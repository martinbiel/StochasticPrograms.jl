var documenterSearchIndex = {"docs":
[{"location":"library/quasigradient/#L-shaped-solvers","page":"Quasi-gradient solvers","title":"L-shaped solvers","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"Documentation for StochasticPrograms.jl's quasi-gradient solvers.","category":"page"},{"location":"library/quasigradient/#Index","page":"Quasi-gradient solvers","title":"Index","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"Pages = [\"quasigradient.md\"]","category":"page"},{"location":"library/quasigradient/#API","page":"Quasi-gradient solvers","title":"API","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"QuasiGradientAlgorithm","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.QuasiGradientAlgorithm","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.QuasiGradientAlgorithm","text":"QuasiGradientAlgorithm\n\nFunctor object for the quasi-gradient algorithm.\n\n...\n\nAlgorithm parameters\n\nlog::Bool = true: Specifices if quasi-gradient procedure should be logged on standard output or not.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"Modules = [QuasiGradient]\nPages   = [\"attributes.jl\", \"MOI_wrapper.jl\"]","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.AbstractQuasiGradientAttribute","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.AbstractQuasiGradientAttribute","text":"AbstractQuasiGradientAttribute\n\nAbstract supertype for attribute objects specific to the L-shaped algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Prox","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Prox","text":"Prox\n\nAn optimizer attribute for specifying a prox policy to be used in the quasi-gradient algorithm. Options are:\n\nNoProx: Unconstrained.\nPolyhedron: QP projection on polyhedral space ?PolyhedronProjection for parameter descriptions. (default)\nAndersonAcceleration:  Anderson acceleration of inner prox step ?AndersonAcceleratedProximal for parameter descriptions.\nNesterov:  Nesterov acceleration of inner prox step ?NesterovProximal for parameter descriptions.\nDryFriction:  Dry-friction acceleration of inner prox step ?DryFrictionProximal for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.ProxParameter","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.ProxParameter","text":"ProxParameter\n\nAbstract supertype for prox-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.StepParameter","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.StepParameter","text":"StepParameter\n\nAbstract supertype for step-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.StepSize","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.StepSize","text":"StepSize\n\nAn optimizer attribute for specifying an aggregation procedure to be used in the quasi-gradient algorithm. Options are:\n\nConstant:  Constant step size ?ConstantStep for parameter descriptions (default)\nDiminishing:  Diminishing step size ?DiminishingStep for parameter descriptions.\nPolyak:  Polyak step size ?PolyakStep for parameter descriptions.\nBB:  Barzilai-Borwein step size ?BBStep for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.SubProblems","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.SubProblems","text":"SubProblems\n\nAn optimizer attribute for specifying if subproblems should be smoothed. Options are:\n\nUnaltered:  Subproblems are solved in their original state (default)\nSmoothed:  Subproblems are smoothed using Moreau envelopes ?SmoothSubProblem for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Termination","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Termination","text":"Termination\n\nAn optimizer attribute for specifying a termination criterion to be used in the quasi-gradient algorithm. Options are:\n\nAfterMaximumIterations:  Terminate after set number of iterations ?MaximumIterations for parameter descriptions (default)\nAtObjectiveThreshold:  Terminate after reaching reference objective ?ObjectiveThreshold for parameter descriptions.\nAtGradientThreshold:  Terminate after reaching zero gradient ?GradientThreshold for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.TerminationParameter","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.TerminationParameter","text":"TerminationParameter\n\nAbstract supertype for termination-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Optimizer","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Optimizer","text":"Optimizer(; <keyword arguments>)\n\nReturn a quasi-gradient optimizer. ...\n\nArguments\n\nmaster_optimizer::AbstractOptimizer: MathOptInterface solver capable of solving linear (and possibly quadratic) programs.\nsubproblem_optimizer::AbstractOptimizer: Optionally specify a different solver for the subproblems.\nexecution::Execution = Serial: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.\nsubproblems::AbstractSubProblemState = Unaltered(): Specify if a smoothing procedure should be applied.\nprox::AbstractProx = Polyhedron(): Specify proximal step.\nstep::AbstractStep = Constant(): Specify step-size\ntermination::AbstractTermination = AfterMaximumIterations(): Specify termination criterion\n<keyword arguments>: Algorithm specific parameters, See ?LShaped for list of possible arguments and default values.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.get_prox_attribute-Tuple{StochasticProgram, String}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.get_prox_attribute","text":"get_prox_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the prox-specific attribute named name in stochasticprogram.\n\nSee also: set_prox_attribute, set_prox_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.get_step_attribute-Tuple{StochasticProgram, String}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.get_step_attribute","text":"get_step_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the step-specific attribute named name in stochasticprogram.\n\nSee also: set_step_attribute, set_step_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.get_termination_attribute-Tuple{StochasticProgram, String}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.get_termination_attribute","text":"get_termination_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the termination-specific attribute named name in stochasticprogram.\n\nSee also: set_termination_attribute, set_termination_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_prox_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_prox_attribute","text":"set_prox_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the prox-specific attribute identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_prox_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_prox_attributes","text":"set_prox_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_prox_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_step_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_step_attribute","text":"set_step_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the step-specific attribute identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_step_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_step_attributes","text":"set_step_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_step_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_termination_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_termination_attribute","text":"set_termination_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the termination-specific attribute identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_termination_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_termination_attributes","text":"set_termination_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_termination_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/quasigradient/#Execution","page":"Quasi-gradient solvers","title":"Execution","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"QuasiGradient.SerialExecution\nQuasiGradient.SynchronousExecution","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.SerialExecution","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.SerialExecution","text":"SerialExecution\n\nFunctor object for using serial execution in a quasi-gradient algorithm. Create by supplying a Serial object through execution in QuasiGradient.Optimizer or by setting the Execution attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.SynchronousExecution","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.SynchronousExecution","text":"SynchronousExecution\n\nFunctor object for using synchronous execution in an quasi-gradient algorithm (assuming multiple Julia cores are available). Create by supplying a Synchronous object through execution in QuasiGradient.Optimizer or by setting the Execution attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#Step","page":"Quasi-gradient solvers","title":"Step","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"QuasiGradient.set_step_attribute\nQuasiGradient.set_step_attributes","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_step_attribute","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_step_attribute","text":"set_step_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the step-specific attribute identified by name to value.\n\n\n\n\n\n","category":"function"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_step_attributes","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_step_attributes","text":"set_step_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_step_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"function"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"Modules = [QuasiGradient]\nPages   = [\"step.jl\", \"constant.jl\", \"diminishing.jl\", \"polyak.jl\", \"bb.jl\"]","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.RawStepParameter","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.RawStepParameter","text":"RawStepParameter\n\nAn optimizer attribute used for raw parameters of the step. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Constant","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Constant","text":"Constant\n\nFactory object for ConstantStep. Pass to step in Quasigradient.Optimizer or set the StepSize attribute. See ?ConstantStep for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.ConstantStep","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.ConstantStep","text":"ConstantStep\n\nFunctor object for using a constant step size in a quasigradient algorithm. Create by supplying a Constant object through step to QuasiGradient.Optimizer or by setting the StepSize attribute.\n\n...\n\nParameters\n\nγ::AbstractFloat = 0.01: Step length\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Diminishing","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Diminishing","text":"Diminishing\n\nFactory object for DiminishingStep. Pass to step in Quasigradient.Optimizer or set the StepSize attribute. See ?DiminishingStep for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.DiminishingStep","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.DiminishingStep","text":"DiminishingStep\n\nFunctor object for using a constant step size in a quasigradient algorithm. Create by supplying a Constant object through step to QuasiGradient.Optimizer or by setting the StepSize attribute.\n\n...\n\nParameters\n\nγ₀::AbstractFloat = 0.1: Nominal step\nη::AbstractFloat = 1.0: Diminishing factor\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Polyak","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Polyak","text":"Polyak\n\nFactory object for PolyakStep. Pass to step in Quasigradient.Optimizer or set the StepSize attribute. See ?PolyakStep for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.PolyakStep","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.PolyakStep","text":"PolyakStep\n\nFunctor object for using the Polyak step size in a quasigradient algorithm. Create by supplying a Polyak object through step to QuasiGradient.Optimizer or by setting the Prox attribute.\n\n...\n\nParameters\n\nγ₀::AbstractFloat = 0.1: Nominal step\nη::AbstractFloat = 1.0: Diminishing factor\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.BB","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.BB","text":"BB\n\nFactory object for BBStep. Pass to step in Quasigradient.Optimizer or set the StepSize attribute. See ?BBStep for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.BBStep","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.BBStep","text":"BBStep\n\nFunctor object for using the Barzilai-Borwein step size in a quasigradient algorithm. Create by supplying a BB object through step to QuasiGradient.Optimizer or by setting the StepSize attribute.\n\n...\n\nParameters\n\nγ₀::AbstractFloat = 0.1: Initial step-size and fallback if BB is numerically unstable\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#Prox","page":"Quasi-gradient solvers","title":"Prox","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"QuasiGradient.set_prox_attribute\nQuasiGradient.set_prox_attributes","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_prox_attribute","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_prox_attribute","text":"set_prox_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the prox-specific attribute identified by name to value.\n\n\n\n\n\n","category":"function"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_prox_attributes","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_prox_attributes","text":"set_prox_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_prox_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"function"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"Modules = [QuasiGradient]\nPages   = [\"prox.jl\", \"no_prox.jl\", \"polyhedron.jl\", \"anderson.jl\", \"nesterov.jl\", \"dry_friction.jl\"]","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.NoProx","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.NoProx","text":"NoProx\n\nFactory object for NoProximal. Passed by default to prox in QuasiGradient.Optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.NoProximal","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.NoProximal","text":"NoProximal\n\nEmpty functor object for running a quasi-gradient algorithm without a prox step.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.ProxPenaltyTerm","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.ProxPenaltyTerm","text":"ProxPenaltyTerm\n\nAn optimizer attribute used to set the proximal term in the prox step. Options are:\n\nQuadratic (default)\nInfNorm\nManhattanNorm\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.RawProxParameter","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.RawProxParameter","text":"RawProxParameter\n\nAn optimizer attribute used for raw parameters of the proximal step. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Polyhedron","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Polyhedron","text":"Polyhedron\n\nFactory object for PolyhedronProjection. Pass to prox in Quasigradient.Optimizer or set the Prox attribute. See ?PolyhedronProjection for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.PolyhedronProjection","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.PolyhedronProjection","text":"PolyhedronProjection\n\nFunctor object for using polyhedral projection in the prox step of a quasigradient algorithm. Create by supplying a Polyhedron object through prox to QuasiGradient.Optimizer or by setting the Prox attribute.\n\n...\n\nParameters\n\npenaltyterm::PenaltyTerm = Quadratic: Specify penaltyterm variant (Quadratic, InfNorm, [ManhattanNorm][@ref])\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.AndersonAcceleratedProximal","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.AndersonAcceleratedProximal","text":"AndersonAcceleratedProximal\n\nFunctor object for using anderson accleration in the prox step of a quasigradient algorithm. Create by supplying an AndersonAcceleration object through prox to QuasiGradient.Optimizer or by setting the Prox attribute.\n\n...\n\nParameters\n\nprox::AbstractProx = Polyhedron: Inner prox step\nm::Integer = 10: Anderson memory\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.AndersonAcceleration","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.AndersonAcceleration","text":"AndersonAcceleration\n\nFactory object for AndersonAcceleratedProximal. Pass to prox in Quasigradient.Optimizer or set the Prox attribute. See ?AndersonAcceleratedProximal for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Nesterov","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Nesterov","text":"Nesterov\n\nFactory object for NesterovProximal. Pass to prox in Quasigradient.Optimizer or set the Prox attribute. See ?NesterovProximal for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.NesterovProximal","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.NesterovProximal","text":"NesterovProximal\n\nFunctor object for using nesterov accleration, with FISTA updates, in the prox step of a quasigradient algorithm. Create by supplying a Nesterov object through prox to QuasiGradient.Optimizer or by setting the Prox attribute.\n\n...\n\nParameters\n\nprox::AbstractProx = Polyhedron: Inner prox step\nstabilizing_projection::Bool = false: Specify if an extra guarding projection should be performed to ensure first-stage feasibility\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.DryFriction","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.DryFriction","text":"DryFriction\n\nFactory object for DryFrictionProximal. Pass to prox in Quasigradient.Optimizer or set the Prox attribute. See ?DryFrictionProximal for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.DryFrictionProximal","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.DryFrictionProximal","text":"DryFrictionProximal\n\nFunctor object for using dry-friction acceleration in the prox step of a quasigradient algorithm. Create by supplying a DryFriction object through prox to QuasiGradient.Optimizer or by setting the Prox attribute.\n\n...\n\nParameters\n\nprox::AbstractProx = Polyhedron: Inner prox step\nγ::AbstractFloat = 0.9: Heavy-ball parameter\nr::AbstractFloat = 1e-3: Dry-friction parameter\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#Termination","page":"Quasi-gradient solvers","title":"Termination","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"QuasiGradient.set_termination_attribute\nQuasiGradient.set_termination_attributes","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_termination_attribute","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_termination_attribute","text":"set_termination_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the termination-specific attribute identified by name to value.\n\n\n\n\n\n","category":"function"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.set_termination_attributes","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.set_termination_attributes","text":"set_termination_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_termination_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"function"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"Modules = [QuasiGradient]\nPages   = [\"termination.jl\", \"iteration.jl\", \"objective.jl\", \"gradient.jl\"]","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.RawTerminationParameter","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.RawTerminationParameter","text":"RawTerminationParameter\n\nAn optimizer attribute used for raw parameters of the termination criterion. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.AfterMaximumIterations","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.AfterMaximumIterations","text":"AfterMaximumIterations\n\nFactory object for MaximumIterations. Pass to terminate in Quasigradient.Optimizer or set the Termination attribute. See ?MaximumIterations for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.MaximumIterations","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.MaximumIterations","text":"MaximumIterations\n\nFunctor object for using maximum number of iterations as termination criterion in a quasigradient algorithm. Create by supplying a AfterMaximumIterations object through terminate to QuasiGradient.Optimizer or by setting the Termination attribute.\n\n...\n\nParameters\n\nmaximum::Integer = 1000: Maximum number of iterations\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.AtObjectiveThreshold","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.AtObjectiveThreshold","text":"AtObjectiveThreshold\n\nFactory object for ObjectiveThreshold. Pass to terminate in Quasigradient.Optimizer or set the Termination attribute. See ?ObjectiveThreshold for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.ObjectiveThreshold","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.ObjectiveThreshold","text":"ObjectiveThreshold\n\nFunctor object for using an objective threshold as termination criterion in a quasigradient algorithm. Create by supplying a AtObjectiveThreshold object through terminate to QuasiGradient.Optimizer or by setting the Termination attribute.\n\n...\n\nParameters\n\nreference::AbstractFloat = 0.0: Reference objective value\nτ::AbstractFloat = 1e-6: Relative tolerance\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.AtGradientThreshold","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.AtGradientThreshold","text":"AtGradientThreshold\n\nFactory object for GradientThreshold. Pass to terminate in Quasigradient.Optimizer or set the Termination attribute. See ?GradientThreshold for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.GradientThreshold","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.GradientThreshold","text":"ObjectiveThreshold\n\nFunctor object for using a zero gradient threshold as termination criterion in a quasigradient algorithm. Create by supplying a AtGradientThreshold object through terminate to QuasiGradient.Optimizer or by setting the Termination attribute.\n\n...\n\nParameters\n\nτ::AbstractFloat = 1e-6: Numerical tolerance for zero gradient\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#Smoothing","page":"Quasi-gradient solvers","title":"Smoothing","text":"","category":"section"},{"location":"library/quasigradient/","page":"Quasi-gradient solvers","title":"Quasi-gradient solvers","text":"QuasiGradient.Unaltered\nQuasiGradient.Smoothed\nQuasiGradient.SubProblem\nQuasiGradient.SmoothSubProblem","category":"page"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Unaltered","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Unaltered","text":"Unaltered\n\nFactory object for using regular SubProblem in the quasi-gradient algorithm. Passed by default to subproblems to QuasiGradient.Optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.Smoothed","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.Smoothed","text":"Smoothed\n\nFactory object for using SmoothSubProblem through Moreau envelopes in the quasi-gradient algorithm. Pass to subproblems in QuasiGradient.Optimizer or by setting the SubProblems attribute. See SmoothSubProblem for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.SubProblem","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.SubProblem","text":"SubProblem\n\nQuasi-gradient subproblem.\n\n\n\n\n\n","category":"type"},{"location":"library/quasigradient/#StochasticPrograms.QuasiGradient.SmoothSubProblem","page":"Quasi-gradient solvers","title":"StochasticPrograms.QuasiGradient.SmoothSubProblem","text":"SmoothSubProblem\n\nSubproblem smoothed using a Moreau envelope.\n\n...\n\nParameters\n\nμ::AbstractFloat = 1.0: Moreau smoothing parameter. Controls the smoothing approximation accuracy.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"manual/data/#Stochastic-data","page":"Stochastic data","title":"Stochastic data","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Decoupling data design and model design is a fundamental principle in StochasticPrograms. This decoupling is achieved through data injection. By data we mean parameters in an optimization problem. In StochasticPrograms, this data is either deterministic and related to a specific stage, or uncertain and related to a specific scenario.","category":"page"},{"location":"manual/data/#Stage-data","page":"Stochastic data","title":"Stage data","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Stage data is related to parameters that always appear in the first or second stage of a stochastic program. These parameters are deterministic and are the same across all scenarios. Such parameters are conveniently included in stochastic models using @parameters. To showcase, we consider a minimal stochastic program:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"beginaligned\n operatorname*maximize_x in mathbbR  quad x + operatornamemathbbE_omega leftQ(x xi(omega))right \n textst  quad l_1 leq x leq u_1\nendaligned","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"where","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"beginaligned\n Q(x xi(omega)) = max_y in mathbbR  quad q_omega y \n textst  quad y + x leq U \n  quad l_2 leq y leq u_2\nendaligned","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"and the stochastic variable","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"  xi(omega) = q_omega","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"takes on the value 1 or -1 with equal probability. Here, the first stage contains the two parameters: l_1 and u_1. The second stage contains the three scenario-independent parameters: U, l_2, and u_2. The following defines this problem in StochasticPrograms, with some chosen deault parameter values:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\nusing GLPK\n\nsm = @stochastic_model begin\n    @stage 1 begin\n        @parameters begin\n            l₁ = -1.\n            u₁ = 1.\n        end\n        @decision(model, l₁ <= x <= u₁)\n        @objective(model, Max, x)\n    end\n    @stage 2 begin\n        @parameters begin\n            U = 2.\n            l₂ = -1.\n            u₂ = 1.\n        end\n        @uncertain q\n        @variable(model, l₂ <= y <= u₂)\n        @objective(model, Max, q*y)\n        @constraint(model, y + x <= U)\n    end\nend\n\nξ₁ = @scenario q = 1. probability = 0.5\nξ₂ = @scenario q = -1. probability = 0.5\n\nsp = instantiate(sm, [ξ₁,ξ₂], optimizer = GLPK.Optimizer)\n\nprintln(sp)\n\nprint(\"VRP = $(VRP(sp))\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, we can investigate the impact of the stage parameters by changing them slightly and reinstantiate the problem. This is achieved by supplying the new parameter values as keyword arguments to instantiate:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sp = instantiate(sm, [ξ₁,ξ₂], l₁ = -2., u₁ = 2., U = 2., l₂ = -0.5, u₂ = 0.5, optimizer = GLPK.Optimizer)\n\nprintln(sp)\n\nprint(\"VRP = $(VRP(sp))\")","category":"page"},{"location":"manual/data/#Scenario-data","page":"Stochastic data","title":"Scenario data","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Any uncertain parameter in the second stage of a stochastic program should be included in some predefined AbstractScenario type. Hence, all uncertain parameters in a stochastic program must be identified before defining the models. In brief, StochasticPrograms demands two functions from this abstraction. The discrete probability of a given AbstractScenario occurring should be returned from probability. Also, the expected scenario out of a collection of given AbstractScenarios should be returned by expected. The predefined Scenario type adheres to this abstraction and is the recommended option for most models, as exemplified in the Quick start.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Instances of Scenario that match an @uncertain declaration are conveniently created using the @scenario macro. The syntax of these macros match, as is shown in the examples below. The following is a declaration of four scalar uncertain values:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"@uncertain q₁ q₂ d₁ d₂","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"which is paired with a matching instantiation of a scenario containing these scalars:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₁ = @scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Below, an equivalent formulation is given that instead defines a random vector.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"@uncertain ξ[i in 1:4]","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"paired with","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₁ = @scenario ξ[i in 1:4] = [24.0, 28.0, 500.0, 100.0] probability = 0.4","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Multidimensional random data is also supported. A simple example is given below.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"@uncertain ξ[i in 1:2, j in 1:3]","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"paired with","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₁ = @scenario ξ[i in 1:2, j in 1:3] = rand(2, 3) probability = rand()","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The assignment syntax is used to directly create the random matrix. The dimensions of the RHS must match the index declaration, which in turn must match the @uncertain declaration. It is also possible to construct more complex examples using JuMP's container syntax. For example,","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"@uncertain ξ[i in 1:3, k in [:a, :b, :c]]","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"and","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"data = Dict((1, :a) => 1.0, (2, :a) => 2.0, (3, :a) => 3.0,\n            (1, :b) => 4.0, (2, :b) => 5.0, (3, :b) => 6.0,\n            (1, :c) => 7.0, (2, :c) => 8.0, (3, :c) => 9.0)\nξ₁ = @scenario ξ[i in 1:3, k in [:a, :b, :c]] data[i,k] probability = rand()","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"or the shorthand:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₁ = @scenario ξ[i in 1:3, k in [:a, :b, :c]] = [1. 2. 3.;\n                                                 4. 5. 6.;\n                                                 7. 8. 9] probability = rand()","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Triangular and conditional indexing work as well:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"@uncertain ξ[i in 1:3, j in 1:3; i <= j]","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"and","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₁ = @scenario ξ[i in 1:3, j in 1:3; i <= j] i+j probability = rand()","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Error checking is performed during model instantiation to ensure that all provided scenarios adhere to the @uncertain declaration.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"In addition, StochasticPrograms provides a convenience macro, @define_scenario, for creating scenario types that also adhere to the scenario abstraction. The following is an alternative way to define a scenario structure for the simple problem introduced in the Quick start:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@define_scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, xi_1 and xi_2 can be created through:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₁ = SimpleScenario(24.0, 28.0, 500.0, 100.0, probability = 0.4)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"and","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ₂ = SimpleScenario(28.0, 32.0, 300.0, 300.0, probability = 0.6)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The defined SimpleScenarios automatically have the [AbstractScenario] functionality. For example, we can check the discrete probability of a given scenario occuring:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"probability(ξ₁)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Moreover, we can form the expected scenario out of a given set:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"ξ̄ = expected([ξ₁, ξ₂])","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"To use the defined scenario in a model, the following @uncertain syntax is used:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"@uncertain ξ from SimpleScenario","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"There are some caveats to note. First, the autogenerated requires an additive zero element of the introduced scenario type. For simple numeric types this is autogenerated as well. However, say that we want to extend the above scenario with some vector parameter of size 2:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@define_scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"In this case, we must provide an implementation of zero using @zero:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@define_scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\n\n    @zero begin\n        return ExampleScenario(0.0, [0.0, 0.0])\n    end\nend\n\ns₁ = ExampleScenario(1., ones(2), probability = 0.5)\ns₂ = ExampleScenario(5., -ones(2), probability = 0.5)\n\nprintln(\"Probability of s₁: $(probability(s₁))\")\n\ns = expected([s₁, s₂])\n\nprintln(\"Expectation over s₁ and s₂: $s\")\nprintln(\"Expectated X: $(s.scenario.X)\")\nprintln(\"Expectated Y: $(s.scenario.Y)\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Another caveat is that the expected function can only be auto generated for fields that support addition and scalar multiplication with Float64. Consider:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@define_scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\n    Z::Int\n\n    @zero begin\n        return ExampleScenario(0.0, [0.0, 0.0], 0)\n    end\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Again, the solution is to provide an implementation of expected, this time using @expectation:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@define_scenario ExampleScenario = begin\n    X::Float64\n    Y::Vector{Float64}\n    Z::Int\n\n    @zero begin\n        return ExampleScenario(0.0, [0.0, 0.0], 0)\n    end\n\n    @expectation begin\n        X = sum([probability(s)*s.X for s in scenarios])\n        Y = sum([probability(s)*s.Y for s in scenarios])\n        Z = sum([round(Int, probability(s)*s.Z) for s in scenarios])\n        return ExampleScenario(X, Y, Z)\n    end\nend\n\ns₁ = ExampleScenario(1., ones(2), 1, probability = 0.5)\ns₂ = ExampleScenario(5., -ones(2), -1, probability = 0.5)\n\nprintln(\"Probability of s₁: $(probability(s₁))\")\n\ns = expected([s₁, s₂])\n\nprintln(\"Expectation over s₁ and s₂: $s\")\nprintln(\"Expectated X: $(s.scenario.X)\")\nprintln(\"Expectated Y: $(s.scenario.Y)\")\nprintln(\"Expectated Z: $(s.scenario.Z)\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"For most problems, @define_scenario will probably be adequate. Otherwise consider defining Custom scenarios.","category":"page"},{"location":"manual/data/#Sampling","page":"Stochastic data","title":"Sampling","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using Random\nRandom.seed!(1)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Typically, we do not have exact knowledge of all possible future scenarios. However, we often have access to some model of the uncertainty. For example, scenarios could originate from:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"A stochastic variable with known distribution\nA time series fitted to data\nA nerual network prediction","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Even if the exact scenario distribution is unknown, or not all possible scenarios are available, we can still formulate a stochastic program that approximates the model we wish to formulate. This is achieved through a technique called sampled average approximation, which is based on sampling. The idea is to sample a large number n of scenarios with equal probability frac1n and then use them to generate and solve a stochastic program. By the law of large numbers, the result will converge with probability 1 to the \"true\" solution with increasing n.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"StochasticPrograms accepts AbstractSampler objects in place of AbstractScenario. However, an AbstractSampler is always linked to some underlying AbstractScenario type, which is reflected in the resulting stochastic program as well.","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The most basic sampler is the included Sampler, which is used to sample basic Scenarios. Consider","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\nsampler = Sampler() do\n    return Scenario(q₁ = 24.0 + randn(), q₂ = 28.0 + randn(), d₁ = 500.0 + randn(), d₂ = 100 + randn(), probability = rand())\nend\n\nsampler()","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Samplers can also be conveniently created using @sampler. We can define a simple scenario type and a simple sampler as follows:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using StochasticPrograms\n\n@define_scenario ExampleScenario = begin\n    w::Float64\nend\n\n@sampler ExampleSampler = begin\n    w::Float64\n\n    ExampleSampler(w::AbstractFloat) = new(w)\n\n    @sample ExampleScenario begin\n        w = sampler.w\n        return ExampleScenario(w*randn(), probability = rand())\n    end\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"This creates a new AbstractSampler type called ExampleSampler, which samples ExampleScenarios. Now, we can create a sampler object and sample a scenario","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sampler = ExampleSampler(2.)\n\nξ = sampler()\n\nprintln(ξ)\nprintln(\"ξ: $(ξ.w)\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, lets create a stochastic model using the ExampleScenario type:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sm = @stochastic_model begin\n    @stage 1 begin\n        @decision(model, x >= 0)\n        @objective(model, Min, x)\n    end\n    @stage 2 begin\n        @uncertain w from ExampleScenario\n        @variable(model, y)\n        @objective(model, Min, y)\n        @constraint(model, y + x == w)\n    end\nend","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Now, we can sample 5 scenarios using the first sampler to generate 5 subproblems:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"sp = instantiate(sm, sampler, 5)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Printing yields:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"print(sp)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Sampled stochastic programs are solved as usual:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using GLPK\n\nset_optimizer(sp, GLPK.Optimizer)\n\noptimize!(sp)\n\nprintln(\"optimal decision: $(optimal_decision(sp))\")\nprintln(\"optimal value: $(objective_value(sp))\")","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"Again, if the functionality offered by @sampler is not adequate, consider Custom scenarios.","category":"page"},{"location":"manual/data/#Custom-scenarios","page":"Stochastic data","title":"Custom scenarios","text":"","category":"section"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"using Random\nRandom.seed!(1)","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"More complex scenario designs are probably not implementable using @define_scenario. However, it is still possible to create a custom scenario type as long as:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The type is a subtype of AbstractScenario\nThe type implements probability\nThe type implements expected, which should return an additive zero element if given an empty array","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The restriction on expected is there to support taking expectations in a distributed environment. We are also free to define custom sampler objects, as long as:","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"The sampler type is a subtype of AbstractSampler\nThe sampler type implements a functor call that performs the sampling","category":"page"},{"location":"manual/data/","page":"Stochastic data","title":"Stochastic data","text":"See the Continuous scenario distribution for an example of custom scenario/sampler implementations.","category":"page"},{"location":"library/crash/#Crash","page":"Crash","title":"Crash","text":"","category":"section"},{"location":"library/crash/","page":"Crash","title":"Crash","text":"Documentation for StochasticPrograms.jl's crash methods, for use in structured solvers and sample-based solvers.","category":"page"},{"location":"library/crash/#Index","page":"Crash","title":"Index","text":"","category":"section"},{"location":"library/crash/","page":"Crash","title":"Crash","text":"Pages = [\"crash.md\"]","category":"page"},{"location":"library/crash/#Crash-methods","page":"Crash","title":"Crash methods","text":"","category":"section"},{"location":"library/crash/","page":"Crash","title":"Crash","text":"Modules = [Crash]\nPages   = [\"crash.jl\"]","category":"page"},{"location":"library/crash/#StochasticPrograms.Crash","page":"Crash","title":"StochasticPrograms.Crash","text":"Crash\n\nCollection of crash methods used to generate initial decisions in structured algorithms.\n\n...\n\nAvailable crash methods\n\nNone\nEVP\nScenario\nCustom\n\n...\n\nExamples\n\nThe following solves a stochastic program sp created in StochasticPrograms.jl using an L-shaped algorithm with trust-region and Clp as an lpsolver and by generating an initial decision with the EVP crash.\n\njulia> optimize!(sp, solver = LShapedSolver(GLPKSolverLP(), crash=Crash.EVP(), regularize = TrustRegion()))\nL-Shaped Gap  Time: 0:00:00 (8 iterations)\n  Objective:       -855.8333333333339\n  Gap:             0.0\n  Number of cuts:  4\n  Iterations:      8\n:Optimal\n\n\n\n\n\n","category":"module"},{"location":"library/crash/#StochasticPrograms.Crash.Custom","page":"Crash","title":"StochasticPrograms.Crash.Custom","text":"Custom(x₀)\n\nUse the user-supplied x₀ as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.EVP","page":"Crash","title":"StochasticPrograms.Crash.EVP","text":"EVP\n\nSolve the expected value problem corresponding to the stochastic program and use the expected value solution as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.FeasiblePoint","page":"Crash","title":"StochasticPrograms.Crash.FeasiblePoint","text":"FeasiblePoint\n\nGenerate a feasible first-stage decision as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.None","page":"Crash","title":"StochasticPrograms.Crash.None","text":"None\n\nRandomize the initial decision (default).\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.PreSolve","page":"Crash","title":"StochasticPrograms.Crash.PreSolve","text":"PreSolve\n\nRun a provided (ideally suboptimal) optimization procedure and use the (sub)optimal solution as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"library/crash/#StochasticPrograms.Crash.Scenario","page":"Crash","title":"StochasticPrograms.Crash.Scenario","text":"Scenario\n\nSolve the wait-and-see problem corresponding a supplied scenario and use the optimal solution as initial decision.\n\n\n\n\n\n","category":"type"},{"location":"manual/quickstart/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"manual/quickstart/#Installation","page":"Quick start","title":"Installation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"StochasticPrograms is installed as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"pkg> add StochasticPrograms","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Afterwards, the functionality can be made available in a module or REPL through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using StochasticPrograms","category":"page"},{"location":"manual/quickstart/#Stochastic-programs","page":"Quick start","title":"Stochastic programs","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Consider some probability space (OmegamathcalFpi) where Omega is a sample space, mathcalF is a sigma-algebra over Omega and pi mathcalF to 01 is a probability measure. Let xi(omega) Omega to mathbbR^N be some random variable on Omega with finite second moments. A two-stage linear stochastic program has the following mathematical representation:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n operatorname*minimize_x in mathbbR^n  quad c^T x + operatornamemathbbE_omega leftQ(xxi(omega))right \n textst  quad Ax = b \n  quad x geq 0\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"where","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n    Q(xxi(omega)) = min_y in mathbbR^m  quad q_omega^T y \n    textst  quad T_omegax + Wy = h_omega \n     quad y geq 0\n  endaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the sample space Omega is finite, stochastic program has a closed form that can be represented on a computer. Such functionality is provided by StochasticPrograms. If the sample space Omega is infinite, sampling techniques can be used to represent the stochastic program using finite instances generated using  sample.","category":"page"},{"location":"manual/quickstart/#A-simple-stochastic-program","page":"Quick start","title":"A simple stochastic program","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To showcase the use of StochasticPrograms we will walk through a simple example. Consider the following stochastic program: (taken from Introduction to Stochastic Programming).","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n operatorname*minimize_x_1 x_2 in mathbbR  quad 100x_1 + 150x_2 + operatornamemathbbE_omega leftQ(x_1x_2xi(omega))right \n textst  quad x_1+x_2 leq 120 \n  quad x_1 geq 40 \n  quad x_2 geq 20\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"where","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n Q(x_1x_2xi(omega)) = min_y_1y_2 in mathbbR  quad q_1(omega)y_1 + q_2(omega)y_2 \n textst  quad 6y_1+10y_2 leq 60x_1 \n  quad 8y_1 + 5y_2 leq 80x_2 \n  quad 0 leq y_1 leq d_1(omega) \n  quad 0 leq y_2 leq d_2(omega)\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and the stochastic variable","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"  xi(omega) = beginpmatrix\n     q_1(omega)  q_2(omega)  d_1(omega)  d_2(omega)\n  endpmatrix^T","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"parameterizes the second-stage model. In the following, we consider how to model, analyze, and solve this stochastic program using StochasticPrograms. In many examples, a MathOptInterface solver is required. Hence, we load the GLPK solver:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using GLPK","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We also load Ipopt to solve quadratic problems:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using Ipopt","category":"page"},{"location":"manual/quickstart/#Stochastic-model-definition","page":"Quick start","title":"Stochastic model definition","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"First, we define a stochastic model that describes the introduced stochastic program above.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"@stochastic_model simple_model begin\n    @stage 1 begin\n        @decision(simple_model, x₁ >= 40)\n        @decision(simple_model, x₂ >= 20)\n        @objective(simple_model, Min, 100*x₁ + 150*x₂)\n        @constraint(simple_model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @uncertain q₁ q₂ d₁ d₂\n        @recourse(simple_model, 0 <= y₁ <= d₁)\n        @recourse(simple_model, 0 <= y₂ <= d₂)\n        @objective(simple_model, Max, q₁*y₁ + q₂*y₂)\n        @constraint(simple_model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(simple_model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The optimization models in the first and second stage are defined using JuMP syntax inside @stage blocks. Every first-stage variable is annotated with @decision. This allows us to use the variable in the second stage. The @uncertain annotation specifies that the variables q₁, q₂, d₁ and d₂ are uncertain. Instances of the uncertain variables will later be injected to create instances of the second stage model. We will consider two stochastic models of the uncertainty and showcase the main functionality of the framework for each.","category":"page"},{"location":"manual/quickstart/#Finite-sample-space","page":"Quick start","title":"Finite sample space","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"First, let xi be a discrete distribution, taking on the value","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"  xi_1 = beginpmatrix\n    24  28  500  100\n  endpmatrix^T","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"with probability 04 and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"  xi_1 = beginpmatrix\n    28  32  300  300\n  endpmatrix^T","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"with probability 06.","category":"page"},{"location":"manual/quickstart/#Instantiation","page":"Quick start","title":"Instantiation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"First, we create the two instances xi_1 and xi_2 of the random variable. For simple models this is conveniently achieved through the Scenario type. xi_1 and xi_2 can be created as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"ξ₁ = @scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"ξ₂ = @scenario q₁ = 28.0 q₂ = 32.0 d₁ = 300.0 d₂ = 300.0 probability = 0.6","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"where the variable names should match those given in the @uncertain annotation. We are now ready to instantiate the stochastic program introduced above.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"sp = instantiate(simple_model, [ξ₁, ξ₂], optimizer = GLPK.Optimizer)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"By default, the stochastic program is instantiated with a deterministic equivalent structure. It is straightforward to work out the extended form because the example problem is small:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n operatorname*minimize_x_1 x_2 y_11 y_21 y_12 y_22 in mathbbR  quad 100x_1 + 150x_2 - 96y_11 - 112y_21 - 168y_12 - 192y_22  \n textst  quad x_1 + x_2 leq 120 \n  quad 6 y_11 + 10 y_21 leq 60 x_1 \n  quad 8 y_11 + 5 y_21 leq 80 x_2 \n  quad 6 y_12 + 10 y_22 leq 60 x_1 \n  quad 8 y_12 + 5 y_22 leq 80 x_2 \n  quad x_1 geq 40 \n  quad x_2 geq 20 \n  quad 0 leq y_11 leq 500 \n  quad 0 leq y_21 leq 100 \n  quad 0 leq y_12 leq 300 \n  quad 0 leq y_22 leq 300\nendaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can print the stochastic program and confirm that it indeed models the example recourse problem given above:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"print(sp)","category":"page"},{"location":"manual/quickstart/#Optimization","page":"Quick start","title":"Optimization","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The most common operation is to solve the instantiated stochastic program for an optimal first-stage decision. We instantiated the problem with the GLPK optimizer, so we can solve the problem directly:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimize!(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can then query the resulting optimal value:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and the optimal first-stage decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimal_decision(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Alternatively, we can solve the problem with a structure-exploiting solver. The framework provides both LShaped and ProgressiveHedging solvers. We first re-instantiate the problem using an L-shaped optimizer:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"sp_lshaped = instantiate(simple_model, [ξ₁, ξ₂], optimizer = LShaped.Optimizer)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"It should be noted that the memory representation of the stochastic program is now different. Because we instantiated the model with an L-shaped optimizer it generated the program according to a stage-decomposition structure:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"print(sp_lshaped)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To solve the problem with L-shaped, we must first specify internal optimizers that can solve emerging subproblems:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"set_optimizer_attribute(sp_lshaped, MasterOptimizer(), GLPK.Optimizer)\nset_optimizer_attribute(sp_lshaped, SubProblemOptimizer(), GLPK.Optimizer)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can now run the optimization procedure:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimize!(sp_lshaped)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"L-Shaped Gap  Time: 0:00:01 (6 iterations)\n  Objective:       -855.8333333333339\n  Gap:             0.0\n  Number of cuts:  7\n  Iterations:      6","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and verify that we get the same results:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(sp_lshaped)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"-855.8333333333339","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimal_decision(sp_lshaped)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"2-element Array{Float64,1}:\n 46.66666666666673\n 36.25000000000003","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Likewise, we can solve the problem with progressive-hedging. Consider:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"sp_progressivehedging = instantiate(simple_model, [ξ₁, ξ₂], optimizer = ProgressiveHedging.Optimizer)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Stochastic program with:\n * 2 decision variables\n * 2 recourse variables\n * 2 scenarios of type Scenario\nStructure: Scenario-decomposition\nSolver name: Progressive-hedging with fixed penalty","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Now, the induced structure is the scenario-decomposition that decomposes the stochastic program completely into subproblems over the scenarios. Consider the printout:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"print(sp_progressivehedging)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Scenario problems\n==============\nSubproblem 1 (p = 0.40):\nMin 100 x₁ + 150 x₂ - 24 y₁ - 28 y₂\nSubject to\n y₁ ≥ 0.0\n y₂ ≥ 0.0\n y₁ ≤ 500.0\n y₂ ≤ 100.0\n x₁ ∈ Decisions\n x₂ ∈ Decisions\n x₁ ≥ 40.0\n x₂ ≥ 20.0\n x₁ + x₂ ≤ 120.0\n -60 x₁ + 6 y₁ + 10 y₂ ≤ 0.0\n -80 x₂ + 8 y₁ + 5 y₂ ≤ 0.0\n\nSubproblem 2 (p = 0.60):\nMin 100 x₁ + 150 x₂ - 28 y₁ - 32 y₂\nSubject to\n y₁ ≥ 0.0\n y₂ ≥ 0.0\n y₁ ≤ 300.0\n y₂ ≤ 300.0\n x₁ ∈ Decisions\n x₂ ∈ Decisions\n x₁ ≥ 40.0\n x₂ ≥ 20.0\n x₁ + x₂ ≤ 120.0\n -60 x₁ + 6 y₁ + 10 y₂ ≤ 0.0\n -80 x₂ + 8 y₁ + 5 y₂ ≤ 0.0\n\nSolver name: Progressive-hedging with fixed penalty","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To solve the problem with progressive-hedging, we must also specify an internal optimizers that can solve the subproblems:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"set_optimizer_attribute(sp_progressivehedging, SubProblemOptimizer(), Ipopt.Optimizer)\nset_suboptimizer_attribute(sp_progressivehedging, MOI.RawParameter(\"print_level\"), 0) # Silence Ipopt","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can now run the optimization procedure:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimize!(sp_progressivehedging)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Progressive Hedging Time: 0:00:07 (303 iterations)\n  Objective:   -855.5842547490254\n  Primal gap:  7.2622997706326046e-6\n  Dual gap:    8.749063651111478e-6\n  Iterations:  302","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and verify that we get the same results:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(sp_progressivehedging)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"-855.5842547490254","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimal_decision(sp_progressivehedging)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"2-element Array{Float64,1}:\n 46.65459574079722\n 36.24298005619633","category":"page"},{"location":"manual/quickstart/#Decision-evaluation","page":"Quick start","title":"Decision evaluation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Decision evaluation is an important concept in stochastic programming. The expected result of taking a given first-stage decision x is given by","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"V(x) = c^T x + operatornamemathbbE_omega leftQ(xxi(omega))right","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the sample space is finite, the above expressions has a closed form that is readily calculated. Consider the following first-stage decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x = [40., 20.]","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The expected result of taking this decision in the simple finite model can be determined through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Internally, this fixes all occurances of the first-stage variables in the deterministic equivalent and solves the resulting problem. An equivalent approach is to fix the decisions manually:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"another_sp = instantiate(simple_model, [ξ₁, ξ₂], optimizer = GLPK.Optimizer)\nfix.(all_decision_variables(another_sp, 1), x)\noptimize!(another_sp)\nobjective_value(another_sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Decision evaluation is supported by the other storage structures as well:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp_lshaped, x)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"-470.39999999999964","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp_progressivehedging, x)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"-470.40000522896185","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"In a stage-decomposition structure, the occurances of first-stage decisions in the second-stage subproblems are treated as known decisions with parameter values that can be set. We can explicitly create such a subproblem to clearly see this in action:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"print(outcome_model(sp, x, ξ₁))","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Moreover, we can evaluate the result of the decision in a given scenario, i.e. solving a single outcome model, through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x, ξ₁)","category":"page"},{"location":"manual/quickstart/#Solution-caching","page":"Quick start","title":"Solution caching","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"StochasticPrograms minimizes memory usage by reusing the same underlying structure when optimizing the model as when evaluating a decision. As a consequence, calls to for example evaluate_decision replaces any previosly found optimal solution. Hence,","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimal_decision(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"returns values consistent with above call to evaluate_decision. Optionally, the solution obtained from calling optimize! can be cached by setting a cache flag during the call:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimize!(sp; cache = true)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"or by directly calling cache_solution!:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"cache_solution!(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"after optimizing. Now, we again obtain","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimal_decision(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"However, if we now also re-run decision evaluation:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"the solution stays consistent with the optimization call:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimal_decision(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The caching procedure attempts to save as many MathOptInterface attributes as possible, so for example dual values of the constraints should stay consistent with the optimized model as well. For larger models, the caching procedure can be time consuming and is therefore not enabled by default. For the same reason, the subproblem solutions are only cached for models with fewer than 100 scenarios. The first-stage solution is always cached if caching is enabled.","category":"page"},{"location":"manual/quickstart/#Stochastic-performance","page":"Quick start","title":"Stochastic performance","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Apart from solving the stochastic program, we can compute two classical measures of stochastic performance. The first measures the value of knowing the random outcome before making the decision. This is achieved by taking the expectation in the original model outside the minimization, to obtain the wait-and-see problem:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"mathrmEWS = operatornamemathbbE_omegaleft\n  beginaligned\n    min_x in mathbbR^n  quad c^T x + Q(xxi(omega)) \n    textst  quad Ax = b \n     quad x geq 0\n  endalignedright","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Now, the first- and second-stage decisions are taken with knowledge about the uncertainty. If we assume that we know what the actual outcome will be, we would be interested in the optimal course of action in that scenario. This is the concept of wait-and-see models. For example if ξ₁ is believed to be the actual outcome, we can define a wait-and-see model as follows:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"ws = WS(sp, ξ₁)\nprint(ws)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The optimal first-stage decision in this scenario can be determined through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x₁ = wait_and_see_decision(sp, ξ₁)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can evaluate this decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x₁)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The outcome is of course worse than taking the optimal decision. However, it would perform better if ξ₁ is the actual outcome:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, x₁, ξ₁)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"as compared to:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sp, optimal_decision(sp), ξ₁)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The difference between the expected wait-and-see value and the value of the recourse problem is known as the expected value of perfect information:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"mathrmEVPI = mathrmEWS - mathrmVRP","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The EVPI measures the expected loss of not knowing the exact outcome beforehand. It quantifies the value of having access to an accurate forecast. We calculate it in the framework through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"EVPI(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"EVPI is supported in the other structures as well:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"EVPI(sp_lshaped)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"662.9166666666661","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"EVPI(sp_progressivehedging)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"663.165763660815","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can also compute EWS directly using EWS. Note, that the scenario-decomposition structure is ideal for solving wait-and-see type problems.","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the expectation in the original model is instead taken inside the second-stage objective function Q, we obtain the expected-value-problem:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"beginaligned\n    operatorname*minimize_x in mathbbR^n  quad c^T x + Q(xoperatornamemathbbE_omegaxi(omega)) \n    textst  quad Ax = b \n     quad x geq 0\n  endaligned","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The solution to the expected-value-problem is known as the expected value decision, and is denoted by barx. We can compute it through","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"x̄ = expected_value_decision(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The expected result of taking the expected value decision is known as the expected result of the expected value decision:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"mathrmEEV = c^T barx + operatornamemathbbE_xiQ(barxxi(omega))","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The difference between the value of the recourse problem and the expected result of the expected value decision is known as the value of the stochastic solution:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"mathrmVSS = mathrmEEV - mathrmVRP","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The VSS measures the expected loss of ignoring the uncertainty in the problem. A large VSS indicates that the second stage is sensitive to the stochastic data. We calculate it using","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"VSS(sp)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"VSS is supported in the other structures as well:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"VSS(sp_lshaped)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"286.91666666666606","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"VSS(sp_progressivehedging)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"286.6675823650668","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can also compute EEV directly using EEV. Note, that the stage-decomposition structure is ideal for solving VSS type problems.","category":"page"},{"location":"manual/quickstart/#Infinite-sample-space","page":"Quick start","title":"Infinite sample space","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"In the above, the probability space consists of only two scenarios and the stochastic program can hence be represented in a closed form. If it instead holds that xi follows say a normal distribution, then it is no longer possible to represent the full stochastic program since this would require infinite scenarios. We then revert to sampling-based techniques. For example, let xi sim mathcalN(mu Sigma) with","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"mu = beginpmatrix\n 24 \n 32 \n 400 \n 200\nendpmatrix quad Sigma = beginpmatrix\n 2  05  0  0 \n 05  1  0  0 \n 0  0  50  20 \n 0  0  20  30\nendpmatrix","category":"page"},{"location":"manual/quickstart/#Instantiation-2","page":"Quick start","title":"Instantiation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To approximate the resulting stochastic program in StochasticPrograms, we first create a sampler object capable of generating scenarios from this distribution. This is most conveniently achieved using the @sampler macro:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"using Distributions\n\n@sampler SimpleSampler = begin\n    N::MvNormal\n\n    SimpleSampler(μ, Σ) = new(MvNormal(μ, Σ))\n\n    @sample Scenario begin\n        x = rand(sampler.N)\n        return Scenario(q₁ = x[1], q₂ = x[2], d₁ = x[3], d₂ = x[4])\n    end\nend\n\nμ = [24, 32, 400, 200]\nΣ = [2 0.5 0 0\n     0.5 1 0 0\n     0 0 50 20\n     0 0 20 30]\n\nsampler = SimpleSampler(μ, Σ)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Now, we can use the same stochastic model created before and the created sampler object to generate a sampled approximation of the stochastic program. For now, we create a small sampled model of just 5 scenarios:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"sampled_sp = instantiate(simple_model, sampler, 5, optimizer = GLPK.Optimizer)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"An optimal solution to this sampled model approximates the optimal solution to the infinite model in the sense that the empirical average second-stage cost converges pointwise with probability one to the true optimal value as the number of sampled scenarios goes to infinity. Moreoever, we can apply a central limit theorem to calculate confidence intervals around the objective value, as well as around the EVPI and VSS. This is the basis for the technique known as sample average approximation. In the following, we show how we can achieve approximations of the finite sample space functionality. Note that most operations are now performed directly on the simple_model object together with a supplied sampler object.","category":"page"},{"location":"manual/quickstart/#Optimization-2","page":"Quick start","title":"Optimization","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"To approximately solve the stochastic program over normally distributed scenarios, we must first set a sample-based solver. The framework provides the SAA solver:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"set_optimizer(simple_model, SAA.Optimizer)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We must first set an instance optimizer that can solve emerging sampled instances:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"set_optimizer_attribute(simple_model, InstanceOptimizer(), GLPK.Optimizer)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Note, that we can use a structure-exploiting solver for the instance optimizer. We now set a desired confidence level and the number of samples:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"set_optimizer_attribute(simple_model, Confidence(), 0.9)\nset_optimizer_attribute(simple_model, NumSamples(), 100)\nset_optimizer_attribute(simple_model, NumEvalSamples(), 300)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can now calculate a confidence interval around the optimal value through:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"confidence_interval(simple_model, sampler)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"The optimization procedure provided by SAA iteratively calculates confidence intervals for growing sample sizes until a desired relative tolerance is reached:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"set_optimizer_attribute(simple_model, RelativeTolerance(), 5e-2)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"We can now optimize the model:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"optimize!(simple_model, sampler)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"SAA gap Time: 0:00:03 (4 iterations)\n  Confidence interval:  Confidence interval (p = 95%): [-1095.65 − -1072.36]\n  Relative error:       0.021487453807842415\n  Sample size:          64","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and query the result:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(simple_model);objective_value(simple_model);","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"objective_value(simple_model) = Confidence interval (p = 95%): [-1095.65 − -1072.36]","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Note, that we can just replace the sampler object to use another model of the uncertainty.","category":"page"},{"location":"manual/quickstart/#Decision-evaluation-2","page":"Quick start","title":"Decision evaluation","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"If the sample space is infinite, or if the underlying random variable xi is continuous, a first-stage decision also can only be evaluated in a stochastic sense. For example, note the result of evaluating the decision on the sampled model created above:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(sampled_sp, x)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and compare it to the result of evaluating it on another sampled model of similar size:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"another_sp = instantiate(simple_model, sampler, 5, optimizer = GLPK.Optimizer)\nevaluate_decision(another_sp, x)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"which, if any, of these values should be a candidate for the true value of V(x)? A more precise result is obtained by evaluating the decision using a sampled-based approach:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"evaluate_decision(simple_model, x, sampler)","category":"page"},{"location":"manual/quickstart/#Stochastic-performance-2","page":"Quick start","title":"Stochastic performance","text":"","category":"section"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Using the same techniques as above, we can calculate confidence intervals around the EVPI and VSS:","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"EVPI(simple_model, sampler)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Confidence interval (p = 99%): [32.96 − 144.51]","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"and","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"VSS(simple_model, sampler)","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Warning: VSS is not statistically significant to the chosen confidence level and tolerance\nConfidence interval (p = 95%): [-0.05 − 0.05]","category":"page"},{"location":"manual/quickstart/","page":"Quick start","title":"Quick start","text":"Note, that the VSS is not statistically significant. This is not surprising for a normally distributed uncertainty model. The expected value decision is expected to perform well.","category":"page"},{"location":"manual/decisions/#Decision-API","page":"Decision API","title":"Decision API","text":"","category":"section"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"StochasticPrograms provides an extended version of JuMPs API for decision variables/constraints/objectives with stage and scenario dependence. Consider the following problem:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"using StochasticPrograms\nusing GLPK\n\nξ₁ = @scenario a = 1 probability = 0.5\nξ₂ = @scenario a = 2 probability = 0.5\n\nsp = StochasticProgram([ξ₁,ξ₂], Deterministic())\n@first_stage sp = begin\n    @decision(sp, x >= 2)\n    @variable(sp, w)\n    @objective(sp, Min, x)\nend\n@second_stage sp = begin\n    @known(sp, x)\n    @uncertain a\n    @recourse(sp, y >= 1/a)\n    @objective(sp, Max, y)\n    @constraint(sp, con, a*y <= x)\nend","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"A first-stage decision and a second-stage recourse decision has been identified. We include a printout of the stochastic program for reference:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"print(sp)","category":"page"},{"location":"manual/decisions/#Decision-variables","page":"Decision API","title":"Decision variables","text":"","category":"section"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"All variables annotated with either @decision or @recourse become available through the API. We can query all such variables:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"all_decision_variables(sp)","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"stage-wise lists can also be obtained:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"all_decision_variables(sp, 1)","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"and","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"all_decision_variables(sp, 2)","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"JuMPs [] syntax is available as well, with the addition that the stage must be provided as well:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"x = sp[1,:x]\nprintln(x)\nprintln(typeof(x))","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"The return type is DecisionVariable a specialized AbstractVariableRef. For first-stage variables, the syntax is unchanged from JuMP:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"println(name(x))\nprintln(\"x has lower bound: $(has_lower_bound(x))\")\nprintln(\"x has upper bound: $(has_upper_bound(x))\")\nprintln(\"lower_bound(x) = $(lower_bound(x))\")","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"If we instead query for the recourse decision y:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"y = sp[2,:y]\nprintln(y)\nprintln(typeof(y))","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"The same getters will error:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"lower_bound(y)","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"ERROR: y is scenario dependent, consider `lower_bound(dvar, scenario_index)`.","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"As indicated by the error, y is scenario-dependent so a scenario_index must be provided as well:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"println(name(y, 1))\nprintln(\"y has lower bound in scenario 1: $(has_lower_bound(y, 1))\")\nprintln(\"y has upper bound in scenario 1: $(has_upper_bound(y, 1))\")\nprintln(\"lower_bound(y, 1) = $(lower_bound(y, 1))\")\n\nprintln(name(y, 2))\nprintln(\"y has lower bound in scenario 2: $(has_lower_bound(y, 2))\")\nprintln(\"y has upper bound in scenario 2: $(has_upper_bound(y, 2))\")\nprintln(\"lower_bound(y, 2) = $(lower_bound(y, 2))\")","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"The lower bound of y is as expected different in the two scenarios. Some attributes, such as the variable name, are structure dependent and may vary in a StageDecomposition or ScenarioDecomposition structure. Auxiliary variables created with the standard @variable are not available through this API. To access them, either annotate them with @decision (or @recourse in the final stage), or access the relevant JuMP subproblem and query the variable as usual. For example:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"w = DEP(sp)[:w]\nprintln(w)\nprintln(typeof(w))","category":"page"},{"location":"manual/decisions/#Decision-constraints","page":"Decision API","title":"Decision constraints","text":"","category":"section"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"Constraints that include variables annotated with either @decision or @recourse can also be accessed in the extended API. Stage-wise list of all such constraints can be obtained:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"println(list_of_constraint_types(sp, 1))","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"println(list_of_constraint_types(sp, 2))","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"and type-sorted constraints can be obtained through a stage-dependent variant of all_constraints:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"all_constraints(sp, 2, DecisionAffExpr{Float64}, MOI.LessThan{Float64});","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"The scenario-dependent constraint in stage 2 can also be accessed through","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"con = sp[2,:con];\nprintln(con)","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"This returns an SPConstraintRef, similar in function to DecisionVariable. The constraint originates from stage-two, so most attributes are scenario-dependent:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"println(name(con, 1))\nprintln(\"RHS of con in scenario 1 = $(normalized_rhs(con, 1))\")\nprintln(\"Coefficient of x in scenario 1 = $(normalized_coefficient(con, x, 1))\")\nprintln(\"Coefficient of y in scenario 1 = $(normalized_coefficient(con, y, 1))\")\n\nprintln(name(con, 2))\nprintln(\"RHS of con in scenario 2 = $(normalized_rhs(con, 2))\")\nprintln(\"Coefficient of x in scenario 2 = $(normalized_coefficient(con, x, 2))\")\nprintln(\"Coefficient of y in scenario 2 = $(normalized_coefficient(con, y, 2))\")","category":"page"},{"location":"manual/decisions/#Decision-objectives","page":"Decision API","title":"Decision objectives","text":"","category":"section"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"The objective function of a stochastic program can be obtained in full or in stage and scenario-dependent chunks:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"println(\"Objective in stage 1: $(objective_function(sp, 1))\")\nprintln(\"Objective in stage 2, scenario 1: $(objective_function(sp, 2, 1))\")\nprintln(\"Objective in stage 2, scenario 2: $(objective_function(sp, 2, 2))\")\nprintln(\"Full objective: $(objective_function(sp))\")","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"and can be modified accordingly:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"set_objective_coefficient(sp, y, 2, 1, 2.);\nprintln(\"Objective in stage 2, scenario 1: $(objective_function(sp, 2, 1))\")\nprintln(\"Full objective: $(objective_function(sp))\")\nset_objective_coefficient(sp, y, 2, 1, 1.);","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"The stochastic program objective is structure dependent and will appear different if the stochastic program is instead instantiated with StageDecomposition or ScenarioDecomposition.","category":"page"},{"location":"manual/decisions/#Solved-problem","page":"Decision API","title":"Solved problem","text":"","category":"section"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"After optimizing the stochastic program, attributes for which is_set_by_optimize is true can be accessed using the same scenario-dependent syntax:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"set_optimizer(sp, GLPK.Optimizer)\n\noptimize!(sp)\n\n# Main result\nprintln(\"Termination status: $(termination_status(sp))\")\nprintln(\"Objective value: $(objective_value(sp))\")\nprintln(\"Optimal decision: $(optimal_decision(sp))\")\n\n# First stage\nprintln(\"value(x) = $(value(x))\")\nprintln(\"reduced_cost(x) = $(reduced_cost(x))\")\n\n# Scenario 1\n# Second stage\nprintln(\"value(y, 1) = $(value(y, 1))\")\nprintln(\"reduced_cost(y, 1) = $(reduced_cost(y, 1))\")\nprintln(\"dual(con, 1) = $(dual(con, 1))\")\nprintln(\"Objective value in scenario 1: $(objective_value(sp, 1))\")\nprintln(\"Optimal recourse in scenario 1: $(optimal_recourse_decision(sp, 1))\")\n\n# Scenario 2\nprintln(\"value(y, 2) = $(value(y, 2))\")\nprintln(\"reduced_cost(y, 2) = $(reduced_cost(y, 2))\")\nprintln(\"dual(con, 2) = $(dual(con, 2))\")\nprintln(\"Objective value in scenario 2: $(objective_value(sp, 2))\")\nprintln(\"Optimal recourse in scenario 2: $(optimal_recourse_decision(sp, 2))\")","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"As mentioned in the Quick start, decision evaluation can be performed manually through the decision API. Consider:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"fix(x, 3.);","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"This not only fixes x in the first-stage, but also in all occurances in subsequent stages:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"print(sp)","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"This is more apparent in a stage-decomposition structure:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"vertical_sp = StochasticProgram([ξ₁,ξ₂], StageDecomposition())\n@first_stage vertical_sp = begin\n    @decision(vertical_sp, x >= 2)\n    @variable(vertical_sp, w)\n    @objective(vertical_sp, Min, x)\nend\n@second_stage vertical_sp = begin\n    @known(vertical_sp, x)\n    @uncertain a\n    @recourse(vertical_sp, y >= 1/a)\n    @objective(vertical_sp, Max, y)\n    @constraint(vertical_sp, con, a*y <= x)\nend\n\nx = vertical_sp[1,:x]\nfix(x, 3.)\n\nprint(vertical_sp)","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"We resolve the problem to verify:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"optimize!(sp)\n\n# Main result\nprintln(\"Termination status: $(termination_status(sp))\")\nprintln(\"Objective value: $(objective_value(sp))\")\nprintln(\"Optimal decision: $(optimal_decision(sp))\")\n\n# First stage\nprintln(\"value(x) = $(value(x))\")\n\n# Scenario 1\n# Second stage\nprintln(\"value(y, 1) = $(value(y, 1))\")\nprintln(\"reduced_cost(y, 1) = $(reduced_cost(y, 1))\")\nprintln(\"dual(con, 1) = $(dual(con, 1))\")\nprintln(\"Objective value in scenario 1: $(objective_value(sp, 1))\")\nprintln(\"Optimal recourse in scenario 1: $(optimal_recourse_decision(sp, 1))\")\n\n# Scenario 2\nprintln(\"value(y, 2) = $(value(y, 2))\")\nprintln(\"reduced_cost(y, 2) = $(reduced_cost(y, 2))\")\nprintln(\"dual(con, 2) = $(dual(con, 2))\")\nprintln(\"Objective value in scenario 2: $(objective_value(sp, 2))\")\nprintln(\"Optimal recourse in scenario 2: $(optimal_recourse_decision(sp, 2))\")\n\n# Evaluating x = 3 should give the same answer:\nprintln(\"Equivalent decision evaluation: $(evaluate_decision(sp, [3.]))\")","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"We can also fix the value of y in a specific scenario:","category":"page"},{"location":"manual/decisions/","page":"Decision API","title":"Decision API","text":"fix(y, 1, 2.)\noptimize!(sp)\n\n# Main result\nprintln(\"Termination status: $(termination_status(sp))\")\nprintln(\"Objective value: $(objective_value(sp))\")\nprintln(\"Optimal decision: $(optimal_decision(sp))\")\n\n# First stage\nprintln(\"value(x) = $(value(x))\")\n\n# Scenario 1\n# Second stage\nprintln(\"value(y, 1) = $(value(y, 1))\")\nprintln(\"Objective value in scenario 1: $(objective_value(sp, 1))\")\nprintln(\"Optimal recourse in scenario 1: $(optimal_recourse_decision(sp, 1))\")\n\n# Scenario 2\nprintln(\"value(y, 2) = $(value(y, 2))\")\nprintln(\"Objective value in scenario 2: $(objective_value(sp, 2))\")\nprintln(\"Optimal recourse in scenario 2: $(optimal_recourse_decision(sp, 2))\")\n\n# Evaluating x = 3 should give the same answer:\nprintln(evaluate_decision(sp, [3.]))\n\n# Evaluating x = 3 should give the same answer:\nprintln(\"Equivalent decision evaluation: $(evaluate_decision(sp, [3.]))\")","category":"page"},{"location":"library/solverinterface/#Solver-interface","page":"Solver interface","title":"Solver interface","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Documentation for StochasticPrograms.jl's interface for structured solvers and sample-based solvers.","category":"page"},{"location":"library/solverinterface/#Index","page":"Solver interface","title":"Index","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Pages = [\"solverinterface.md\"]","category":"page"},{"location":"library/solverinterface/#Interface","page":"Solver interface","title":"Interface","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"AbstractStructuredOptimizer\nAbstractSampledOptimizer","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.AbstractStructuredOptimizer","page":"Solver interface","title":"StochasticPrograms.AbstractStructuredOptimizer","text":"AbstractStructuredOptimizer\n\nAbstract supertype for structure-exploiting optimizers.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.AbstractSampledOptimizer","page":"Solver interface","title":"StochasticPrograms.AbstractSampledOptimizer","text":"AbstractSampledOptimizer\n\nAbstract supertype for sample-based optimizers.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Modules = [StochasticPrograms]\nPages   = [\"optimizer_interface.jl\"]","category":"page"},{"location":"library/solverinterface/#JuMP.optimize!","page":"Solver interface","title":"JuMP.optimize!","text":"optimize!(optimizer::AbstractStructuredOptimizer)\n\nStart the solution procedure for optimizer after a call to load_structure!.\n\nSee also: load_structure!\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.check_loadable","page":"Solver interface","title":"StochasticPrograms.check_loadable","text":"check_loadable(optimizer::AbstractStructuredOptimizer, structure::AbstractStochasticStructure)\n\nThrows an UnloadableStructure exception if structure is not loadable by optimizer.\n\nSee also: [`load_structure!`](@ref)\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.load_model!","page":"Solver interface","title":"StochasticPrograms.load_model!","text":"load_model!(optimizer::AbstractSampledOptimizer, model::StochasticModel, x₀::AbstractVector)\n\nInstantiate the optimizer with the stochastic model and initial decision x₀.\n\nSee also: optimize!\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.load_structure!","page":"Solver interface","title":"StochasticPrograms.load_structure!","text":"load_structure!(optimizer::AbstractStructuredOptimizer, structure::AbstractStochasticStructure, x₀::AbstractVector)\n\nInstantiate the optimizer with the stochastic program represented in memory by the given structure and initial decision x₀.\n\nSee also: optimize!\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.master_optimizer","page":"Solver interface","title":"StochasticPrograms.master_optimizer","text":"master_optimizer(optimizer::AbstractStructuredOptimizer)\n\nReturn a MOI optimizer constructor\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.num_iterations","page":"Solver interface","title":"StochasticPrograms.num_iterations","text":"num_iterations(optimizer::AbstractStructuredOptimizer)\n\nReturn the number of iterations ran by the structured optimizer\n\nSee also: optimize!\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.optimal_instance","page":"Solver interface","title":"StochasticPrograms.optimal_instance","text":"optimal_instance(optimizer::AbstractSampledOptimizer)\n\nReturn a stochastic programming instance of the stochastic model after a call to optimize!.\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.optimizer_name-Tuple{AbstractSampledOptimizer}","page":"Solver interface","title":"StochasticPrograms.optimizer_name","text":"optimizer_name(optimizer::AbstractSampledOptimizer)\n\nOptionally, return a string identifier of AbstractSampledOptimizer.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.optimizer_name-Tuple{AbstractStructuredOptimizer}","page":"Solver interface","title":"StochasticPrograms.optimizer_name","text":"optimizer_name(optimizer::AbstractStructuredOptimizer)\n\nOptionally, return a string identifier of AbstractStructuredOptimizer.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.restore_structure!","page":"Solver interface","title":"StochasticPrograms.restore_structure!","text":"restore_structure!(optimizer::AbstractStructuredOptimizer)\n\nRestore the stochastic program to the state it was in before a call to optimize!\n\nSee also: load_structure!\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.subproblem_optimizer","page":"Solver interface","title":"StochasticPrograms.subproblem_optimizer","text":"subproblem_optimizer(optimizer::AbstractStructuredOptimizer)\n\nReturn a MOI optimizer constructor for solving subproblems\n\n\n\n\n\n","category":"function"},{"location":"library/solverinterface/#StochasticPrograms.supports_structure-Tuple{MathOptInterface.AbstractOptimizer, AbstractStochasticStructure}","page":"Solver interface","title":"StochasticPrograms.supports_structure","text":"supports_structure(optimizer::StochasticProgramOptimizerType, structure::AbstractStochasticStructure)\n\nReturn a Bool indicating whether optimizer supports the stochastic structure. That is, load_structure!(optimizer, structure) will not throw UnsupportedStructure\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#Attributes","page":"Solver interface","title":"Attributes","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"AbstractStructuredOptimizerAttribute\nAbstractSampledOptimizerAttribute","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.AbstractStructuredOptimizerAttribute","page":"Solver interface","title":"StochasticPrograms.AbstractStructuredOptimizerAttribute","text":"AbstractStructuredOptimizerAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the structure-exploiting optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.AbstractSampledOptimizerAttribute","page":"Solver interface","title":"StochasticPrograms.AbstractSampledOptimizerAttribute","text":"AbstractSampledOptimizerAttribute\n\nAbstract supertype for attribute objects that can be used to set or get attributes (properties) of the sample-based optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Modules = [StochasticPrograms]\nPages   = [\"attributes.jl\"]","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.Confidence","page":"Solver interface","title":"StochasticPrograms.Confidence","text":"Confidence\n\nAn optimizer attribute for specifying the confidence level of sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.Execution","page":"Solver interface","title":"StochasticPrograms.Execution","text":"Execution\n\nAn optimizer attribute for specifying an execution policy for a structure-exploiting algorithm. Options are:\n\nSerial:  Classical L-shaped (default)\nSynchronous: Classical L-shaped run in parallel\nAsynchronous: Asynchronous L-shaped ?Asynchronous for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.ExecutionParameter","page":"Solver interface","title":"StochasticPrograms.ExecutionParameter","text":"ExecutionParameter\n\nAbstract supertype for execution-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.InstanceCrash","page":"Solver interface","title":"StochasticPrograms.InstanceCrash","text":"InstanceCrash\n\nAn optimizer attribute for specifying a crash start to be used when solving sampled instances.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.InstanceOptimizer","page":"Solver interface","title":"StochasticPrograms.InstanceOptimizer","text":"InstanceOptimizer\n\nAn optimizer attribute for specifying the AbstractStructuredOptimizer/AbstractOptimizer used to solve sampled problems in sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.InstanceOptimizerAttribute","page":"Solver interface","title":"StochasticPrograms.InstanceOptimizerAttribute","text":"InstanceOptimizerAttribute\n\nAn optimizer attribute used for setting attributes of the instance optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.MasterOptimizer","page":"Solver interface","title":"StochasticPrograms.MasterOptimizer","text":"MasterOptimizer\n\nAn optimizer attribute for specifying the MathOptInterface optimizer used to solve master problems arising in a structure-exploiting procedure.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.MasterOptimizerAttribute","page":"Solver interface","title":"StochasticPrograms.MasterOptimizerAttribute","text":"MasterOptimizerAttribute\n\nAn optimizer attribute used for setting attributes of the master optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.NumEEVSamples","page":"Solver interface","title":"StochasticPrograms.NumEEVSamples","text":"NumEEVSamples\n\nAn optimizer attribute for specifying the sample size of expected-value evaluation instances in sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.NumEWSSamples","page":"Solver interface","title":"StochasticPrograms.NumEWSSamples","text":"NumEWSSamples\n\nAn optimizer attribute for specifying the sample size of wait-and-see instances in sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.NumEvalSamples","page":"Solver interface","title":"StochasticPrograms.NumEvalSamples","text":"NumEvalSamples\n\nAn optimizer attribute for specifying the sample size of evaluation instances of sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.NumLowerTrials","page":"Solver interface","title":"StochasticPrograms.NumLowerTrials","text":"NumLowerTrials\n\nAn optimizer attribute for specifying the number of trials used to compute lower bounds of confidence intervals in sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.NumSamples","page":"Solver interface","title":"StochasticPrograms.NumSamples","text":"NumSamples\n\nAn optimizer attribute for specifying the sample size of sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.NumUpperTrials","page":"Solver interface","title":"StochasticPrograms.NumUpperTrials","text":"NumUpperTrials\n\nAn optimizer attribute for specifying the number of trials used to compute upper bounds of confidence intervals in sample-based procedures.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.RawInstanceOptimizerParameter","page":"Solver interface","title":"StochasticPrograms.RawInstanceOptimizerParameter","text":"RawInstanceOptimizerParameter\n\nAn optimizer attribute used for raw parameters of the instance optimizer. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.RawMasterOptimizerParameter","page":"Solver interface","title":"StochasticPrograms.RawMasterOptimizerParameter","text":"RawMasterOptimizerParameter\n\nAn optimizer attribute used for raw parameters of the master optimizer. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.RawSubProblemOptimizerParameter","page":"Solver interface","title":"StochasticPrograms.RawSubProblemOptimizerParameter","text":"RawSubProblemOptimizerParameter\n\nAn optimizer attribute used for raw parameters of the subproblem optimizer. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.RelativeTolerance","page":"Solver interface","title":"StochasticPrograms.RelativeTolerance","text":"RelativeTolerance\n\nAn optimizer attribute for specifying the relative tolerance of a structure-exploiting algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.SubProblemOptimizer","page":"Solver interface","title":"StochasticPrograms.SubProblemOptimizer","text":"SubProblemOptimizer\n\nAn optimizer attribute for specifying the MathOptInterface optimizer used to solve subproblems arising in a structure-exploiting procedure.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.get_instanceoptimizer_attribute-Tuple{StochasticModel, MathOptInterface.AbstractOptimizerAttribute}","page":"Solver interface","title":"StochasticPrograms.get_instanceoptimizer_attribute","text":"get_instanceoptimizer_attribute(stochasticmodel::StochasticModel, attr::MOI.AbstractOptimizerAttribute)\n\nReturn the value of the solver-specific attribute attr of the instance optimizer in stochasticmodel.\n\nSee also: set_instanceoptimizer_attribute, set_instanceoptimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.get_instanceoptimizer_attribute-Tuple{StochasticProgram, String}","page":"Solver interface","title":"StochasticPrograms.get_instanceoptimizer_attribute","text":"get_instanceoptimizer_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the solver-specific attribute named name of the instance optimizer in stochasticprogram.\n\nSee also: set_instanceoptimizer_attribute, set_instanceoptimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.get_masteroptimizer_attribute-Tuple{StochasticProgram, MathOptInterface.AbstractOptimizerAttribute}","page":"Solver interface","title":"StochasticPrograms.get_masteroptimizer_attribute","text":"get_masteroptimizer_attribute(stochasticprogram::StochasticProgram, attr::MOI.AbstractOptimizerAttribute)\n\nReturn the value of the solver-specific attribute attr of the master optimizer in stochasticprogram.\n\nSee also: set_masteroptimizer_attribute, set_masteroptimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.get_masteroptimizer_attribute-Tuple{StochasticProgram, String}","page":"Solver interface","title":"StochasticPrograms.get_masteroptimizer_attribute","text":"get_masteroptimizer_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the solver-specific attribute named name of the master optimizer in stochasticprogram.\n\nSee also: set_masteroptimizer_attribute, set_masteroptimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.get_suboptimizer_attribute-Tuple{StochasticProgram, MathOptInterface.AbstractOptimizerAttribute}","page":"Solver interface","title":"StochasticPrograms.get_suboptimizer_attribute","text":"get_suboptimizer_attribute(stochasticprogram::StochasticProgram, attr::MOI.AbstractOptimizerAttribute)\n\nReturn the value of the solver-specific attribute attr of the subproblem optimizer in stochasticprogram.\n\nSee also: set_suboptimizer_attribute, set_suboptimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.get_suboptimizer_attribute-Tuple{StochasticProgram, String}","page":"Solver interface","title":"StochasticPrograms.get_suboptimizer_attribute","text":"get_suboptimizer_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the solver-specific attribute named name of the subproblem optimizer in stochasticprogram.\n\nSee also: set_suboptimizer_attribute, set_suboptimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_instanceoptimizer_attribute-Tuple{StochasticModel, MathOptInterface.AbstractOptimizerAttribute, Any}","page":"Solver interface","title":"StochasticPrograms.set_instanceoptimizer_attribute","text":"set_instanceoptimizer_attribute(stochasticmodel::StochasticModel, attr::MOI.AbstractOptimizerAttribute, value)\n\nSets solver-specific attribute attr of the instance optimizer to value in stochasticmodel.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_instanceoptimizer_attribute-Tuple{StochasticModel, Union{String, Symbol}, Any}","page":"Solver interface","title":"StochasticPrograms.set_instanceoptimizer_attribute","text":"set_instanceoptimizer_attribute(stochasticmodel::StochasticModel, name::Union{Symbol, String}, value)\n\nSets solver-specific attribute of the instance optimizer identified by name to value in stochasticmodel.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_instanceoptimizer_attributes-Tuple{StochasticModel, Vararg{Pair, N} where N}","page":"Solver interface","title":"StochasticPrograms.set_instanceoptimizer_attributes","text":"set_instanceoptimizer_attributes(stochasticmodel::StochasticModel, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_instanceoptimizer_attribute(stochasticmodel, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_masteroptimizer_attribute-Tuple{StochasticProgram, MathOptInterface.AbstractOptimizerAttribute, Any}","page":"Solver interface","title":"StochasticPrograms.set_masteroptimizer_attribute","text":"set_masteroptimizer_attribute(stochasticprogram::StochasticProgram, attr::MOI.AbstractOptimizerAttribute, value)\n\nSets solver-specific attribute attr of the master optimizer to value.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_masteroptimizer_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"Solver interface","title":"StochasticPrograms.set_masteroptimizer_attribute","text":"set_masteroptimizer_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets solver-specific attribute of the master optimizer identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_masteroptimizer_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"Solver interface","title":"StochasticPrograms.set_masteroptimizer_attributes","text":"set_masteroptimizer_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_masteroptimizer_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_suboptimizer_attribute-Tuple{StochasticProgram, MathOptInterface.AbstractOptimizerAttribute, Any}","page":"Solver interface","title":"StochasticPrograms.set_suboptimizer_attribute","text":"set_suboptimizer_attribute(stochasticprogram::StochasticProgram, attr::MOI.AbstractOptimizerAttribute, value)\n\nSets solver-specific attribute attr of the subproblem optimizer to value.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_suboptimizer_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"Solver interface","title":"StochasticPrograms.set_suboptimizer_attribute","text":"set_suboptimizer_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets solver-specific attribute of the subproblem optimizer identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#StochasticPrograms.set_suboptimizer_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"Solver interface","title":"StochasticPrograms.set_suboptimizer_attributes","text":"set_suboptimizer_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_suboptimizer_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/solverinterface/#Execution","page":"Solver interface","title":"Execution","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Serial\nSynchronous\nAsynchronous","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.Serial","page":"Solver interface","title":"StochasticPrograms.Serial","text":"Serial\n\nFactory object for LShaped.SerialExecution/ProgressiveHedging.SerialExecution. Pass through the Execution attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.Synchronous","page":"Solver interface","title":"StochasticPrograms.Synchronous","text":"Synchronous\n\nFactory object for LShaped.SynchronousExecution/ProgressiveHedging.SynchronousExecution. Pass through the Execution attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.Asynchronous","page":"Solver interface","title":"StochasticPrograms.Asynchronous","text":"Asynchronous\n\nFactory object for LShaped.AsynchronousExecution/ProgressiveHedging.AsynchronousExecution. Pass through the Execution attribute.\n\n...\n\nParameters\n\nmax_active::Int = 3: Maximum number of active iterations that run asynchronously.\nκ::T = 0.5: Relative amount of finished subproblems required to start a new iterate. Governs the amount of asynchronicity.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#Penalty-terms","page":"Solver interface","title":"Penalty terms","text":"","category":"section"},{"location":"library/solverinterface/","page":"Solver interface","title":"Solver interface","text":"Quadratic\nLinearized\nInfNorm\nManhattanNorm","category":"page"},{"location":"library/solverinterface/#StochasticPrograms.Quadratic","page":"Solver interface","title":"StochasticPrograms.Quadratic","text":"Quadratic\n\nFunctor object for using a quadratic 2-norm penalty term. Requires an AbstractMathProgSolver capable of solving QP problems. Passed by default through penalty where applicable.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.Linearized","page":"Solver interface","title":"StochasticPrograms.Linearized","text":"Linearized\n\nFunctor object for using an approximately quadratic penalty term, through linearization. Pass through penalty where applicable.\n\n...\n\nParameters\n\nnbreakpoints::Int: Number of cutting planes used to approximate quadratic term\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.InfNorm","page":"Solver interface","title":"StochasticPrograms.InfNorm","text":"InfNorm\n\nFunctor object for using a linear ∞-norm penalty term. Pass through penalty where applicable.\n\n\n\n\n\n","category":"type"},{"location":"library/solverinterface/#StochasticPrograms.ManhattanNorm","page":"Solver interface","title":"StochasticPrograms.ManhattanNorm","text":"ManhattanNorm\n\nFunctor object for using a linear 1-norm penalty term. Pass through penalty where applicable.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#L-shaped-solvers","page":"L-shaped solvers","title":"L-shaped solvers","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Documentation for StochasticPrograms.jl's L-shaped solvers.","category":"page"},{"location":"library/lshaped/#Index","page":"L-shaped solvers","title":"Index","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Pages = [\"lshaped.md\"]","category":"page"},{"location":"library/lshaped/#API","page":"L-shaped solvers","title":"API","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShapedAlgorithm","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.LShapedAlgorithm","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.LShapedAlgorithm","text":"LShapedAlgorithm\n\nFunctor object for the L-shaped algorithm.\n\n...\n\nAlgorithm parameters\n\nτ::AbstractFloat = 1e-6: Relative tolerance for convergence checks.\ndebug::Bool = false: Specifies if extra information should be saved for debugging purposes. Defaults to false for memory efficiency.\ncut_scaling::AbstractFloat = 1.0: Rescaling factor for cutting planes to improve numerical stability.\nlog::Bool = true: Specifices if L-shaped procedure should be logged on standard output or not.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShaped]\nPages   = [\"attributes.jl\", \"MOI_wrapper.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.AbstractLShapedAttribute","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.AbstractLShapedAttribute","text":"AbstractLShapedAttribute\n\nAbstract supertype for attribute objects specific to the L-shaped algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.AggregationParameter","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.AggregationParameter","text":"AggregationParameter\n\nAbstract supertype for aggregation-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Aggregator","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Aggregator","text":"Aggregator\n\nAn optimizer attribute for specifying an aggregation procedure to be used in the L-shaped algorithm. Options are:\n\nNoAggregation:  Multi-cut L-shaped algorithm (default)\nPartialAggregation:  ?PartialAggregation for parameter descriptions.\nFullAggregation:  ?FullAggregation for parameter descriptions.\nDynamicAggregation:  ?DynamicAggregation for parameter descriptions.\nClusterAggregation:  ?ClusterAggregation for parameter descriptions.\nHybridAggregation:  ?HybridAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.ConsolidationParameter","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.ConsolidationParameter","text":"ConsolidationParameter\n\nAbstract supertype for consolidation-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Consolidator","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Consolidator","text":"Consolidator\n\nAn optimizer attribute for specifying a consolidation procedure to be used in the L-shaped algorithm. Options are:\n\nNoConsolidation (default)\nConsolidation\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.FeasibilityStrategy","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.FeasibilityStrategy","text":"FeasibilityStrategy\n\nAn optimizer attribute for specifying a strategy for dealing with second-stage feasibility the L-shaped algorithm. Options are:\n\nIgnoreFeasibility (default)\nFeasibilityCuts\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.IntegerParameter","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.IntegerParameter","text":"IntegerParameter\n\nAbstract supertype for integer-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.IntegerStrategy","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.IntegerStrategy","text":"IntegerStrategy\n\nAn optimizer attribute for specifying a strategy for dealing with integers the L-shaped algorithm. Options are:\n\nIgnoreIntegers (default)\nCombinatorialCuts\nConvexification\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.RegularizationParameter","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.RegularizationParameter","text":"RegularizationParameter\n\nAbstract supertype for regularization-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Regularizer","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Regularizer","text":"Regularizer\n\nAn optimizer attribute for specifying a regularization procedure to be used in the L-shaped algorithm. Options are:\n\nNoRegularization:  L-shaped algorithm (default)\nRegularizedDecomposition:  Regularized decomposition ?RegularizedDecomposition for parameter descriptions.\nTrustRegion:  Trust-region ?TrustRegion for parameter descriptions.\nLevelSet:  Level-set ?LevelSet for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Optimizer","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Optimizer","text":"Optimizer(; <keyword arguments>)\n\nReturn an L-shaped optimizer. ...\n\nArguments\n\nmaster_optimizer::AbstractOptimizer: MathOptInterface solver capable of solving linear (and possibly quadratic) programs.\nsubproblem_optimizer::AbstractOptimizer: Optionally specify a different solver for the subproblems.\nfeasibility_cuts::Bool = false: Specify if feasibility cuts should be used\nregularize::AbstractRegularizer = DontRegularize(): Specify regularization procedure (DontRegularize, RegularizedDecomposition/RD/WithRegularizedDecomposition, TrustRegion/TR/WithTrustRegion, LevelSet/LV/WithLevelSets).\naggregate::AbstractAggregator = DontAggregate(): Specify aggregation procedure (DontAggregate, Aggregate, PartialAggregate, DynamicAggregate, ClusterAggregate, GranulatedAggregate, HybridAggregate)\nconsolidate::AbstractConsolidator = DontConsolidate(): Specify consolidation procedure (DontConsolidate, Consolidate)\nexecution::Execution = Serial: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.\n<keyword arguments>: Algorithm specific parameters, See ?LShaped for list of possible arguments and default values.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.get_aggregation_attribute-Tuple{StochasticProgram, String}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.get_aggregation_attribute","text":"get_aggregation_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the aggregation-specific attribute named name in stochasticprogram.\n\nSee also: set_aggregation_attribute, set_aggregation_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.get_consolidation_attribute-Tuple{StochasticProgram, String}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.get_consolidation_attribute","text":"get_consolidation_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the consolidation-specific attribute named name in stochasticprogram.\n\nSee also: set_consolidation_attribute, set_consolidation_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.get_regularization_attribute-Tuple{StochasticProgram, String}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.get_regularization_attribute","text":"get_regularization_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the regularization-specific attribute named name in stochasticprogram.\n\nSee also: set_regularization_attribute, set_regularization_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_aggregation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_aggregation_attribute","text":"set_aggregation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the aggregation-specific attribute identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_aggregation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_aggregation_attributes","text":"set_aggregation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_aggregation_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_consolidation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_consolidation_attribute","text":"set_consolidation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the consolidation-specific attribute identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_consolidation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_consolidation_attributes","text":"set_consolidation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_consolidation_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_regularization_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_regularization_attribute","text":"set_regularization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the regularization-specific attribute identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_regularization_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_regularization_attributes","text":"set_regularization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_regularization_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#Execution","page":"L-shaped solvers","title":"Execution","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShaped.SerialExecution\nLShaped.SynchronousExecution\nLShaped.AsynchronousExecution","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.SerialExecution","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.SerialExecution","text":"SerialExecution\n\nFunctor object for using serial execution in a lshaped algorithm. Create by supplying a Serial object through execution in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.SynchronousExecution","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.SynchronousExecution","text":"SynchronousExecution\n\nFunctor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a Synchronous object through execution in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.AsynchronousExecution","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.AsynchronousExecution","text":"AsynchronousExecution\n\nFunctor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a Asynchronous object through execution in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Feasibility","page":"L-shaped solvers","title":"Feasibility","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShaped.NoFeasibilityAlgorithm\nLShaped.IgnoreFeasibility\nLShaped.FeasibilityCutsMaster\nLShaped.FeasibilityCutsWorker\nLShaped.FeasibilityCuts","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.NoFeasibilityAlgorithm","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.NoFeasibilityAlgorithm","text":"NoFeasibilityAlgorithm\n\nEmpty functor object for running an L-shaped algorithm without dealing with second-stage feasibility.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.IgnoreFeasibility","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.IgnoreFeasibility","text":"IgnoreFeasibility\n\nFactory object for NoFeasibilityAlgorithm. Passed by default to feasibility_strategy in LShaped.Optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.FeasibilityCutsMaster","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.FeasibilityCutsMaster","text":"FeasibilityCutsMaster\n\nMaster functor object for using feasibility cuts in an L-shaped algorithm. Create by supplying a FeasibilityCuts object through feasibility_strategy in LShaped.Optimizer or set the FeasibilityStrategy attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.FeasibilityCutsWorker","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.FeasibilityCutsWorker","text":"FeasibilityCutsWorker\n\nWorker functor object for using feasibility cuts in an L-shaped algorithm. Create by supplying a FeasibilityCuts object through feasibility_strategy in LShaped.Optimizer or set the FeasibilityStrategy attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.FeasibilityCuts","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.FeasibilityCuts","text":"IgnoreFeasibility\n\nFactory object for using feasibility cuts in an L-shaped algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Integers","page":"L-shaped solvers","title":"Integers","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShaped]\nPages   = [\"integer.jl\", \"ignore_integers.jl\", \"combinatorial_cuts.jl\", \"convexification.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.RawIntegerParameter","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.RawIntegerParameter","text":"RawIntegerAlgorithmParameter\n\nAn optimizer attribute used for raw parameters of the integer algorithm. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.IgnoreIntegers","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.IgnoreIntegers","text":"IgnoreIntegers\n\nFactory object for NoIntegerAlgorithm. Passed by default to integer_strategy in LShaped.Optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.NoIntegerAlgorithm","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.NoIntegerAlgorithm","text":"NoIntegerAlgorithm\n\nEmpty functor object for running an L-shaped algorithm without dealing with integer variables.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.CombinatorialCuts","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.CombinatorialCuts","text":"CombinatorialCuts\n\nFactory object for CombinatorialCuts. Pass to integer_strategy in LShaped.Optimizer or set the IntegerStrategy attribute.\n\n...\n\nParameters\n\nlower_bound::AbstractFloat = -1e10: Set a lower bound on the second-stage objective, removing the need to approximate it.\nalternate::Bool = false: Specify if algorithm should alternate between solving relaxed problems (generating regular optimality cuts) and unrelaxed problems (generating combinatorial cuts)\nupdate_L_every::Integer = 0: Set the frequency at which the lower bound approximation should be updated. Only approximate once if set to zero.\noptimizer = nothing: Optionally specify an optimizer used to solve auxilliary problems in the LiftAndProject or CuttingPlaneTree strategies.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.CombinatorialCutsMaster","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.CombinatorialCutsMaster","text":"CombinatorialCutsMaster\n\nMaster functor object for using weak optimality cuts in an integer L-shaped algorithm. Requires all first-stage decisions to be binary. Create by supplying a CombinatorialCuts object through integer_strategy in LShaped.Optimizer or set the IntegerStrategy attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.CombinatorialCutsWorker","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.CombinatorialCutsWorker","text":"CombinatorialCutsWorker\n\nWorker functor object for using weak optimality cuts in an integer L-shaped algorithm. Create by supplying a CombinatorialCuts object through integer_strategy in LShaped.Optimizer or set the IntegerStrategy attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Convexification","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Convexification","text":"Convexification\n\nFactory object for using convexification to handle integer recourse. Pass to integer_strategy in LShaped.Optimizer or set the IntegerStrategy attribute.\n\n...\n\nParameters\n\nmaximum_iterations::Integer = 1: Determines the number of iterations spent generating cutting-planes each time a subproblem is solved.\nstrategy::ConvexificationStrategy = Gomory(): Specify convexification strategy (Gomory, LiftAndProject, CuttingPlaneTree)\noptimizer = nothing: Optionally specify an optimizer used to solve auxilliary problems in the LiftAndProject or CuttingPlaneTree strategies.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.ConvexificationMaster","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.ConvexificationMaster","text":"ConvexificationMaster\n\nMaster functor object for using weak optimality cuts in an integer L-shaped algorithm. Requires all first-stage decisions to be binary. Create by supplying a Convexification object through integer_strategy in LShaped.Optimizer or set the IntegerStrategy attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.ConvexificationWorker","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.ConvexificationWorker","text":"ConvexificationWorker\n\nWorker functor object for using weak optimality cuts in an integer L-shaped algorithm. Create by supplying a Convexification object through integer_strategy in LShaped.Optimizer or set the IntegerStrategy attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Regularization","page":"L-shaped solvers","title":"Regularization","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShaped.set_regularization_attribute\nLShaped.set_regularization_attributes\nLShaped.RawRegularizationParameter\nLShaped.NoRegularization\nLShaped.DontRegularize\nLShaped.RegularizedDecomposition\nLShaped.RD\nLShaped.TrustRegion\nLShaped.TR\nLShaped.LevelSet\nLShaped.LV","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_regularization_attribute","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_regularization_attribute","text":"set_regularization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the regularization-specific attribute identified by name to value.\n\n\n\n\n\n","category":"function"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_regularization_attributes","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_regularization_attributes","text":"set_regularization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_regularization_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"function"},{"location":"library/lshaped/#StochasticPrograms.LShaped.RawRegularizationParameter","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.RawRegularizationParameter","text":"RawRegularizationParameter\n\nAn optimizer attribute used for raw parameters of the regularizer. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.NoRegularization","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.NoRegularization","text":"NoRegularization\n\nEmpty functor object for running an L-shaped algorithm without regularization.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.DontRegularize","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.DontRegularize","text":"DontRegularize\n\nFactory object for NoRegularization. Passed by default to regularize in LShaped.Optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.RegularizedDecomposition","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.RegularizedDecomposition","text":"RegularizedDecomposition\n\nFunctor object for using regularized decomposition regularization in an L-shaped algorithm. Create by supplying an RD object through regularize in LShaped.Optimizer or by setting the Regularizer attribute.\n\n...\n\nParameters\n\nσ::AbstractFloat = 1.0: Initial value of regularization parameter. Controls the relative penalty of the deviation from the current major iterate.\nσ̅::AbstractFloat = 4.0: Maximum value of the regularization parameter.\nσ̲::AbstractFloat = 0.5: Minimum value of the regularization parameter.\nlog::Bool = true: Specifices if L-shaped procedure should be logged on standard output or not.\npenaltyterm::PenaltyTerm = Quadratic: Specify penaltyterm variant (Quadratic, InfNorm, [ManhattanNorm][@ref])\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.RD","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.RD","text":"RD\n\nFactory object for RegularizedDecomposition. Pass to regularize in LShaped.Optimizer or set the Regularizer attribute. Equivalent factory calls: RD, WithRD, RegularizedDecomposition, WithRegularizedDecomposition. See ?RegularizedDecomposition for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.TrustRegion","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.TrustRegion","text":"TrustRegion\n\nFunctor object for using trust-region regularization in an L-shaped algorithm. Create by supplying a TR object through regularize in LShaped.Optimizer or by setting the Regularizer attribute.\n\n...\n\nParameters\n\nγ::T = 1e-4: Relative tolerance for deciding if a minor iterate should be accepted as a new major iterate.\nΔ::AbstractFloat = 1.0: Initial size of ∞-norm trust-region.\nΔ̅::AbstractFloat = 1000.0: Maximum size of ∞-norm trust-region.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.TR","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.TR","text":"TR\n\nFactory object for TrustRegion. Pass to regularize in LShaped.Optimizer or set the Regularizer attribute.. Equivalent factory calls: TR, WithTR, TrustRegion, WithTrustRegion. See ?TrustRegion for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.LevelSet","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.LevelSet","text":"LevelSet\n\nFunctor object for using level-set regularization in an L-shaped algorithm. Create by supplying an LV object through regularize in LShaped.Optimizer or by setting the Regularizer attribute.\n\n...\n\nParameters\n\nλ::AbstractFloat = 0.5: Controls the level position L = (1-λ)θ + λQ̃, a convex combination of the current lower and upper bound.\npenaltyterm::PenaltyTerm = Quadratic: Specify penaltyterm variant (Quadratic, InfNorm, [ManhattanNorm][@ref])\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.LV","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.LV","text":"LV\n\nFactory object for LevelSet. Pass to regularize in LShaped.Optimizer or set the Regularizer attribute. Equivalent factory calls: LV, WithLV, LevelSet, WithLevelSets. See ?LevelSet for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Aggregation","page":"L-shaped solvers","title":"Aggregation","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShaped.set_aggregation_attribute\nLShaped.set_aggregation_attributes","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_aggregation_attribute","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_aggregation_attribute","text":"set_aggregation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the aggregation-specific attribute identified by name to value.\n\n\n\n\n\n","category":"function"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_aggregation_attributes","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_aggregation_attributes","text":"set_aggregation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_aggregation_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"function"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShaped]\nPages   = [\"no_aggregation.jl\", \"partial_aggregation.jl\", \"dynamic_aggregation.jl\", \"cluster_aggregation.jl\", \"granulated_aggregation.jl\", \"hybrid_aggregation.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.DontAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.DontAggregate","text":"DontAggregate\n\nFactory object for NoAggregation. Passed by default to aggregate in LShaped.Optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.NoAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.NoAggregation","text":"NoAggregation\n\nEmpty functor object for running an L-shaped algorithm without aggregation (multi-cut L-shaped).\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Aggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Aggregate","text":"Aggregate\n\nFactory object for FullAggregation. Pass to aggregate in LShaped.Optimizer or by set the Aggregator attribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.PartialAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.PartialAggregate","text":"PartialAggregate\n\nFactory object for PartialAggregation. Pass to aggregate in LShaped.Optimizer or set the Aggregator attribute.  See ?PartialAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.PartialAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.PartialAggregation","text":"PartialAggregation\n\nFunctor object for using partial aggregation in an L-shaped algorithm. Create by supplying a PartialAggregate object through aggregate in LShaped.Optimizer or by setting the Aggregator attribute.\n\n...\n\nParameters\n\nsize::Int: Number of cuts in each aggregate\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T<:AbstractFloat","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.FullAggregation","text":"FullAggregation\n\nFunctor object for using complete aggregation in an L-shaped algorithm. Create by supplying an Aggregate object through aggregate in the LShapedSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.DynamicAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.DynamicAggregate","text":"DynamicAggregate(num_aggregates::Integer, rule::AbstractSelectionRule; lock_after::Function = (τ,n)->false)\n\nFactory object for DynamicAggregation. Pass to aggregate in LShaped.Optimizer or set the Aggregator attribute. See ?DynamicAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.DynamicAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.DynamicAggregation","text":"DynamicAggregation\n\nFunctor object for using dynamic aggregation in an L-shaped algorithm. Create by supplying a DynamicAggregate object through aggregate in LShaped.Optimizer or by setting the Aggregator attribute.\n\nThe following selection rules are available\n\nSelectUniform\nSelectDecaying\n[SelectRandom](@ref\nSelectClosest\nSortByReference\n\n...\n\nParameters\n\nnum_aggregates::Int: Number of aggregates\nrule::SelectionRule: Rule that determines which aggregate an incoming cut should be placed in\nlock_after::Function = (τ,n)->false: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap τ and the number of iterations n\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.ClusterAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.ClusterAggregate","text":"ClusterAggregate(rule::AbstractClusterRule; lock_after::Function = (τ,n)->false)\n\nFactory object for ClusterAggregation. Pass to aggregate in LShaped.Optimizer or set the Aggregator attribute. See ?ClusterAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.ClusterAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.ClusterAggregation","text":"ClusterAggregation\n\nFunctor object for using cluster aggregation in an L-shaped algorithm. Create by supplying a ClusterAggregate object through aggregate in LShaped.Optimizer or by setting the Aggregator attribute.\n\nThe following cluster rules are available\n\nStaticCluster\nClusterByReference\n[Kmedoids](@ref\nHierarchical\n\n...\n\nParameters\n\nrule::ClusterRule: Rule that determines how cuts should be sorted into clusters\nlock_after::Function = (τ,n)->false: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap τ and the number of iterations n\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.GranulatedAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.GranulatedAggregate","text":"GranulatedAggregate\n\nFactory object for GranulatedAggregation. Pass to aggregate in LShaped.Optimizer or set the Aggregator attribute.  See ?GranulatedAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.GranulatedAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.GranulatedAggregation","text":"GranulatedAggregation\n\nFunctor object for using partial aggregation in an L-shaped algorithm. Create by supplying a GranulatedAggregate object through aggregate in LShaped.Optimizer or by setting the Aggregator attribute.\n\n...\n\nParameters\n\nsize::Int: Number of cuts in each aggregate\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.HybridAggregate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.HybridAggregate","text":"HybridAggregate(initial::AbstractAggregator, final::AbstractAggregator, τ::AbstractFloat)\n\nFactory object for HybridAggregation. Pass to aggregate in LShaped.Optimizer or by setting the Aggregator attribute. See ?HybridAggregation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.HybridAggregation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.HybridAggregation","text":"HybridAggregation\n\nFunctor object for using hybrid aggregation in an L-shaped algorithm. Create by supplying a HybridAggregate object through aggregate in LShaped.Optimizer or by setting the Aggregator attribute.\n\n...\n\nParameters\n\ninitial::AbstractAggregator: Initial aggregation scheme\nfinal::AbstractAggregator: Final aggregation scheme\nτ::T: The active aggregation scheme is switched from initial to final when the optimality gap decreases below τ\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Selection-rules","page":"L-shaped solvers","title":"Selection rules","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShaped]\nPages   = [\"selection_rules.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.SelectClosest","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.SelectClosest","text":"SelectClosest(τ::AbstractFloat; distance::Function = absolute_distance)\n\nIncoming cuts are placed into the closest aggregate, according the supplied distance function. An empty aggregate is chosen if no aggregate is within the tolerance τ\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.SelectDecaying","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.SelectDecaying","text":"SelectDecaying(T₀::Integer, T̲::Integer = 1, γ::T)\n\nBehaves like SelectUniform, but the uniform aggregate size decays by γ each iteration, starting from T₀. T̲ is an optional lower bound on the aggregate size.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.SelectRandom","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.SelectRandom","text":"SelectRandom(max = Inf)\n\nIncoming cuts are placed into aggregates randomly. An optional maximum number of cuts max can be specified.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.SelectUniform","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.SelectUniform","text":"SelectUniform(n::Integer)\n\nIncoming cuts are placed into aggregates uniformly, so that each aggregate has at most n cuts. Behaves as PartialAggregation.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.SortByReference","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.SortByReference","text":"SortByReference(τ::AbstractFloat; distance::Function = absolute_distance)\n\nIncoming cuts are placed into an aggregate based on the distance to a reference cut, according the supplied distance function. Behaves as SelectClosest if not withing the tolerance τ to the reference cut.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Cluster-rules","page":"L-shaped solvers","title":"Cluster rules","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShaped]\nPages   = [\"cluster_rules.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.ClusterByReference","text":"ClusterByReference(τ::AbstractFloat; distance::Function = absolute_distance)\n\nBuffered cuts are aggregated if within the tolerance τ to a reference cut, according the supplied distance function. Behaves as multi-cut otherwise.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Hierarchical","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Hierarchical","text":"Hierarchical(nclusters::Int; distance::Function = absolute_distance, linkage::Symbol = :single)\n\nBuffered cuts are sorted into nclusters clusters, using a Hierarchical algorithm, with the given linkage, over a generalized distance matrix.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Kmedoids","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Kmedoids","text":"Kmedoids(nclusters::Int; distance::Function = absolute_distance)\n\nBuffered cuts are sorted into nclusters clusters, using a K-medoids algorithm over a generalized distance matrix.\n\nThe following distance measures are available\n\nabsolute_distance\nangular_distance\n[spatioangular_distance](@ref\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.StaticCluster","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.StaticCluster","text":"StaticCluster(clusters::Vector{Float64})\n\nBuffered cuts are sorting according to the supplied weights clusters\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#Distance-measures","page":"L-shaped solvers","title":"Distance measures","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShaped]\nPages   = [\"distance_measures.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.absolute_distance","text":"absolute_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)\n\nAbsolute distance between two optimality cuts\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.angular_distance","text":"angular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)\n\nAngular distance between two optimality cuts\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#StochasticPrograms.LShaped.spatioangular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.spatioangular_distance","text":"spatioangular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)\n\nSpatioangular distance between two optimality cuts.\n\n\n\n\n\n","category":"method"},{"location":"library/lshaped/#Consolidation","page":"L-shaped solvers","title":"Consolidation","text":"","category":"section"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"LShaped.set_consolidation_attribute\nLShaped.set_consolidation_attributes","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_consolidation_attribute","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_consolidation_attribute","text":"set_consolidation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the consolidation-specific attribute identified by name to value.\n\n\n\n\n\n","category":"function"},{"location":"library/lshaped/#StochasticPrograms.LShaped.set_consolidation_attributes","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.set_consolidation_attributes","text":"set_consolidation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_consolidation_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"function"},{"location":"library/lshaped/","page":"L-shaped solvers","title":"L-shaped solvers","text":"Modules = [LShaped]\nPages   = [\"consolidation.jl\"]","category":"page"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Consolidate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Consolidate","text":"Consolidate\n\nFactory object for Consolidation. Pass to consolidate in LShaped.Optimizer or set the Consolidator attribute. See ?Consolidation for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.Consolidation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.Consolidation","text":"Consolidation\n\nFunctor object for using consolidation in an L-shaped algorithm. Create by supplying a Consolidate object through consolidate in LShaped.Optimizer or by setting the Consolidator attribute.\n\n...\n\nAlgorithm parameters\n\ntresh::T = 0.95: Relative amount of redundant cuts in a former iteration required to consider the iteration redundant\nat::Int = 5.0: Number of times an iteration can be redundant before consolidation is triggered\nrebuild::Function = at_tolerance(): Function deciding when the master model should be rebuilt according to performed consolidations\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.DontConsolidate","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.DontConsolidate","text":"DontConsolidate\n\nFactory object for NoConsolidation. Passed by default to consolidate in LShaped.Optimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.NoConsolidation","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.NoConsolidation","text":"NoConsolidation\n\nEmpty functor object for running the L-shaped algorithm without consolidation.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.RawConsolidationParameter","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.RawConsolidationParameter","text":"RawConsolidationParameter\n\nAn optimizer attribute used for raw parameters of the consolidator. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/lshaped/#StochasticPrograms.LShaped.at_tolerance-Tuple{}","page":"L-shaped solvers","title":"StochasticPrograms.LShaped.at_tolerance","text":"at_tolerance(τ = 0.4, miniter = 0)\n\nRebuild master when at least nconsolidations*miniter iterations has passed and the ratio of number of cuts in the consolidated collection and the number of cuts in the master model has decreased below τ.\n\n\n\n\n\n","category":"method"},{"location":"manual/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"manual/examples/#Farmer-problem","page":"Examples","title":"Farmer problem","text":"","category":"section"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The following defines the well-known \"Farmer problem\", first outlined in Introduction to Stochastic Programming, in StochasticPrograms. The problem revolves around a farmer who needs to decide how to partition his land to sow three different crops. The uncertainty comes from not knowing what the future yield of each crop will be. Recourse decisions involve purchasing/selling crops at the market.","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"using StochasticPrograms\nusing GLPK","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"An example implementation of the farmer problem is given by:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Crops = [:wheat, :corn, :beets]\n@stochastic_model farmer_model begin\n    @stage 1 begin\n        @parameters begin\n            Crops = Crops\n            Cost = Dict(:wheat=>150, :corn=>230, :beets=>260)\n            Budget = 500\n        end\n        @decision(farmer_model, x[c in Crops] >= 0)\n        @objective(farmer_model, Min, sum(Cost[c]*x[c] for c in Crops))\n        @constraint(farmer_model, sum(x[c] for c in Crops) <= Budget)\n    end\n    @stage 2 begin\n        @parameters begin\n            Crops = Crops\n            Required = Dict(:wheat=>200, :corn=>240, :beets=>0)\n            PurchasePrice = Dict(:wheat=>238, :corn=>210)\n            SellPrice = Dict(:wheat=>170, :corn=>150, :beets=>36, :extra_beets=>10)\n        end\n        @uncertain ξ[c in Crops]\n        @recourse(farmer_model, y[p in setdiff(Crops, [:beets])] >= 0)\n        @recourse(farmer_model, w[s in Crops ∪ [:extra_beets]] >= 0)\n        @objective(farmer_model, Min, sum(PurchasePrice[p] * y[p] for p in setdiff(Crops, [:beets]))\n                   - sum(SellPrice[s] * w[s] for s in Crops ∪ [:extra_beets]))\n        @constraint(farmer_model, minimum_requirement[p in setdiff(Crops, [:beets])],\n            ξ[p] * x[p] + y[p] - w[p] >= Required[p])\n        @constraint(farmer_model, minimum_requirement_beets,\n            ξ[:beets] * x[:beets] - w[:beets] - w[:extra_beets] >= Required[:beets])\n        @constraint(farmer_model, beets_quota, w[:beets] <= 6000)\n    end\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The three yield scenarios can be defined through:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"ξ₁ = @scenario ξ[c in Crops] = [3.0, 3.6, 24.0] probability = 1/3\nξ₂ = @scenario ξ[c in Crops] = [2.5, 3.0, 20.0] probability = 1/3\nξ₃ = @scenario ξ[c in Crops] = [2.0, 2.4, 16.0] probability = 1/3","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We can now instantiate the farmer problem using the defined stochastic farmer_model and the three yield scenarios:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"farmer = instantiate(farmer_model, [ξ₁,ξ₂,ξ₃], optimizer = GLPK.Optimizer)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Printing:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"print(farmer)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We can now optimize the farmer_model:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"optimize!(farmer)\nx = optimal_decision(farmer)\nx = farmer[1,:x]\nprintln(\"Wheat: $(value(x[:wheat]))\")\nprintln(\"Corn: $(value(x[:corn]))\")\nprintln(\"Beets: $(value(x[:beets]))\")\nprintln(\"Profit: $(objective_value(farmer))\")","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We can also check results for a specific scenario:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"y = farmer[2,:y]\nw = farmer[2,:w]\nprintln(\"Purchased wheat: $(value(y[:wheat], 1))\")\nprintln(\"Purchased corn: $(value(y[:corn], 1))\")\nprintln(\"Sold wheat: $(value(w[:wheat], 1))\")\nprintln(\"Sold corn: $(value(w[:corn], 1))\")\nprintln(\"Sold beets: $(value(w[:extra_beets], 1))\")\nprintln(\"Profit: $(objective_value(farmer, 1))\")","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Finally, we calculate the stochastic performance of the farmer_model:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"println(\"EVPI: $(EVPI(farmer))\")\nprintln(\"VSS: $(VSS(farmer))\")","category":"page"},{"location":"manual/examples/#Continuous-scenario-distribution","page":"Examples","title":"Continuous scenario distribution","text":"","category":"section"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"As an example, consider the following generalized stochastic program:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"beginaligned\n operatorname*minimize_x in mathbbR  quad operatornamemathbbE_omega left(x - xi(omega))^2right \nendaligned","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"where xi(omega) is exponentially distributed. We will skip the mathematical details here and just take for granted that the optimizer to the above problem is the mean of the exponential distribution. We will try to approximately solve this problem using sample average approximation. First, lets try to introduce a custom discrete scenario type that farmer_models a stochastic variable with a continuous probability distribution. Consider the following implementation:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"using StochasticPrograms\nusing Distributions\n\nstruct DistributionScenario{D <: UnivariateDistribution} <: AbstractScenario\n    probability::Probability\n    distribution::D\n    ξ::Float64\n\n    function DistributionScenario(distribution::UnivariateDistribution, val::AbstractFloat)\n        return new{typeof(distribution)}(Probability(pdf(distribution, val)), distribution, Float64(val))\n    end\nend\n\nfunction StochasticPrograms.expected(scenarios::Vector{<:DistributionScenario{D}}) where D <: UnivariateDistribution\n    isempty(scenarios) && return DistributionScenario(D(), 0.0)\n    distribution = scenarios[1].distribution\n    return ExpectedScenario(DistributionScenario(distribution, mean(distribution)))\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The fallback probability method is viable as long as the scenario type contains a Probability field named probability. The implementation of expected is somewhat unconventional as it returns the mean of the distribution regardless of how many scenarios are given.","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"We can implement a sampler that generates exponentially distributed scenarios as follows:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"struct ExponentialSampler <: AbstractSampler{DistributionScenario{Exponential{Float64}}}\n    distribution::Exponential\n\n    ExponentialSampler(θ::AbstractFloat) = new(Exponential(θ))\nend\n\nfunction (sampler::ExponentialSampler)()\n    ξ = rand(sampler.distribution)\n    return DistributionScenario(sampler.distribution, ξ)\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Now, lets attempt to define the generalized stochastic program using the available farmer_modeling tools:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"using Ipopt\n\nsm = @stochastic begin\n    @stage 1 begin\n        @decision(model, x)\n    end\n    @stage 2 begin\n        @uncertain ξ from DistributionScenario\n        @objective(model, Min, (x - ξ)^2)\n    end\nend","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Two-Stage Stochastic Model\n\nminimize f₀(x) + 𝔼[f(x,ξ)]\n  x∈𝒳\n\nwhere\n\nf(x,ξ) = min  f(y; x, ξ)\n              y ∈ 𝒴 (x, ξ)","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"The mean of the given exponential distribution is 20, which is the optimal solution to the general problem. Now, lets create a finite sampled farmer_model of 1000 exponentially distributed numbers:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"sampler = ExponentialSampler(2.) # Create a sampler\n\nsp = instantiate(sm, sampler, 1000, optimizer = Ipopt.Optimizer) # Sample 1000 exponentially distributed scenarios and create a sampled farmer_model","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Stochastic program with:\n * 1 decision variable\n * 1 recourse variable\n * 1000 scenarios of type DistributionScenario\nSolver is default solver","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"By the law of large numbers, we approach the generalized formulation with increasing sample size. Solving yields:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"optimize!(sp)\n\nprintln(\"Optimal decision: $(optimal_decision(sp))\")\nprintln(\"Optimal value: $(objective_value(sp))\")","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Optimal decision: [2.0397762891884894]\nOptimal value: 4.00553678799426","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Now, due to the special implementation of the expected function, it actually holds that the expected value solution solves the generalized problem. Consider:","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"println(\"Expected value decision: $(expected_value_decision(sp)\")\nprintln(\"VSS: $(VSS(sp))\")","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"EVP decision: [2.0]\nVSS: 0.00022773669794418083","category":"page"},{"location":"manual/examples/","page":"Examples","title":"Examples","text":"Accordingly, the VSS is small.","category":"page"},{"location":"manual/model/#Stochastic-models","page":"Stochastic models","title":"Stochastic models","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @stochastic_model command is now introduced in more detail. The discussion will as before revolve around the simple example introduced in the Quick start:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@stochastic_model simple_model begin\n    @stage 1 begin\n        @decision(simple_model, x₁ >= 40)\n        @decision(simple_model, x₂ >= 20)\n        @objective(simple_model, Min, 100*x₁ + 150*x₂)\n        @constraint(simple_model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @known(simple_model, x₁, x₂)\n        @uncertain q₁ q₂ d₁ d₂\n        @recourse(simple_model, 0 <= y₁ <= d₁)\n        @recourse(simple_model, 0 <= y₂ <= d₂)\n        @objective(simple_model, Max, q₁*y₁ + q₂*y₂)\n        @constraint(simple_model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(simple_model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Note, that the resulting model object is stored in simple_model, and that the same name is used to reference the stochastic program in the @stage blocks. The following anonymous syntax is also supported:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"simple_model = @stochastic_model begin\n    @stage 1 begin\n        @decision(model, x₁ >= 40)\n        @decision(model, x₂ >= 20)\n        @objective(model, Min, 100*x₁ + 150*x₂)\n        @constraint(model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @known(model, x₁, x₂)\n        @uncertain q₁ q₂ d₁ d₂\n        @recourse(model, 0 <= y₁ <= d₁)\n        @recourse(model, 0 <= y₂ <= d₂)\n        @objective(model, Max, q₁*y₁ + q₂*y₂)\n        @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"where the reserved keyword model is used in the @stage blocks.","category":"page"},{"location":"manual/model/#[@stage](@ref)-blocks","page":"Stochastic models","title":"@stage blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The body of a @stochastic_model definition consists of a number of @stage blocks, following the syntax:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@stage N begin\n    ...\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Here, N is the stage number and the body is made up of JuMP syntax as well as @parameters, @decision, and @uncertain blocks. At least two stages must be defined and the stages must be defined in consecutive order starting with the first stage. The number of stage blocks included in the @stochastic_model definition determines the number of stages that a stochastic program instantiated from the resulting stochastic model will have.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"note: Note\nIt is possible to define and instantiate stochastic models with more than two stages. However, most internal tools and solvers only support two-stage models at this point.","category":"page"},{"location":"manual/model/#[@parameters](@ref)-blocks","page":"Stochastic models","title":"@parameters blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @parameters blocks are used to introduce deterministic parameters to a @stage block. See for example Stage data. The following:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@parameters a b","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"makes the constants a and b available as model parameters. This incurs a promise that those parameters will be injected when instantiating the model, and if no default values are available they must be supplied by the user. In other words, if sm is a stochastic model that includes the above @parameters annotation in one of its @stage blocks, then those parameters must be supplied as keyword arguments when instantiating stochastic programs using this model:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"instantiate(sm, scenarios, a = 1, b = 2)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Alternatively, default values can be specified directly in the @parameters block:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@parameters begin\n    a = 1\n    b = 2\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Values supplied to instantiate are always used, and otherwise the default values are used. The responsibility is on the user to ensure that the supplied parameters support the operations used in the @stage blocks. Parameters can be reused in multiple blocks, but each occurance must be annotated by @parameters in each of the stages.","category":"page"},{"location":"manual/model/#[@decision](@ref)-blocks","page":"Stochastic models","title":"@decision blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @decision blocks are used to annotate linking variables between stages. Their usage is identical syntax-wise to JuMP's @variable macros. Internally, they create specialized JuMP variables with context-dependent behaviour.","category":"page"},{"location":"manual/model/#[@recourse](@ref)-blocks","page":"Stochastic models","title":"@recourse blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @recourse macro functions like the @decision macro, but is only used to annotate recourse decisions in the final stage.","category":"page"},{"location":"manual/model/#[@known](@ref)-blocks","page":"Stochastic models","title":"@known blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"A @known annotation is used in subsequent stages to bring a decision defined in a previous stage into scope. Any decision defined by @decision inside a @stochastic_model automatically annotates subsequent stages with appropriate @known lines.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @known block in the simple example above is given by","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@known(simple_moel, x₁, x₂)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"This states that the second stage of the stochastic model depends on the decisions x₁ and x₂ taken in the previous stage. Note again that this lines is implicitly added by @stochastic_model and is not required.","category":"page"},{"location":"manual/model/#[@uncertain](@ref)-blocks","page":"Stochastic models","title":"@uncertain blocks","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The @uncertain blocks are used to annotate stochastic data in the stochastic model. For flexibility, there are several different ways of doing this. However, an @uncertain annotation is always connected to some AbstractScenario type, as introduced in Scenario data. Note, that a @stage block can only include one @uncertain block. All stochastic information in a given stage must therefore be captured in the @uncertain block of that stage.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The most simple approach is to use leverage the Scenario type. Consider the @uncertain annotation given above:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"This will ensure that Scenarios that are expected to have the fields q₁, q₂, d₁ and d₂ are injected when constructing second-stage models. Each such scenario must be supplied or sampled using a supplied sampler object. It is the responsibility of the user to ensure that each supplied or sampled Scenario has the correct fields. For example, the following yields a Scenario compatible with the above @uncertain line:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Scenario(q₁ = 24.0,\n         q₂ = 28.0,\n         d₁ = 500.0,\n         d₂ = 100.0,\n         probability = 0.4)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Alternatively, the same scenario is conveniently created using the @scenario macro, matching the syntax of the @uncertain declaration:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"We can also use JuMP's container syntax:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain ξ[1:5]\n@uncertain ξ[i in 1:5]\n@uncertain ξ[i in 1:5, i != 3]\n@uncertain ξ[i in 1:5, j in 1:5]\n@uncertain ξ[i in 1:5, k in [:a,:b,:c]]","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"and then use the a corresponding formulation in the @scenario macro to generate scenarios:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"ξ = @scenario ξ[1:5] = rand(5) probability = rand()\nξ = @scenario ξ[i in 1:5] i * rand() probability = rand()\nξ = @scenario ξ[i in 1:5, i != 3] i * rand() probability = rand()\nξ = @scenario ξ[i in 1:5, j in 1:5] = rand(5,5) probability = rand()\nξ = @scenario ξ[i in 1:5, k in [:a,:b,:c]] = rand(5,5) probability = rand()","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Note, that we above sometimes assign the full random vector directly, and sometimes provide an indexed based formula.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"As shown in Stochastic data, it is also possible to introduce other scenario types, either using @define_scenario or manally as explained in Custom scenarios and demonstrated in the Continuous scenario distribution example. If we instead define the necessary scenario structure as follows:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@define_scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"One can then use:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain ξ::SimpleScenario","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"and extract the required fields from ξ which will be of type SimpleScenario after data injection. Again, it is the responsibility of the user to supply scenarios of this type when instantiating the model. For example, the following constructs a SimpleScenario compatible with the above @uncertain line:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"SimpleScenario(-24.0, -28.0, 500.0, 100.0, probability = 0.4)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"It is also possible to directly unpack the necessary fields using the following syntactic sugar:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from SimpleScenario","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The actual scenario instance can still be annotated and used if necessary:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from ξ::SimpleScenario","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Finally, if the @uncertain block is used within a @stochastic_model environment, it is possible to simultaneosly define the underlying scenario type. In other words,","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain ξ::SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"and","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@uncertain q₁ q₂ d₁ d₂ from ξ::SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"are all possible methods of defining and using the SimpleScenario type in a @stage block.","category":"page"},{"location":"manual/model/#Model-instantiation","page":"Stochastic models","title":"Model instantiation","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"A model object sm defined using @stochastic_model can be used to instantiate stochastic programs over both finite/infinite sample spaces and discrete/continuous random variables.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"If the scenarios are associated with a discrete random variable over a finite sample space, then the corresponding stochastic program is finite and can be instantiated by providing the full list of scenarios:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = instantiate(sm, scenarios)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Here, scenarios is a vector of scenarios consistent with the @uncertain annotation used in the second stage of sm. It is the responsibility of the user to ensure that the individual probabilities of the scenarios sum up to one, so that the model is consistent.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"If the scenarios are instead associated with a continuous random variable, with finite second moments, over an infinite sample space, then the corresponding stochastic program is not finite and must be approximated. The only supported way of doing so in StochasticPrograms is by using sampled average approximations. A finite stochastic program that approximates the stochastic model is obtained through","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = instantiate(sm, sampler, n)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"where sampler is an AbstractSampler, as outlined in Sampling, and n is the number of samples to include.","category":"page"},{"location":"manual/model/#Instant-models","page":"Stochastic models","title":"Instant models","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"It is possible to create one-off stochastic programs without needing to first define a model object. To do so, any required scenario data structure must be defined first. Consider:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"using StochasticPrograms\n\n@define_scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend\nξ₁ = SimpleScenario(-24.0, -28.0, 500.0, 100.0, probability = 0.4)\nξ₂ = SimpleScenario(-28.0, -32.0, 300.0, 300.0, probability = 0.6)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Next, an unmodeled stochastic program can be instantiated using the two created scenarios:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = StochasticProgram([ξ₁, ξ₂], Deterministic())","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Note that we must provide the instantiation type explicitly as well. A slightly diferrent modeling syntax is now used to define the stage models of sp:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@first_stage sp = begin\n    @decision(sp, x₁ >= 40)\n    @decision(sp, x₂ >= 20)\n    @objective(sp, Min, 100*x₁ + 150*x₂)\n    @constraint(sp, x₁ + x₂ <= 120)\nend\n@second_stage sp = begin\n    @known(sp, x₁, x₂)\n    @uncertain q₁ q₂ d₁ d₂ from SimpleScenario\n    @recourse(sp, 0 <= y₁ <= d₁)\n    @recourse(sp, 0 <= y₂ <= d₂)\n    @objective(sp, Min, q₁*y₁ + q₂*y₂)\n    @constraint(sp, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(sp, 8*y₁ + 5*y₂ <= 80*x₂)\nend","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Here, @first_stage and @second_stage are just syntactic sugar for @stage 1 and @stage 2. Note, that the model name sp must be used internally in the @stage blocks when referencing the model. This is is the definition syntax used internally by StochasticModel objects when instantiating stochastic programs. Note, that we must explicitly add the @known annotations to the second stage with this approach, while models created using @stochastic_model does this automatically. We can verify that this approach yields the same stochastic program by printing and comparing to the Quick start:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"print(sp)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"As a side note, it is possible to run stage definition macros on programs with existing models. This overwrites the previous model and upon regeneration all internal problems. For example, the following increases the lower bound on the second stage variables to 2:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"@stage 2 sp = begin\n    @known(sp, x₁, x₂)\n    @uncertain q₁ q₂ d₁ d₂ from SimpleScenario\n    @recourse(sp, 2 <= y₁ <= d₁)\n    @recourse(sp, 2 <= y₂ <= d₂)\n    @objective(sp, Min, q₁*y₁ + q₂*y₂)\n    @constraint(sp, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(sp, 8*y₁ + 5*y₂ <= 80*x₂)\nend\n\ngenerate!(sp)\n\nprint(sp)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"It is of course also possible to do this on programs instantiated from a StochasticModel.","category":"page"},{"location":"manual/model/#SMPS","page":"Stochastic models","title":"SMPS","text":"","category":"section"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"StochasticPrograms also support reading models specified in the SMPS format. Specifically, SMPS definitions with uncertain data of types INDEP or BLOCKS are supported. We show how the simple example can be specified in SMPS. An SMPS definition consist of the following files:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"problem.smps\nproblem.tim\nproblem.cor\nproblem.sto","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Here, problem.smps is just an empty file that shares the name with the others to simplify IO commands. The problem.tim file specifies the stage structure of the stochastic program. An example for the simple problem is given below.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"TIME          SIMPLE\nPERIODS\n    X1        BOUND                    STAGE1\n    Y1        LINK1                    STAGE2\nENDATA","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Row and column delimeters are given for each stage. The problem.cor file specifies the optimization structure of the problem in MPS format. An example for the simple problem as follows.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"NAME          SIMPLE\nROWS\n N  OBJ\n L  BOUND\n L  LINK1\n L  LINK2\n L  Y1UP\n L  Y2UP\nCOLUMNS\n    X1        OBJ       100.0          BOUND     1.0\n    X2        OBJ       150.0          BOUND     1.0\n    X1        LINK1     -60.0\n    X2        LINK2     -80.0\n    Y1        OBJ       26.0           Y1UP      1.0\n    Y2        OBJ       30.0           Y2UP      1.0\n    Y1        LINK1     6.0            LINK2     8.0\n    Y2        LINK1     10.0           LINK2     5.0\nRHS\n    RHS       BOUND     120.0\n    RHS       LINK1     0.0\n    RHS       LINK2     0.0\n    RHS       Y1UP      400.0\n    RHS       Y2UP      200.0\nBOUNDS\n LO X1LIM     X1        40.0\n LO X2LIM     X2        20.0\n LO Y1LIM     Y1        0.0\n LO Y2LIM     Y2        0.0\nENDATA","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Finally, the problem.sto file specifies the uncertain data. We use the BLOCKS format to specify the simple scenarios.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"STOCH         SIMPLE\nBLOCKS        DISCRETE\n BL BLOCK1    STAGE2    0.4\n    Y1        OBJ       -24.0\n    Y2        OBJ       -28.0\n    RHS       Y1UP      500.0\n    RHS       Y2UP      100.0\n BL BLOCK1    STAGE2    0.6\n    Y1        OBJ       -28.0\n    Y2        OBJ       -32.0\n    RHS       Y1UP      300.0\n    RHS       Y2UP      300.0\nENDATA","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"We specify the two scenarios, giving the value in each corresponding coordinate in the problem.cor file. Now, we can read this model into Julia in several ways, assuming all files are in the same folder. First, consider","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"model = read(\"problem.smps\", StochasticModel)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Two-Stage Stochastic Model\n\nminimize f₀(x) + 𝔼[f(x,ξ)]\n  x∈𝒳\n\nwhere\n\nf(x,ξ) = min  f(y; x, ξ)\n              y ∈ 𝒴 (x, ξ)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"This returns a StochasticModel object that can be used as usual, assuming it is instantiated with the scenarios of the special SMPSScenario type. To that end, we can read a specialized sampler object for the specified SMPS model:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sampler = read(\"problem.smps\", SMPSSampler)\nsampler()","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"SMPSScenario with probability 1.0 and underlying data:\n\nΔq = [0.0, 0.0, -54.0, -62.0]\nΔT = 0×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries\nΔW = 0×2 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries\nΔh = Float64[]\nΔC = 4×4 SparseArrays.SparseMatrixCSC{Float64,Int64} with 0 stored entries\nΔd₁ = [0.0, 0.0, 0.0, 0.0]\nΔd₂ = [0.0, 0.0, -100.0, 100.0]","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"We can now instantiate a specific instance of the read model:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = instantiate(model, sampler, 2)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Stochastic program with:\n * 2 decision variables\n * 2 recourse variables\n * 2 scenarios of type SMPSScenario\nStructure: Deterministic equivalent\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"The same result, up to sampling, can be achieved directly through","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = read(\"problem.smps\", StochasticProgram, num_scenarios = 2)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Stochastic program with:\n * 2 decision variables\n * 2 recourse variables\n * 2 scenarios of type SMPSScenario\nStructure: Deterministic equivalent\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"This read variant takes the same keyword arguments as instantiate. Because the specified scenario structure in BLOCKS or INDEP format has finite support, it is possible to read the stochastic program corresponding to the full support by not specifying num_scenarios:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"sp = read(\"problem.smps\", StochasticProgram)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Stochastic program with:\n * 2 decision variables\n * 2 recourse variables\n * 2 scenarios of type SMPSScenario\nStructure: Deterministic equivalent\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"In this case, the full support correspond exactly to the simple model we have considered before:","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"print(sp)","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"Deterministic equivalent problem\nMin 100 x[1] + 150 x[2] - 16.8 y₂[1] - 19.2 y₂[2] - 9.600000000000001 y₁[1] - 11.200000000000001 y₁[2]\nSubject to\n y₁[1] ≥ 0.0\n y₁[2] ≥ 0.0\n y₂[1] ≥ 0.0\n y₂[2] ≥ 0.0\n [x[1], x[2]] ∈ Decisions\n x[1] ≥ 40.0\n x[2] ≥ 20.0\n [x[1] + x[2] - 120] ∈ MathOptInterface.Nonpositives(1)\n [-60 x[1] + 6 y₁[1] + 10 y₁[2], -80 x[2] + 8 y₁[1] + 5 y₁[2], y₁[1] - 500, y₁[2] - 100] ∈ MathOptInterface.Nonpositives(4)\n [-60 x[1] + 6 y₂[1] + 10 y₂[2], -80 x[2] + 8 y₂[1] + 5 y₂[2], y₂[1] - 300, y₂[2] - 300] ∈ MathOptInterface.Nonpositives(4)\nSolver name: No optimizer attached.","category":"page"},{"location":"manual/model/","page":"Stochastic models","title":"Stochastic models","text":"A warning is issued if the full support contains more than 1e5 scenarios.","category":"page"},{"location":"manual/distributed/#Distributed-stochastic-programs","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"","category":"section"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Stochastic programs related to industrial applications are often associated with complex models and vast numbers of scenarios, often in the order of 1000-1000000. Hence, the extensive form can have billions of variables and constraints, and often does not fit in memory on a single machine. This clarifies the need for solution approaches that work in parallel on distributed data when instantiating and optimizing large-scale stochastic programs.","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"If multiple Julia processes are available, locally or in a cluster, StochasticPrograms natively distributes any defined stochastic programs on the available processing nodes. Consider as before:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"using Distributed\n\naddprocs(3)\n\n@everywhere using StochasticPrograms\n@everywhere using Distributions\n\n@sampler SimpleSampler = begin\n    N::MvNormal\n\n    SimpleSampler(μ, Σ) = new(MvNormal(μ, Σ))\n\n    @sample Scenario begin\n        x = rand(sampler.N)\n        return Scenario(q₁ = x[1], q₂ = x[2], d₁ = x[3], d₂ = x[4])\n    end\nend\n\nμ = [28, 32, 300, 300]\nΣ = [2 0.5 0 0\n     0.5 1 0 0\n     0 0 50 20\n     0 0 20 30]\n\nsampler = SimpleSampler(μ, Σ)","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"@scenario and @sampler automatically ensures that the introduced scenario and sampler types are available on all processes. Define the stochastic model in the usual way:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"@stochastic_model simple_model begin\n    @stage 1 begin\n        @decision(simple_model, x₁ >= 40)\n        @decision(simple_model, x₂ >= 20)\n        @objective(simple_model, Min, 100*x₁ + 150*x₂)\n        @constraint(simple_model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @uncertain q₁ q₂ d₁ d₂ from SimpleScenario\n        @recourse(simple_model, 0 <= y₁ <= d₁)\n        @recourse(simple_model, 0 <= y₂ <= d₂)\n        @objective(simple_model, Min, q₁*y₁ + q₂*y₂)\n        @constraint(simple_model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(simple_model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"and instantiate a sampled model with 10 sceanarios:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"sp = instantiate(simple_model, sampler, 10)","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"the lightweight model recipes are passed to all worker nodes. The worker nodes then use the recipes and lightweight sampler object to instantiate second stage models in parallel. This is one of the intended outcomes of the design choices made in StochasticPrograms. The separation between data design and model design allows us to minimize data passing in a natural way.","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Many operations in StochasticPrograms are embarassingly parallel which is exploited throughout when a stochastic program is distributed. Notably:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"evaluate_decision\nEVPI\nVSS","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Perform many subproblem independent operations in parallel. The best performance is achieved if the optimization of the recourse problem is performed by an algorithm that can operate in parallel on the distributed stochastic programs. The solver suites provided by the LShaped and ProgressiveHedging modules are examples of this. For example, we can optimize the distributed version of the simple stochastic program with a parallelized L-shaped algorithm as follows:","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"using GLPK\n\nsp = instantiate(simple_model, sampler, 10, optimizer = () -> LShaped.Optimizer(GLPK.Optimizer))\n\noptimize!(sp)","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"Distributed L-Shaped Gap  Time: 0:00:03 (6 iterations)\n  Objective:       -855.8333333333339\n  Gap:             0.0\n  Number of cuts:  7","category":"page"},{"location":"manual/distributed/","page":"Distributed stochastic programs","title":"Distributed stochastic programs","text":"A quick note should also be made about the API calls that become less efficient in a distributed setting. This includes all calls that collect data that reside on remote processes. The functions in this category that involve the most data passing is scenarios, which fetches all scenarios in the stochastic program, and subproblems, which fetches all second stage models in the stochastic program. If these collections are required frequently it is recommended to not distribute the stochastic program. This can be ensured by supplying procs = [1] to the constructor call. Individual queries scenario(stochasticprogram, i) and subproblem(stochasticprogram, i) are viable depending on the size of the scenarios/models. If a MathProgBase solver is supplied to a distributed stochastic program it will fetch all scenarios to the master node and attempt to build the extensive form. Long computation times are expected for large-scale models, assuming they fit in memory. If so, it is again recommended to avoid distributing the stochastic program through procs = [1]. The best approach is to use a structured solver that can operate on distributed stochastic programs, such as LShaped or ProgressiveHedging.","category":"page"},{"location":"library/SAA/#Sample-average-approximation","page":"Sample average approximation","title":"Sample average approximation","text":"","category":"section"},{"location":"library/SAA/","page":"Sample average approximation","title":"Sample average approximation","text":"Documentation for StochasticPrograms.jl's SAA solvers.","category":"page"},{"location":"library/SAA/#Index","page":"Sample average approximation","title":"Index","text":"","category":"section"},{"location":"library/SAA/","page":"Sample average approximation","title":"Sample average approximation","text":"Pages = [\"SAA.md\"]","category":"page"},{"location":"library/SAA/#API","page":"Sample average approximation","title":"API","text":"","category":"section"},{"location":"library/SAA/","page":"Sample average approximation","title":"Sample average approximation","text":"Modules = [SAA]\nPages   = [\"MOI_wrapper.jl\"]","category":"page"},{"location":"library/progressivehedging/#Progressive-hedging-solvers","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"Documentation for StochasticPrograms.jl's progressive-hedging solvers.","category":"page"},{"location":"library/progressivehedging/#Index","page":"Progressive-hedging solvers","title":"Index","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"Pages = [\"progressivehedging.md\"]","category":"page"},{"location":"library/progressivehedging/#API","page":"Progressive-hedging solvers","title":"API","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"ProgressiveHedgingAlgorithm","category":"page"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.ProgressiveHedgingAlgorithm","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.ProgressiveHedgingAlgorithm","text":"ProgressiveHedgingAlgorithm\n\nFunctor object for the progressive-hedging algorithm. Create using the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nτ::AbstractFloat = 1e-6: Relative tolerance for convergence checks.\nlog::Bool = true: Specifices if progressive-hedging procedure should be logged on standard output or not.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"Modules = [ProgressiveHedging]\nPages   = [\"attributes.jl\", \"MOI_wrapper.jl\"]","category":"page"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.AbstractProgressiveHedgingAttribute","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.AbstractProgressiveHedgingAttribute","text":"AbstractProgressiveHedgingAttribute\n\nAbstract supertype for attribute objects specific to the progressive-hedging algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.DualTolerance","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.DualTolerance","text":"DualTolerance\n\nAn optimizer attribute for specifying the dual tolerance in the progressive-hedging algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.PenalizationParameter","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.PenalizationParameter","text":"PenalizationParameter\n\nAbstract supertype for penalization-specific attributes.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.Penalizer","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.Penalizer","text":"Regularizer\n\nAn optimizer attribute for specifying a penalization procedure to be used in the progressive-hedging algorithm. Options are:\n\nFixed:  Fixed penalty (default) ?Fixed for parameter descriptions.\nAdaptive: Adaptive penalty update ?Adaptive for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.PenaltyTerm","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.PenaltyTerm","text":"PenaltyTerm\n\nAn optimizer attribute for specifying what proximal term should be used in subproblemsof the progressive-hedging algorithm. Options are:\n\nQuadratic (default)\nLinearized\nInfNorm\nManhattanNorm\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.PrimalTolerance","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.PrimalTolerance","text":"PrimalTolerance\n\nAn optimizer attribute for specifying the primal tolerance in the progressive-hedging algorithm.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.Optimizer","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.Optimizer","text":"Optimizer(; <keyword arguments>)\n\nReturn a progressive-hedging optimizer.\n\n...\n\nArguments\n\nsubproblem_optimizer::AbstractOptimizer: MathOptInterface solver capable of solving quadratic programs.\npenalty::AbstractPenalizer = Fixed(): Specify penalty update procedure (Fixed, Adaptive)\nexecution::AbstractExecuter = Serial: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.\npenaltyterm::PenaltyTerm = Quadratic: Specify penaltyterm variant (Quadratic, Linearized, InfNorm, [ManhattanNorm][@ref])\n<keyword arguments>: Algorithm specific parameters, consult individual docstrings (see above list) for list of possible arguments and default values.\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.get_penalization_attribute-Tuple{StochasticProgram, String}","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.get_penalization_attribute","text":"get_penalization_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the penalization-specific attribute named name in stochasticprogram.\n\nSee also: set_penalization_attribute, set_penalization_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.set_penalization_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.set_penalization_attribute","text":"set_penalization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the penalization-specific attribute identified by name to value.\n\n\n\n\n\n","category":"method"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.set_penalization_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.set_penalization_attributes","text":"set_penalization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_penalization_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"method"},{"location":"library/progressivehedging/#Execution","page":"Progressive-hedging solvers","title":"Execution","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"ProgressiveHedging.SerialExecution\nProgressiveHedging.SynchronousExecution\nProgressiveHedging.AsynchronousExecution","category":"page"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.SerialExecution","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.SerialExecution","text":"SerialExecution\n\nFunctor object for using serial execution in a progressive-hedging algorithm. Create by supplying a Serial object through execution in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.SynchronousExecution","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.SynchronousExecution","text":"SynchronousExecution\n\nFunctor object for using synchronous execution in a progressive-hedging algorithm (assuming multiple Julia cores are available). Create by supplying a Synchronous object through execution in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.AsynchronousExecution","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.AsynchronousExecution","text":"AsynchronousExecution\n\nFunctor object for using asynchronous execution in a progressive-hedging algorithm (assuming multiple Julia cores are available). Create by supplying an Asynchronous object through execution in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#Penalties","page":"Progressive-hedging solvers","title":"Penalties","text":"","category":"section"},{"location":"library/progressivehedging/","page":"Progressive-hedging solvers","title":"Progressive-hedging solvers","text":"ProgressiveHedging.set_penalization_attribute\nProgressiveHedging.set_penalization_attributes\nProgressiveHedging.RawPenalizationParameter\nProgressiveHedging.FixedPenalization\nProgressiveHedging.Fixed\nProgressiveHedging.AdaptivePenalization\nProgressiveHedging.Adaptive","category":"page"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.set_penalization_attribute","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.set_penalization_attribute","text":"set_penalization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets the penalization-specific attribute identified by name to value.\n\n\n\n\n\n","category":"function"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.set_penalization_attributes","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.set_penalization_attributes","text":"set_penalization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_penalization_attribute(stochasticprogram, attribute, value) for each pair.\n\n\n\n\n\n","category":"function"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.RawPenalizationParameter","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.RawPenalizationParameter","text":"RawPenalizationParameter\n\nAn optimizer attribute used for raw parameters of the penalizer. Defers to RawOptimizerAttribute.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.FixedPenalization","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.FixedPenalization","text":"FixedPenalization\n\nFunctor object for using fixed penalty in a progressive-hedging algorithm. Create by supplying a Fixed object through penalty in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nr::T = 1.00: Fixed penalty\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.Fixed","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.Fixed","text":"Fixed\n\nFactory object for FixedPenalization. Pass to penalty in the ProgressiveHedgingSolver factory function. See ?FixedPenalization for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.AdaptivePenalization","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.AdaptivePenalization","text":"AdaptivePenalization\n\nFunctor object for using adaptive penalty in a progressive-hedging algorithm. Create by supplying an Adaptive object through penalty in the ProgressiveHedgingSolver factory function and then pass to a StochasticPrograms.jl model.\n\n...\n\nParameters\n\nζ::T = 0.1: Used to calculate the initial penalty. Non-anticipativity in the initial decision is enforced more as ζ increase.\nγ₁::T = 1e-5: Tolerance for primal changes being significant\nγ₂::T = 0.01: Tolerance for primal changes dominating dual changes\nγ₃::T = 0.25: Tolerance for dual changes dominating primal changes\nσ::T = 1e-5: Tolerance for the quadratic penalty dominating the Lagrangian\nα::T = 0.95: Penalty decrease after primal changes dominating dual changes\nθ::T = 1.1: Penalty increase after dual changes dominating primal changes\nν::T = 0.1: Tolerance for significant non-anticipativity violation\nβ::T = 1.1: Penalty increase after increased non-anticipativity violation\nη::T = 1.25: Default penalty increase in the default case\n\n...\n\n\n\n\n\n","category":"type"},{"location":"library/progressivehedging/#StochasticPrograms.ProgressiveHedging.Adaptive","page":"Progressive-hedging solvers","title":"StochasticPrograms.ProgressiveHedging.Adaptive","text":"Adaptive\n\nFactory object for AdaptivePenalization. Pass to penalty in the ProgressiveHedgingSolver factory function. See ?AdaptivePenalization for parameter descriptions.\n\n\n\n\n\n","category":"type"},{"location":"#StochasticPrograms.jl","page":"Home","title":"StochasticPrograms.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A modeling framework for stochastic programming problems","category":"page"},{"location":"#Summary","page":"Home","title":"Summary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Stochastic programming models recourse problems where an initial decision is taken, uncertain parameters are observed, followed by recourse decisions to correct any inaccuracy in the initial decision. StochasticPrograms.jl is a general purpose modeling framework for stochastic programming. The framework includes both modeling tools and structure-exploiting optimization algorithms. The underlying optimization problems are formulated using JuMP.jl. Stochastic programming models can be efficiently formulated using an expressive syntax and models can be instantiated, inspected, and analyzed interactively. The framework scales seamlessly to distributed environments. Small instances of a model can be run locally to ensure correctness, while larger instances are automatically distributed in a memory-efficient way onto supercomputers or clouds and solved using parallel optimization algorithms. These structure-exploiting solvers are based on variations of the classical L-shaped, progressive-hedging, and quasi-gradient algorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The framework will prove useful to researchers, educators and industrial users alike. Researchers will benefit from the readily extensible open-source framework, where they can formulate complex stochastic models or quickly typeset and test novel optimization algorithms. Educators of stochastic programming will benefit from the clean and expressive syntax. Moreover, the framework supports analysis tools and stochastic programming constructs, such as expected value of perfect information (EVPI) and value of the stochastic solution (VSS), from classical theory and leading textbooks. Industrial practitioners can make use of StochasticPrograms.jl to rapidly formulate complex models, analyze small instances locally, and then run large-scale instances in production. In doing so, they get distributed capabilities for free, without changing the code, and access to well-tested state-of-the-art implementations of parallel structure-exploiting solvers. A good introduction to recourse models, and to the stochastic programming constructs provided in this package, is given in Introduction to Stochastic Programming.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Flexible problem definition\nDeferred model instantiation\nScenario data injection\nComprehensive collection of stochastic programming methods\nNatively distributed\nInterface to structure-exploiting solver algorithms\nEfficient parallel implementations of classical algorithms","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider Quick start for a tutorial explaining how to get started using StochasticPrograms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some examples of models written in StochasticPrograms can be found on the Examples page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Index for the complete list of documented functions and types.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use StochasticPrograms, please cite the following preprint:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{spjl,\n  title     = {Efficient Stochastic Programming in {J}ulia},\n  author    = {Martin Biel and Mikael Johansson},\n  journal   = {arXiv preprint arXiv:1909.10451},\n  year      = {2019}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the cut aggregation funcionality for L-shaped, please cite the following preprint","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{cutaggregation,\n  title     = {Dynamic cut aggregation in {L}-shaped algorithms},\n  author    = {Martin Biel and Mikael Johansson},\n  journal   = {arXiv preprint arXiv:1910.13752},\n  year      = {2019}\n}","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual/quickstart.md\", \"manual/data.md\", \"manual/model.md\", \"manual/decisions.md\", \"manual/distributed.md\", \"manual/structuredsolvers.md\", \"manual/examples.md\"]","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library/public.md\", \"library/solverinterface.md\", \"library/crash.md\", \"library/lshaped.md\", \"library/progressivehedging.md\", \"library/SAA.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library/public.md\"]\nOrder   = [:type, :macro, :function]","category":"page"},{"location":"library/public/#Public-interface","page":"Public interface","title":"Public interface","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Documentation for StochasticPrograms.jl's public interface.","category":"page"},{"location":"library/public/#Contents","page":"Public interface","title":"Contents","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Pages = [\"public.md\"]","category":"page"},{"location":"library/public/#Index","page":"Public interface","title":"Index","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Pages = [\"public.md\"]\nOrder   = [:type, :macro, :function]","category":"page"},{"location":"library/public/#Constructors","page":"Public interface","title":"Constructors","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"stochasticprogram.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.StochasticProgram","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram\n\nAn instance of a stochastic optimization problem.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StochasticProgram-2","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(first_stage_params::Any,\n                  second_stage_params::Any,\n                  scenarios::Vector{<:AbstractScenario},\n                  instantiation::StochasticInstantiation,\n                  optimizer_constructor = nothing)\n\nCreate a new two-stage stochastic program with a given collection of scenarios. Optionally, a capable optimizer_constructor can be supplied to later optimize the stochastic program. If multiple Julia processes are available, the resulting stochastic program will automatically be memory-distributed on these processes. This can be avoided by setting procs = [1].\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StochasticProgram-3","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(first_stage_params::Any,\n                  second_stage_params::Any,\n                  instantiation::StochasticInstantiation,\n                  optimizer_constructor=nothing) where T <: AbstractFloat\n\nCreate a new two-stage stochastic program with stage data given by first_stage_params and second_stage_params. After construction, scenarios of type Scenario can be added through add_scenario!. Optionally, a capable optimizer_constructor can be supplied to later optimize the stochastic program. If multiple Julia processes are available, the resulting stochastic program will automatically be memory-distributed on these processes. This can be avoided by setting procs = [1].\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StochasticProgram-4","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(scenarios::Vector{<:AbstractScenario},\n                  instantiation::StochasticInstantiation,\n                  optimizer_constructor = nothing)\n\nCreate a new two-stage stochastic program with a given collection of scenarios and no stage data. Optionally, a capable optimizer_constructor can be supplied to later optimize the stochastic program. If multiple Julia processes are available, the resulting stochastic program will automatically be memory-distributed on these processes. This can be avoided by setting procs = [1].\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Union{Tuple{Scenario}, Tuple{Any, Any, Type{Scenario}, StochasticInstantiation}, Tuple{Any, Any, Type{Scenario}, StochasticInstantiation, Any}} where Scenario<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(first_stage_params::Any,\n                  second_stage_params::Any,\n                  ::Type{Scenario},\n                  instantiation::StochasticInstantiation,\n                  optimizer_constructor=nothing) where Scenario <: AbstractScenario\n\nCreate a new two-stage stochastic program with stage data given by first_stage_params and second_stage_params. After construction, scenarios of type S can be added through add_scenario!. Optionally, a capable optimizer_constructor can be supplied to later optimize the stochastic program. If multiple Julia processes are available, the resulting stochastic program will automatically be memory-distributed on these processes. This can be avoided by setting procs = [1].\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.StochasticProgram-Union{Tuple{Scenario}, Tuple{Type{Scenario}, StochasticInstantiation}, Tuple{Type{Scenario}, StochasticInstantiation, Any}} where Scenario<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.StochasticProgram","text":"StochasticProgram(::Type{Scenario},\n                  instantiation::StochasticInstantiation,\n                  optimizer_constructor=nothing) where Scenario <: AbstractScenario\n\nCreate a new two-stage stochastic program with scenarios of type Scenario and no stage data. Optionally, a capable optimizer_constructor can be supplied to later optimize the stochastic program.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#IO","page":"Public interface","title":"IO","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [SMPS]\nPages   = [\"reader.jl\"]","category":"page"},{"location":"library/public/#Base.read-Tuple{IO, Type{SMPSSampler}}","page":"Public interface","title":"Base.read","text":"read(io::IO,\n     ::Type{SMPSSampler})\n\nReturn an SMPSSampler capable of sampling SMPSScenario using the model definition read from io in SMPS format.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Base.read-Tuple{IO, Type{StochasticModel}}","page":"Public interface","title":"Base.read","text":"read(io::IO,\n     ::Type{SMPSSampler})\n\nReturn an StochasticModel from the model definition read from io in SMPS format.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Base.read-Tuple{IO, Type{StochasticProgram}}","page":"Public interface","title":"Base.read","text":"read(io::IO,\n     ::Type{StochasticProgram};\n     num_scenarios::Union{Nothing, Integer} = nothing,\n     instantiation::StochasticInstantiation = UnspecifiedInstantiation(),\n     optimizer = nothing;\n     defer::Bool = false,\n     kw...)\n\nInstantiate a two-stage stochastic program using the model definition read from io in SMPS format, of size num_scenarios. If num_scenarios = nothing, instantiate using the full support. Optionally, supply an optimizer. If no explicit instantiation is provided, the structure is induced by the optimizer. The structure is Deterministic by default.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Structures","page":"Public interface","title":"Structures","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"stochasticstructure.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.AbstractStochasticStructure","page":"Public interface","title":"StochasticPrograms.AbstractStochasticStructure","text":"AbstractStochasticStructure{N}\n\nAbstract supertype for the underlying memory structure of a stochastic program. N is the number of stages.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Deterministic","page":"Public interface","title":"StochasticPrograms.Deterministic","text":"Deterministic\n\nInstantiates with the DeterministicEquivalent structure.\n\nSee also: DeterministicEquivalent\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.DistributedHorizontal","page":"Public interface","title":"StochasticPrograms.DistributedHorizontal","text":"DistributedHorizontal\n\nInstantiates with the ScenarioDecompositionStructure on multiple cores.\n\nSee also: ScenarioDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.DistributedScenarioDecomposition","page":"Public interface","title":"StochasticPrograms.DistributedScenarioDecomposition","text":"DistributedScenarioDecomposition\n\nInstantiates with the ScenarioDecompositionStructure on multiple cores.\n\nSee also: ScenarioDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.DistributedStageDecomposition","page":"Public interface","title":"StochasticPrograms.DistributedStageDecomposition","text":"DistributedStageDecomposition\n\nInstantiates with the StageDecompositionStructure on multiple cores.\n\nSee also: StageDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.DistributedVertical","page":"Public interface","title":"StochasticPrograms.DistributedVertical","text":"DistributedVertical\n\nInstantiates with the StageDecompositionStructure on multiple cores.\n\nSee also: StageDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Horizontal","page":"Public interface","title":"StochasticPrograms.Horizontal","text":"Horizontal\n\nInstantiates with the ScenarioDecompositionStructure on a single core.\n\nSee also: ScenarioDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.ScenarioDecomposition","page":"Public interface","title":"StochasticPrograms.ScenarioDecomposition","text":"ScenarioDecomposition\n\nInstantiates with the ScenarioDecompositionStructure on a single core.\n\nSee also: ScenarioDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StageDecomposition","page":"Public interface","title":"StochasticPrograms.StageDecomposition","text":"StageDecomposition\n\nInstantiates with the StageDecompositionStructure on a single core.\n\nSee also: StageDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StochasticInstantiation","page":"Public interface","title":"StochasticPrograms.StochasticInstantiation","text":"StochasticInstantiation\n\nAbstract supertype for the underlying memory structure of a stochastic program. N is the number of stages.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.UnloadableStructure","page":"Public interface","title":"StochasticPrograms.UnloadableStructure","text":"UnloadasbleStructure{Opt <: StochasticProgramOptimizerType, S <: AbstractStochasticStructure}\n\nError thrown when an optimizer of type Opt cannot load a structure of type S.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.UnloadedStructure","page":"Public interface","title":"StochasticPrograms.UnloadedStructure","text":"UnloadedStructure{Opt <: StochasticProgramOptimizerType}\n\nError thrown when an optimizer of type Opt has not yet loaded a stochastic structure and an operation which requires a structure to be loaded is called.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.UnspecifiedInstantiation","page":"Public interface","title":"StochasticPrograms.UnspecifiedInstantiation","text":"UnspecifiedInstantiation\n\nDefault instantiation value, which defers the choice to default_structure.\n\nSee also: default_structure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.UnsupportedStructure","page":"Public interface","title":"StochasticPrograms.UnsupportedStructure","text":"UnsupportedStructure{Opt <: StochasticProgramOptimizerType, S <: AbstractStochasticStructure}\n\nError indicating that an optimizer of type Opt does not support the stochastic structure S.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Vertical","page":"Public interface","title":"StochasticPrograms.Vertical","text":"Vertical\n\nInstantiates with the StageDecompositionStructure on a single core.\n\nSee also: StageDecompositionStructure\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StochasticStructure","page":"Public interface","title":"StochasticPrograms.StochasticStructure","text":"StochasticStructure(scenario_types::ScenarioTypes{M}, instantiation::StochasticInstantiation) where M\n\nConstructs a stochastic structure over the M provided scenario types according to the specified instantiation. Should be overrided for every defined stochastic structure.\n\nStochasticStructure(scenarios::NTuple{M, Vector{<:AbstractScenario}}, instantiation::StochasticInstantiation) where M\n\nConstructs a stochastic structure over the M provided scenario sets according to the specified instantiation. Should be overrided for every defined stochastic structure.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.default_structure-Tuple{StochasticInstantiation, Any}","page":"Public interface","title":"StochasticPrograms.default_structure","text":"default_structure(instantiation::StochasticInstantiation, optimizer)\n\nReturns a StochasticInstantiation based on the provided instantiation and optimizer. If an explicit instantiation is provided it is always prioritized. Otherwise, if instantiation is UnspecifiedInstantiation, returns whatever structure requested by the optimizer. Defaults to Deterministic if no optimizer is provided.\n\n\n\n\n\n","category":"method"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"DeterministicEquivalent\nStageDecompositionStructure\nScenarioDecompositionStructure","category":"page"},{"location":"library/public/#StochasticPrograms.DeterministicEquivalent","page":"Public interface","title":"StochasticPrograms.DeterministicEquivalent","text":"DeterministicEquivalent\n\nDeterministic equivalent memory structure. Stochastic program is stored as one large optimization problem. Supported by any standard AbstractOptimizer.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.StageDecompositionStructure","page":"Public interface","title":"StochasticPrograms.StageDecompositionStructure","text":"StageDecompositionStructure\n\nVertical memory structure. Decomposes stochastic program by stages.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.ScenarioDecompositionStructure","page":"Public interface","title":"StochasticPrograms.ScenarioDecompositionStructure","text":"ScenarioDecompositionStructure\n\nHorizontal memory structure. Decomposes stochastic program by scenario.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#Decisions","page":"Public interface","title":"Decisions","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"decision_variable.jl\", \"decision_constraint.jl\", \"decision_objective.jl\", \"variable_interface.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.DecisionVariable","page":"Public interface","title":"StochasticPrograms.DecisionVariable","text":"DecisionVariable <: AbstractVariableRef\n\nIdentifier for a decision in a stochastic program. Holds a reference to the stochastic program, the stage the decision is taken in, and its corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#JuMP.BinaryRef-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.BinaryRef","text":"BinaryRef(dvar::DecisionVariable)\n\nReturn a constraint reference to the binary constraint of the decision variable dvar. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.FixRef-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.FixRef","text":"FixRef(dvar::DecisionVariable)\n\nReturn a constraint reference to the constraint fixing the value of the decision dvar. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.IntegerRef-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.IntegerRef","text":"IntegerRef(dvar::DecisionVariable)\n\nReturn a constraint reference to the integrality constraint of the decision variable dvar. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.LowerBoundRef-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.LowerBoundRef","text":"LowerBoundRef(dvar::DecisionVariable)\n\nReturn a constraint reference to the lower bound constraint of the decision variable dvar. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.UpperBoundRef-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.UpperBoundRef","text":"LowerBoundRef(dvar::DecisionVariable)\n\nReturn a constraint reference to the upper bound constraint of the decision variable dvar. Errors if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, DecisionVariable, Integer}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, dvar::DecisionVariable, scenario_index::Integer)\n\nDelete the scenario-dependent decision variable associated with dvar from the stochasticprogram at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, DecisionVariable}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, dvar::DecisionVariable)\n\nDelete the first-stage decision variable associated with dvar from the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, Vector{DecisionVariable}, Integer}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, dvars::Vector{DecisionVariable}, scenario_index::Integer)\n\nDelete the scenario-dependent decisions associated with dvars from the stochasticprogram at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, Vector{DecisionVariable}}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, dvars::Vector{DecisionVariable})\n\nDelete the decisions associated with dvars from the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete_lower_bound-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(dvar::DecisionVariable, scenario_index::Integer)\n\nDelete the lower bound constraint of the scenario-dependent decision variable dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete_lower_bound-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.delete_lower_bound","text":"delete_lower_bound(dvar::DecisionVariable)\n\nDelete the lower bound constraint of the first-stage decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete_upper_bound-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(dvar::DecisionVariable, scenario_index::Integer)\n\nDelete the upper bound constraint of the scenario-dependent decision variable dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete_upper_bound-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.delete_upper_bound","text":"delete_upper_bound(dvar::DecisionVariable)\n\nDelete the upper bound constraint of the first-stage decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.fix-Tuple{DecisionVariable, Integer, Number}","page":"Public interface","title":"JuMP.fix","text":"fix(dvar::DecisionVariable, scenario_index::Integer, val::Number)\n\nFix the scenario-dependent decision associated with dvar at scenario_index to val. In contexts where dvar is a variable, the variable is fixed to the value. In contexts where dvar is a known parameter value, the value is updated.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.fix-Tuple{DecisionVariable, Number}","page":"Public interface","title":"JuMP.fix","text":"fix(dvar::DecisionVariable, val::Number)\n\nFix the first-stage decision associated with dvar to val. In contexts where dvar is a variable, the variable is fixed to the value. In contexts where dvar is a known parameter value, the value is updated.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_lower_bound-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.has_lower_bound","text":"has_lower_bound(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn true if the scenario-dependent decision variable dvar has a lower bound at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_lower_bound-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.has_lower_bound","text":"has_lower_bound(dvar::DecisionVariable)\n\nReturn true if the first-stage decision variable dvar has a lower bound.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_upper_bound-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.has_upper_bound","text":"has_upper_bound(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn true if the scenario-dependent decision variable dvar has a upper bound at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_upper_bound-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.has_upper_bound","text":"has_upper_bound(dvar::DecisionVariable)\n\nReturn true if the first-stage decision variable dvar has a upper bound.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_values-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.has_values","text":"has_values(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer; result::Int = 1)\n\nReturn true if the solver has a primal solution in the node at stage stage and scenario scenario_index in result index result available to query, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_values-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.has_values","text":"has_values(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer; result::Int = 1)\n\nReturn true if the solver has a primal solution in scenario scenario_index in result index result available to query, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_values-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.has_values","text":"has_duals(stochasticprogram::StochasticProgram; result::Int = 1)\n\nReturn true if the solver has a primal solution in the first-stage of stochasticprogram in result index result available to query, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.index-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.index","text":"index(dvar::DecisionVariable)::MOI.VariableIndex\n\nReturn the index of the decision variable that corresponds to dvar in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_binary-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.is_binary","text":"is_binary(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn true if the scenario-dependent decision variable dvar is constrained to be binary at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_binary-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.is_binary","text":"is_binary(dvar::DecisionVariable)\n\nReturn true if the first-stage decision variable dvar is constrained to be binary.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_fixed-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.is_fixed","text":"is_fixed(dvar::DecisionVariable, scenario_index)\n\nReturn true if dvar is a fixed decision variable in scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_fixed-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.is_fixed","text":"is_fixed(dvar::DecisionVariable)\n\nReturn true if dvar is a fixed first-stage decision variable.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_integer-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.is_integer","text":"is_integer(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn true if the scenario-dependent decision variable dvar is constrained to be integer at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_integer-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.is_integer","text":"is_integer(dvar::DecisionVariable)\n\nReturn true if the first-stage decision variable dvar is constrained to be integer.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_valid-Tuple{StochasticProgram, DecisionVariable, Integer}","page":"Public interface","title":"JuMP.is_valid","text":"is_valid(stochasticprogram::StochasticProgram, dvar::DecisionVariable, scenario_index::Integer)\n\nReturn true if the scenario-dependent dvar refers to a valid decision variable in stochasticprogram at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_valid-Tuple{StochasticProgram, DecisionVariable}","page":"Public interface","title":"JuMP.is_valid","text":"is_valid(stochasticprogram::StochasticProgram, dvar::DecisionVariable)\n\nReturn true if dvar refers to a valid first-stage decision variable in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.lower_bound-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.lower_bound","text":"lower_bound(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn the lower bound of the scenario-dependent decision variable dvar at scenario_index. Error if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.lower_bound-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.lower_bound","text":"lower_bound(dvar::DecisionVariable)\n\nReturn the lower bound of the first-stage decision variable dvar. Error if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.name-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.name","text":"name(dvar::DecisionVariable, scenario_index::Integer)::String\n\nGet the name of the scenario-dependent decision variable dvar in scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.name-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.name","text":"name(dvar::DecisionVariable, scenario_index::Integer)::String\n\nGet the name of the decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.optimizer_index-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.optimizer_index","text":"optimizer_index(dvar::DecisionVariable, scenario_index)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to the scenario-dependent dvar in the optimizer model at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.optimizer_index-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.optimizer_index","text":"optimizer_index(dvar::DecisionVariable)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to dvar in the optimizer model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.reduced_cost-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.reduced_cost","text":"reduced_cost(dvar::DecisionVariable)::Float64\n\nReturn the reduced cost associated with the scenario-dependent decision variable dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.reduced_cost-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.reduced_cost","text":"reduced_cost(dvar::DecisionVariable)::Float64\n\nReturn the reduced cost associated with the decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.relax_integrality-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.relax_integrality","text":"relax_integrality(stochasticprogram::StochasticProgram)\n\nModifies stochasticprogram to \"relax\" all binary and integrality constraints on decisions and auxiliary variables.\n\nReturns a function that can be called without any arguments to restore the original stochasticprogram. The behavior of this function is undefined if additional changes are made to the affected decisions and variables in the meantime.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_binary-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.set_binary","text":"set_binary(dvar::DecisionVariable, scenario_index::Integer)\n\nConstrain the scenario-dependent decision variable dvar to the set 01 at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_binary-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.set_binary","text":"set_binary(dvar::DecisionVariable)\n\nConstrain the first-stage decision variable dvar to the set 01.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_integer-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.set_integer","text":"set_integer(dvar::DecisionVariable, scenario_index::Integer)\n\nAdd an integrality constraint on the scenario-dependent decision variable dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_integer-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.set_integer","text":"set_integer(dvar::DecisionVariable)\n\nAdd an integrality constraint on the first-stage decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_lower_bound-Tuple{DecisionVariable, Integer, Number}","page":"Public interface","title":"JuMP.set_lower_bound","text":"set_lower_bound(dvar::DecisionVariable, scenario_index::Integer, lower::Number)\n\nSet the lower bound of the scenario-dependent decision variable dvar at scenario_index to lower. If one does not exist, create a new lower bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_lower_bound-Tuple{DecisionVariable, Number}","page":"Public interface","title":"JuMP.set_lower_bound","text":"set_lower_bound(dvar::DecisionVariable)\n\nSet the lower bound of the first-stage decision variable dvar to lower. If one does not exist, create a new lower bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_name-Tuple{DecisionVariable, Integer, String}","page":"Public interface","title":"JuMP.set_name","text":"set_name(dvar::DecisionVariable, scenario_index::Integer, name::String)\n\nSet the name of the scenario-dependent decision variable dvar in scenario scenario_index to name.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_name-Tuple{DecisionVariable, String}","page":"Public interface","title":"JuMP.set_name","text":"set_name(dvar::DecisionVariable, scenario_index::Integer, name::String)\n\nSet the name of the decision variable dvar to name.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_start_value-Tuple{DecisionVariable, Integer, Number}","page":"Public interface","title":"JuMP.set_start_value","text":"set_start_value(dvar::DecisionVariable, scenario_index::Integer, value::Number)\n\nSet the start value of the scenario-dependent decision variable dvar at scenario_index to value.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_start_value-Tuple{DecisionVariable, Number}","page":"Public interface","title":"JuMP.set_start_value","text":"set_start_value(dvar::DecisionVariable)\n\nSet the start value of the first-stage decision variable dvar to value.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_upper_bound-Tuple{DecisionVariable, Integer, Number}","page":"Public interface","title":"JuMP.set_upper_bound","text":"set_upper_bound(dvar::DecisionVariable, scenario_index::Integer, upper::Number)\n\nSet the upper bound of the scenario-dependent decision variable dvar at scenario_index to upper. If one does not exist, create a new upper bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_upper_bound-Tuple{DecisionVariable, Number}","page":"Public interface","title":"JuMP.set_upper_bound","text":"set_upper_bound(dvar::DecisionVariable, upper::Number)\n\nSet the upper bound of the first-stage decision variable dvar to upper. If one does not exist, create a new upper bound constraint.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.start_value-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.start_value","text":"start_value(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn the start value of the scenario-dependent decision variable dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.start_value-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.start_value","text":"start_value(dvar::DecisionVariable)\n\nReturn the start value of the first-stage decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.unfix-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.unfix","text":"unfix(dvar::DecisionVariable, scenario_index::Integer)\n\nUnfix the scenario-dependent decision associated with dvar at scenario_index. If the decision is already in a NotTaken state, this does nothing.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.unfix-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.unfix","text":"unfix(dvar::DecisionVariable)\n\nUnfix the first-stage decision associated with dvar. If the decision is already in a NotTaken state, this does nothing.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.unset_binary-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.unset_binary","text":"unset_binary(dvar::DecisionVariable, scenario_index::Integer)\n\nDelete the binary constraint of the scenario-dependent decision variable dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.unset_binary-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.unset_binary","text":"unset_binary(dvar::DecisionVariable)\n\nDelete the binary constraint of the first-stage decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.unset_integer-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.unset_integer","text":"unset_integer(dvar::DecisionVariable, scenario_index::Integer)\n\nDelete the integrality constraint of the scenario-dependent decision variable dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.unset_integer-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.unset_integer","text":"unset_integer(dvar::DecisionVariable)\n\nDelete the integrality constraint of the first-stage decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.upper_bound-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.upper_bound","text":"upper_bound(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn the upper bound of the scenario-dependent decision variable dvar at scenario_index. Error if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.upper_bound-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.upper_bound","text":"upper_bound(dvar::DecisionVariable)\n\nReturn the upper bound of the first-stage decision variable dvar. Error if one does not exist.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.value-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"JuMP.value","text":"value(dvar::DecisionVariable, scenario_index::Integer; result = 1)\n\nReturn the scenario-dependent value of the decision variable dvar associated with result index result at scenario_index of the most-recent returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.value-Tuple{DecisionVariable}","page":"Public interface","title":"JuMP.value","text":"value(dvar::DecisionVariable; result = 1)\n\nReturn the value of the first-stage decision variable dvar associated with result index result of the most-recent returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.value-Union{Tuple{T}, Tuple{Union{GenericAffExpr{T, DecisionVariable}, GenericQuadExpr{T, DecisionVariable}}, Dict{Int64, Int64}}} where T","page":"Public interface","title":"JuMP.value","text":"value(dvar_expr::Union{GenericAffExpr{T,DecisionVariable}, GenericQuadExpr{T,DecisionVariable}}, stage_to_scenario::Dict{Int,Int}) where T\n\nEvaluate dvar_expr where the value of a given dvar is found in the scenario returned by the provided stage_to_scenario map.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"StochasticPrograms.decision","text":"decision(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn the scenario-dependent internal Decision associated with dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision-Tuple{DecisionVariable}","page":"Public interface","title":"StochasticPrograms.decision","text":"decision(dvar::DecisionVariable)\n\nReturn the internal Decision associated with the first-stage dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision_by_name-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, String}} where N","page":"Public interface","title":"StochasticPrograms.decision_by_name","text":"decision_by_name(stochasticprogram::Stochasticprogram,\n                 stage::Integer,\n                 name::String)::Union{AbstractVariableRef, Nothing}\n\nReturns the reference of the variable with name attribute name at stage of stochasticprogram or Nothing if no variable has this name attribute. Throws an error if several variables have name as their name attribute at stage s.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage-Tuple{DecisionVariable}","page":"Public interface","title":"StochasticPrograms.stage","text":"stage(dvar::DecisionVariable)\n\nReturn the stage of dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.state-Tuple{DecisionVariable, Integer}","page":"Public interface","title":"StochasticPrograms.state","text":"state(dvar::DecisionVariable, scenario_index::Integer)\n\nReturn the scenario-dependent DecisionState of dvar at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.state-Tuple{DecisionVariable}","page":"Public interface","title":"StochasticPrograms.state","text":"state(dvar::DecisionVariable)\n\nReturn the DecisionState of the first-stage dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.SPConstraintRef","page":"Public interface","title":"StochasticPrograms.SPConstraintRef","text":"SPConstraintRef\n\nHolds a reference to the stochastic program, the stage the constraint resides in, and the corresponding MOI.ConstraintIndex.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#JuMP.all_constraints-Union{Tuple{V}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, Type{var\"#s62\"} where var\"#s62\"<:Union{Vector{var\"#s43\"} where var\"#s43\"<:V, V}, Type{var\"#s42\"} where var\"#s42\"<:MathOptInterface.AbstractSet}} where {N, V<:AbstractJuMPScalar}","page":"Public interface","title":"JuMP.all_constraints","text":"all_constraints(stochasticprogram::StochasticProgram, stage::Integer, function_type, set_type)::Vector{<:SPConstraintRef}\n\nReturn a list of all decision constraints currently in the stochasticprogram at stage where the function has type function_type and the set has type set_type. The constraints are ordered by creation time. This errors if regular constraints are queried. If so, either annotate the relevant variables with @decision or first query the relevant JuMP subproblem and use the regular all_constraints function.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.constraint_by_name-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, String}} where N","page":"Public interface","title":"JuMP.constraint_by_name","text":"constraint_by_name(stochasticprogram::StochasticProgram,\n                   stage::Integer,\n                   name::String)::Union{SPConstraintRef, Nothing}\n\nReturns the reference of the constraint with name attribute name at stage of stochasticprogram or Nothing if no constraint has this name attribute. Throws an error if several constraints have name as their name attribute.\n\nconstraint_by_name(stochasticprogram::StochasticProgram,\n                   stage::Integer,\n                   name::String,\n                   F::Type{<:Union{AbstractJuMPScalar,\n                                   Vector{<:AbstractJuMPScalar},\n                                   MOI.AbstactFunction}},\n                   S::Type{<:MOI.AbstractSet})::Union{SPConstraintRef, Nothing}\n\nSimilar to the method above, except that it throws an error if the constraint is not an F-in-S contraint where F is either the JuMP or MOI type of the function, and S is the MOI type of the set.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.constraint_object-Union{Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape}, Tuple{S}, Tuple{F}} where {F<:(Union{SingleDecision, AffineDecisionFunction{T}, QuadraticDecisionFunction{T}} where T), S<:MathOptInterface.AbstractScalarSet}","page":"Public interface","title":"JuMP.constraint_object","text":"constraint_object(sp_cref::SPConstraintRef)\n\nReturn the underlying constraint data for the first-stage decision constraint referenced by sp_cref.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.constraint_object-Union{Tuple{S}, Tuple{F}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, Integer}} where {F<:(Union{SingleDecision, AffineDecisionFunction{T}, QuadraticDecisionFunction{T}} where T), S<:MathOptInterface.AbstractScalarSet}","page":"Public interface","title":"JuMP.constraint_object","text":"constraint_object(sp_cref::SPConstraintRef, scenario_index)\n\nReturn the underlying constraint data for the scenario-dependent decision constraint referenced by sp_cref in scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, SPConstraintRef, Integer}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, sp_cref::SPConstraintRef, scenario_index::Integer)\n\nDelete the scenario-dependent decision constraint associated with sp_cref from the stochasticprogram in scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, SPConstraintRef}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, sp_cref::SPConstraintRef)\n\nDelete the first-stage decision constraint associated with sp_cref from the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, Vector{var\"#s145\"} where var\"#s145\"<:SPConstraintRef, Integer}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, sp_crefs::Vector{<:SPConstraintRef}, scenario_index::Integer)\n\nDelete the scenario-dependent decision constraints associated with sp_crefs from the stochasticprogram at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.delete-Tuple{StochasticProgram, Vector{var\"#s145\"} where var\"#s145\"<:SPConstraintRef}","page":"Public interface","title":"JuMP.delete","text":"delete(stochasticprogram::StochasticProgram, sp_crefs::Vector{<:SPConstraintRef})\n\nDelete the first-stage decision constraints associated with sp_crefs from the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual-Tuple{SPConstraintRef, Integer}","page":"Public interface","title":"JuMP.dual","text":"dual(sp_cref::SPConstraintRef, scenario_index::Integer; result::Int = 1)\n\nReturn the dual value of the scenario-dependent decision constraint sp_cref in scenario scenario_index associated with result index result of the most-recent solution returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual-Tuple{SPConstraintRef}","page":"Public interface","title":"JuMP.dual","text":"dual(sp_cref::SPConstraintRef; result::Int = 1)\n\nReturn the dual value of the first-stage decision constraint sp_cref associated with result index result of the most-recent solution returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_duals-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.has_duals","text":"has_duals(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer; result::Int = 1)\n\nReturn true if the solver has a dual solution in the node at stage stage and scenario scenario_index in result index result available to query, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_duals-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.has_duals","text":"has_duals(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer; result::Int = 1)\n\nReturn true if the solver has a dual solution in scenario scenario_index in result index result available to query, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.has_duals-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.has_duals","text":"has_duals(stochasticprogram::StochasticProgram; result::Int = 1)\n\nReturn true if the solver has a dual solution in the first-stage of stochasticprogram in result index result available to query, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.index-Tuple{SPConstraintRef}","page":"Public interface","title":"JuMP.index","text":"index(sp_cref::SPConstraintNotOwned)::MOI.ConstraintIndex\n\nReturn the index of the decision constraint that corresponds to sp_cref in the MOI backend.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_valid-Tuple{StochasticProgram, SPConstraintRef, Integer}","page":"Public interface","title":"JuMP.is_valid","text":"is_valid(stochasticprogram::StochasticProgram, sp_cref::SPConstraintRef, scenario_index::Integer)\n\nReturn true if the scenario-dependent sp_cref refers to a valid decision constraint in stochasticprogram at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.is_valid-Tuple{StochasticProgram, SPConstraintRef}","page":"Public interface","title":"JuMP.is_valid","text":"is_valid(stochasticprogram::StochasticProgram, sp_cref::SPConstraintRef)\n\nReturn true if sp_cref refers to a valid first-stage decision constraint in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.list_of_constraint_types-Tuple{StochasticProgram, Integer}","page":"Public interface","title":"JuMP.list_of_constraint_types","text":"list_of_constraint_types(stochasticprogram::Stochasticprogram, stage::Integer)::Vector{Tuple{Type, Type}}\n\nReturn a list of tuples of the form (F, S) where F is a JuMP function type and S is an MOI set type such that all_constraints(stochasticprogram, stage, F, S) returns a nonempty list.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.name-Tuple{SPConstraintRef, Integer}","page":"Public interface","title":"JuMP.name","text":"name(sp_cref::SPConstraintRef, scenario_index::Integer)::String\n\nGet the name of the scenario-dependent decision constraint sp_cref in scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.name-Tuple{SPConstraintRef}","page":"Public interface","title":"JuMP.name","text":"name(sp_cref::SPConstraintRef)::String\n\nGet the name of the decision constraint sp_cref.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.normalized_coefficient-Union{Tuple{S}, Tuple{F}, Tuple{T}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, DecisionVariable, Integer}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S}","page":"Public interface","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(sp_cref::SPConstraintRef, dvar::DecisionVariable, scenario_index::Integer)\n\nReturn the coefficient associated with dvar in the decision constraint sp_cref in scenario scenario_index after JuMP has normalized the constraint into its standard form.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.normalized_coefficient-Union{Tuple{S}, Tuple{F}, Tuple{T}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, DecisionVariable}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S}","page":"Public interface","title":"JuMP.normalized_coefficient","text":"normalized_coefficient(sp_cref::SPConstraintRef, dvar::DecisionVariable)\n\nReturn the coefficient associated with dvar in the first-stage decision constraint sp_cref after JuMP has normalized the constraint into its standard form.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.normalized_rhs-Union{Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape}, Tuple{S}, Tuple{F}, Tuple{T}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S<:Union{MathOptInterface.EqualTo{T}, MathOptInterface.GreaterThan{T}, MathOptInterface.LessThan{T}}}","page":"Public interface","title":"JuMP.normalized_rhs","text":"normalized_rhs(sp_cref::SPConstraintRef)\n\nReturn the right-hand side term of the first-stage decision constraint sp_cref after JuMP has converted the constraint into its normalized form.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.normalized_rhs-Union{Tuple{S}, Tuple{F}, Tuple{T}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, Integer}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S<:Union{MathOptInterface.EqualTo{T}, MathOptInterface.GreaterThan{T}, MathOptInterface.LessThan{T}}}","page":"Public interface","title":"JuMP.normalized_rhs","text":"normalized_rhs(sp_cref::SPConstraintRef, scenario_index::Integer)\n\nReturn the right-hand side term of the scenario-dependent decision constraint sp_cref at scenario_index after JuMP has converted the constraint into its normalized form.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.num_constraints-Union{Tuple{V}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, Type{var\"#s76\"} where var\"#s76\"<:Union{Vector{var\"#s62\"} where var\"#s62\"<:V, V}, Type{var\"#s43\"} where var\"#s43\"<:MathOptInterface.AbstractSet}} where {N, V<:AbstractJuMPScalar}","page":"Public interface","title":"JuMP.num_constraints","text":"num_constraints(stochasticprogram::StochasticProgram{N}, stage::Integer, function_type, set_type)::Int64\n\nReturn the number of decision constraints currently in the stochasticprogram at stage where the function has type function_type and the set has type set_type. This errors if regular constraints are queried. If so, either annotate the relevant variables with @decision or first query the relevant JuMP subproblem and use the regular all_constraints function.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.optimizer_index-Tuple{SPConstraintRef, Integer}","page":"Public interface","title":"JuMP.optimizer_index","text":"optimizer_index(sp_cref::SPConstraintRef, scenario_index)::MOI.VariableIndex\n\nReturn the index of the constraint that corresponds to the scenario-dependent sp_cref in the optimizer model at scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.optimizer_index-Tuple{SPConstraintRef}","page":"Public interface","title":"JuMP.optimizer_index","text":"optimizer_index(sp_cref::SPConstraintRef)::MOI.VariableIndex\n\nReturn the index of the variable that corresponds to dvar in the optimizer model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_name-Tuple{SPConstraintRef, Integer, String}","page":"Public interface","title":"JuMP.set_name","text":"set_name(sp_cref::SPConstraintRef, scenario_index::Integer, name::String)\n\nSet the name of the scenario-dependent decision constraint sp_cref in scenario scenario_index to name.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_name-Tuple{SPConstraintRef, String}","page":"Public interface","title":"JuMP.set_name","text":"set_name(sp_cref::SPConstraintRef, name::String)\n\nSet the name of the decision constraint sp_cref to name.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_normalized_coefficient-Union{Tuple{S}, Tuple{F}, Tuple{T}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, DecisionVariable, Any}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S}","page":"Public interface","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(sp_cref::SPConstraintRef, dvar::DecisionVariable, value)\n\nSet the coefficient of dvar in the first-stage decision constraint sp_cref to value.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_normalized_coefficient-Union{Tuple{S}, Tuple{F}, Tuple{T}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, DecisionVariable, Integer, Any}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S}","page":"Public interface","title":"JuMP.set_normalized_coefficient","text":"set_normalized_coefficient(sp_cref::SPConstraintRef, dvar::DecisionVariable, scenario_index::Integer, value)\n\nSet the coefficient of dvar in the decision constraint sp_cref in scenario scenario_index to value.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_normalized_rhs-Union{Tuple{S}, Tuple{F}, Tuple{T}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, Any}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S<:Union{MathOptInterface.EqualTo{T}, MathOptInterface.GreaterThan{T}, MathOptInterface.LessThan{T}}}","page":"Public interface","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(sp_cref::SPConstraintRef, value)\n\nSet the right-hand side term of the first-stage decision constraint sp_cref to value.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_normalized_rhs-Union{Tuple{S}, Tuple{F}, Tuple{T}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, Integer, Any}} where {T, F<:Union{AffineDecisionFunction{T}, QuadraticDecisionFunction{T}}, S<:Union{MathOptInterface.EqualTo{T}, MathOptInterface.GreaterThan{T}, MathOptInterface.LessThan{T}}}","page":"Public interface","title":"JuMP.set_normalized_rhs","text":"set_normalized_rhs(sp_cref::SPConstraintRef, scenario_index::Integer, value)\n\nSet the right-hand side term of the decision constraint sp_cref at scenario_index to value.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.shadow_price-Union{Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape}, Tuple{S}, Tuple{F}} where {F, S<:MathOptInterface.LessThan}","page":"Public interface","title":"JuMP.shadow_price","text":"shadow_price(sp_cref::SPConstraintRef)\n\nReturn the shadow price of the first-stage decision constraint sp_cref associated with result index result of the most-recent solution returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.shadow_price-Union{Tuple{S}, Tuple{F}, Tuple{SPConstraintRef{MathOptInterface.ConstraintIndex{F, S}, Shape} where Shape<:AbstractShape, Integer}} where {F, S<:MathOptInterface.LessThan}","page":"Public interface","title":"JuMP.shadow_price","text":"shadow_price(sp_cref::SPConstraintRef, scenario_index::Integer)\n\nReturn the shadow price of the scenario-dependent decision constraint sp_cref in scenario scenario_index associated with result index result of the most-recent solution returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.value-Tuple{SPConstraintRef, Function}","page":"Public interface","title":"JuMP.value","text":"value(sp_cref::SPConstraintRef, dvar_value::Function)\n\nEvaluate the primal value of the first-stage decision constraint sp_cref using dvar_value(dvar) as the value for each decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.value-Tuple{SPConstraintRef, Integer, Function}","page":"Public interface","title":"JuMP.value","text":"value(sp_cref::SPConstraintRef, dvar_value::Function)\n\nEvaluate the primal value of the scenario-dependent decision constraint sp_cref in scenario scenario_index using dvar_value(dvar) as the value for each decision variable dvar.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.value-Tuple{SPConstraintRef, Integer}","page":"Public interface","title":"JuMP.value","text":"value(sp_cref::SPConstraintRef, scenario_index::Integer; result::Int = 1)\n\nReturn the primal value of the scenario-dependent decision constraint sp_cref at scenario_index associated with result index result of the most-recent solution returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.value-Tuple{SPConstraintRef}","page":"Public interface","title":"JuMP.value","text":"value(sp_cref::SPConstraintRef; result::Int = 1)\n\nReturn the primal value of the first-stage decision constraint sp_cref associated with result index result of the most-recent solution returned by the solver.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage-Tuple{SPConstraintRef}","page":"Public interface","title":"StochasticPrograms.stage","text":"stage(sp_cref::SPConstraintRef)\n\nReturn the stage of sp_cref.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual_objective_value-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.dual_objective_value","text":"dual_objective_value(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer; result::Int = 1)\n\nReturn the objective value of the dual problem of the node at stage stage and scenario scenario_index associated with result index result of the most-recent solution after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual_objective_value-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.dual_objective_value","text":"dual_objective_value(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer; result::Int = 1)\n\nReturn the objective value of the dual problem of scenario scenario_index associated with result index result of the most-recent solution after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual_objective_value-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.dual_objective_value","text":"dual_objective_value(stochasticprogram::StochasticProgram; result::Int = 1)\n\nReturn the objective value of the dual problem associated with result index result of the most-recent solution after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_bound-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.objective_bound","text":"objective_bound(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the best known bound on the optimal objective value in the node at stage stage and scenario scenario_index after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_bound-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.objective_bound","text":"objective_bound(stochasticprogram::StochasticProgram)\n\nReturn the best known bound on the optimal objective value after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_function","page":"Public interface","title":"JuMP.objective_function","text":"objective_function(stochasticprogram::StochasticProgram,\n                   stage::Integer,\n                   scenario_index::Integer,\n                   T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function in the node at stage stage and scenario scenario_index. Error if the objective is not convertible to type T.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JuMP.objective_function-2","page":"Public interface","title":"JuMP.objective_function","text":"objective_function(stochasticprogram::StochasticProgram,\n                   T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the full objective function of the stochasticprogram. Error if the objective is not convertible to type T.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#JuMP.objective_function-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, Type{var\"#s145\"} where var\"#s145\"<:AbstractJuMPScalar}} where N","page":"Public interface","title":"JuMP.objective_function","text":"objective_function(stochasticprogram::StochasticProgram,\n                   stage::Integer,\n                   T::Type{<:AbstractJuMPScalar}=objective_function_type(model))\n\nReturn an object of type T representing the objective function at stage stage of the stochasticprogram. Error if the objective is not convertible to type T.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_function_type-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.objective_function_type","text":"objective_function_type(stochasticprogram::Stochasticprogram, stage::Integer, scenario_index::Integer)::AbstractJuMPScalar\n\nReturn the type of the objective function in the node at stage stage and scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_function_type-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.objective_function_type","text":"objective_function_type(stochasticprogram::Stochasticprogram)::AbstractJuMPScalar\n\nReturn the type of the objective function of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_function_type-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"JuMP.objective_function_type","text":"objective_function_type(stochasticprogram::Stochasticprogram, stage::Integer)::AbstractJuMPScalar\n\nReturn the type of the objective function at stage stage of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_sense-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.objective_sense","text":"objective_sense(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)::MathOptInterface.OptimizationSense\n\nReturn the objective sense in the node at stage stage and scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_sense-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.objective_sense","text":"objective_sense(stochasticprogram::StochasticProgram)::MathOptInterface.OptimizationSense\n\nReturn the objective sense of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_sense-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"JuMP.objective_sense","text":"objective_sense(stochasticprogram::StochasticProgram, stage::Integer)::MathOptInterface.OptimizationSense\n\nReturn the objective sense of the stochasticprogram stage stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_value-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.objective_value","text":"objective_value(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer; result::Int = 1)\n\nReturn the objective value of the node at stage stage and scenario scenario_index associated with result index result of the most-recent solution after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_value-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.objective_value","text":"objective_value(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer; result::Int = 1)\n\nReturn the objective value of scenario scenario_index associated with result index result of the most-recent solution after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_value-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.objective_value","text":"objective_value(stochasticprogram::StochasticProgram; result::Int = 1)\n\nReturn the objective value associated with result index result of the most-recent solution after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.relative_gap-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.relative_gap","text":"relative_gap(model::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the final relative optimality gap in the node at stage stage and scenario scenario_index after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.relative_gap-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.relative_gap","text":"relative_gap(model::StochasticProgram)\n\nReturn the final relative optimality gap after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_objective_coefficient-Tuple{StochasticProgram, DecisionVariable, Integer, Integer, Real}","page":"Public interface","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(stochasticprogram::StochasticProgram, dvar::DecisionVariable, stage::Integer, scenario_index::Integer, coefficient::Real)\n\nSet the scenario-dependent linear objective coefficient at scenario_index associated with dvar to coefficient in stage stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_objective_coefficient-Tuple{StochasticProgram, DecisionVariable, Integer, Real}","page":"Public interface","title":"JuMP.set_objective_coefficient","text":"set_objective_coefficient(stochasticprogram::StochasticProgram, dvar::DecisionVariable, stage::Integer, coefficient::Real)\n\nSet the linear objective coefficient associated with dvar to coefficient in stage stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_objective_sense-Tuple{StochasticProgram, Integer, Integer, MathOptInterface.OptimizationSense}","page":"Public interface","title":"JuMP.set_objective_sense","text":"set_objective_sense(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the stochasticprogram node at stage stage and scenario scenario_index to the given sense.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_objective_sense-Tuple{StochasticProgram, MathOptInterface.OptimizationSense}","page":"Public interface","title":"JuMP.set_objective_sense","text":"set_objective_sense(stochasticprogram::StochasticProgram, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the stochasticprogram to sense.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_objective_sense-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, MathOptInterface.OptimizationSense}} where N","page":"Public interface","title":"JuMP.set_objective_sense","text":"set_objective_sense(stochasticprogram::StochasticProgram, stage::Integer, sense::MathOptInterface.OptimizationSense)\n\nSets the objective sense of the stochasticprogram at stage stage to sense.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.DecisionRef","page":"Public interface","title":"StochasticPrograms.DecisionRef","text":"DecisionRef <: AbstractVariableRef\n\nHolds a reference to the model, the stage the decision is taken in, and the corresponding MOI.VariableIndex.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#JuMP.fix-Tuple{DecisionRef, Number}","page":"Public interface","title":"JuMP.fix","text":"fix(dref::DecisionRef, val::Number)\n\nFix the decision associated with dref to val.\n\nSee also unfix.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.all_auxiliary_variables-Tuple{Model}","page":"Public interface","title":"StochasticPrograms.all_auxiliary_variables","text":"all_auxiliary_variables(model::JuMP.Model)\n\nReturns a list of all auxiliary variables currently in the decision model through @variable. The variables are ordered by creation time.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.all_decision_variables-Tuple{Model, Integer}","page":"Public interface","title":"StochasticPrograms.all_decision_variables","text":"all_decision_variables(model::JuMP.Model, stage::Integer)\n\nReturns a list of all decisions currently in the model at stage stage. The decisions are ordered by creation time.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.all_decision_variables-Tuple{Model}","page":"Public interface","title":"StochasticPrograms.all_decision_variables","text":"all_decision_variables(model::JuMP.Model)\n\nReturns a stage-wise list of all decisions currently in the model. The decisions are ordered by creation time.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.all_known_decision_variables-Tuple{Model, Integer}","page":"Public interface","title":"StochasticPrograms.all_known_decision_variables","text":"all_known_decision_variables(model::JuMP.Model, stage::Integer)\n\nReturns a stage-wise list of all known decisions currently in the model at stage stage. The decisions are ordered by creation time.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.all_known_decision_variables-Tuple{Model}","page":"Public interface","title":"StochasticPrograms.all_known_decision_variables","text":"all_known_decision_variables(model::JuMP.Model)\n\nReturns a stage-wise list of all known decisions currently in the model. The decisions are ordered by creation time.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision-Tuple{DecisionRef}","page":"Public interface","title":"StochasticPrograms.decision","text":"decision(dref::DecisionRef)\n\nReturn the internal Decision associated with dref.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.num_decisions","page":"Public interface","title":"StochasticPrograms.num_decisions","text":"num_decisions(model::JuMP.Model, stage::Integer = 1)\n\nReturn the number of decisions in model at stage stage. Defaults to the first stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.num_known_decisions","page":"Public interface","title":"StochasticPrograms.num_known_decisions","text":"num_known_decisions(model::JuMP.Model, stage::Integer = 2)\n\nReturn the number of known decisions in model at stage stage. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.state-Tuple{DecisionRef}","page":"Public interface","title":"StochasticPrograms.state","text":"state(dref::DecisionRef)\n\nReturn the DecisionState of dref.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Scenarios","page":"Public interface","title":"Scenarios","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"scenario.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.AbstractScenario","page":"Public interface","title":"StochasticPrograms.AbstractScenario","text":"AbstractScenario\n\nAbstract supertype for scenario objects.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.ExpectedScenario","page":"Public interface","title":"StochasticPrograms.ExpectedScenario","text":"ExpectedScenario{S <: AbstractScenario}\n\nWrapper type around an AbstractScenario. Should for convenience be used as the result of a call to expected.\n\nSee also expected\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Probability","page":"Public interface","title":"StochasticPrograms.Probability","text":"Probability\n\nA type-safe wrapper for Float64 used to represent probability of a scenario occuring.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Scenario","page":"Public interface","title":"StochasticPrograms.Scenario","text":"Scenario\n\nConveniece type that adheres to the AbstractScenario abstraction. Useful when uncertain parameters are defined using @uncertain and instances are created using @scenario.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.expected-Union{Tuple{Vector{S}}, Tuple{S}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.expected","text":"expected(scenarios::Vector{<:AbstractScenario})\n\nReturn the expected scenario out of the collection scenarios in an ExpectedScenario wrapper.\n\nThis is defined through classical expectation: sum([probability(s)*s for s in scenarios]), and is always defined for scenarios created through @scenario, if the requested fields support it.\n\nOtherwise, user-defined scenario types must implement this method for full functionality.\n\nSee also ExpectedScenario\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.probability-Tuple{AbstractScenario}","page":"Public interface","title":"StochasticPrograms.probability","text":"probability(scenario::AbstractScenario)\n\nReturn the probability of scenario occuring.\n\nIs always defined for scenarios created through @scenario. Other user defined scenario types must implement this method to generate a proper probability. The default behaviour is to assume that scenario has a probability field of type Probability\n\nSee also: Probability\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.probability-Tuple{Vector{var\"#s37\"} where var\"#s37\"<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.probability","text":"probability(scenarios::Vector{<:AbstractScenario})\n\nReturn the probability of that any scenario in the collection scenarios occurs.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenariotext-Tuple{IO, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.scenariotext","text":"scenariotext(io::IO, scenario::AbstractScenario)\n\nCustom printout called when printing scenario.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.set_probability!-Tuple{AbstractScenario, AbstractFloat}","page":"Public interface","title":"StochasticPrograms.set_probability!","text":"set_probability!(scenario::AbstractScenario, probability::AbstractFloat)\n\nSet the probability of scenario occuring.\n\nIs always defined for scenarios created through @scenario. Other user defined scenario types must implement this method.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.@define_scenario-Tuple{Any}","page":"Public interface","title":"StochasticPrograms.@define_scenario","text":"@define_scenario(def)\n\nDefine a scenario type compatible with StochasticPrograms using the syntax\n\n@define_scenario name = begin\n    ...structdef...\n\n    [@zero begin\n        ...\n        return zero(scenario)\n    end]\n\n    [@expectation begin\n        ...\n        return expected(scenarios)\n     end]\nend\n\nThe generated type is referenced through name and a default constructor is always generated. This constructor accepts the keyword probability to set the probability of the scenario occuring. Otherwise, any internal variables and specialized constructors are defined in the @define_scenario block as they would be in any Julia struct.\n\nIf possible, a zero method and an expected method will be generated for the defined type. Otherwise, or if the default implementation is not desired, these can be user provided through @zero and @expectation.\n\nThe defined scenario type will be available on all Julia processes.\n\nExamples\n\nThe following defines a simple scenario ξ with a single value.\n\n@define_scenario ExampleScenario = begin\n    ξ::Float64\nend\n\nExampleScenario(1.0, probability = 0.5)\n\n# output\n\nExampleScenario with probability 0.5\n  ξ: 1.0\n\n\nSee also: @zero, @expectation, @sampler\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@expectation-Tuple{Any}","page":"Public interface","title":"StochasticPrograms.@expectation","text":"@expectation(def)\n\nDefine how to form the expected scenario inside a @define_scenario block. The scenario collection is accessed through the reserved keyword scenarios.\n\n@zero begin\n    ...\n    return zero_scenario\nend\n\nExamples\n\nThe following defines expectation for the example scenario defined in @scenario\n\n@expectation begin\n    return ExampleScenario(sum([probability(s)*s.ξ for s in scenarios]))\nend\n\nSee also @define_scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@scenario-Tuple","page":"Public interface","title":"StochasticPrograms.@scenario","text":"@scenario(args..., probability = )\n\nCreate Scenario matching some @uncertain declaration with a supplied probability.\n\n@scenario(var1 = val1, var2 = val2, ..., probability = 1.0)\n\nCreate Scenario matching @uncertain annotation of the form @uncertain var1, var2, ...\n\n@scenario(ξ[i=..., j=..., ...] = values, probability = 1.0)\n\nCreate Scenario matching @uncertain annotation of the form @uncertain ξ[i=..., j=..., ...]. values must have the same dimension as the specified index sets.\n\n@scenario(ξ[i=..., j=..., ...], expr, probability = 1.0, requested_container = :Auto)\n\nCreate Scenario matching @uncertain annotation of the form @uncertain ξ[i=..., j=..., ...]. Wraps JuMP's @container macro to create DenseAxisArray or SparseAxisArray as underlying data. See @container for further syntax information.\n\nExamples\n\nThe following are equivalent ways of creating an instance of the random vector q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ)  of probability 04 and values 240 280 5000 1000.\n\n@scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4\n\n@scenario ξ[i in 1:4] = [24.0, 28.0, 500.0, 100.0] probability = 0.4\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@uncertain-Tuple{Any}","page":"Public interface","title":"StochasticPrograms.@uncertain","text":"@uncertain(def)\n\nIn a @stage block, annotate each uncertain variable using the syntax\n\n@uncertain var1, var2, ...\n\nor using JuMP's container syntax\n\n@uncertain ξ[i=..., j=..., ...]\n\nThis assumes that the [Scenario] type is used. Matching scenario data is then conveniently created using @scenario.\n\nAlternatively, user-defined scenarios can be specified by annotating the type. Also, inside a @stochasticmodel block, user-defined scenarios can be created during the @uncertain annotation, using [`@definescenario`](@ref) syntax.\n\nExamples\n\nThe following are equivalent ways of declaring a random vector q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) in a @stage block, and creating a matching scenario instance of probability 04 and values 240 280 5000 1000.ö\n\n@uncertain q₁ q₂ d₁ d₂\nξ₁ = @scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4\n\n@uncertain ξ[i in 1:4]\nξ₁ = @scenario ξ[i in 1:4] = [24.0, 28.0, 500.0, 100.0] probability = 0.4\n\n@define_scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend\n@uncertain ξ::SimpleScenario\nξ₁ = SimpleScenario(24.0, 28.0, 500.0, 100.0, probability = 0.4)\n\n@stochastic_model begin\n    ...\n    @uncertain ξ::SimpleScenario = begin\n        q₁::Float64\n        q₂::Float64\n        d₁::Float64\n        d₂::Float64\n    end\n    ...\nend\nξ₁ = SimpleScenario(24.0, 28.0, 500.0, 100.0 probability = 0.4)\n\nSee also @scenario, @define_scenario, @parameters, @decision, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@zero-Tuple{Any}","page":"Public interface","title":"StochasticPrograms.@zero","text":"@zero(def)\n\nDefine the additive zero scenario inside a @scenario block using the syntax:\n\n@zero begin\n    ...\n    return zero_scenario\nend\n\nExamples\n\nThe following defines a zero scenario for the example scenario defined in @define_scenario\n\n@zero begin\n    return ExampleScenario(0.0)\nend\n\nSee also @define_scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"AbstractSampler\nSampler\nsample","category":"page"},{"location":"library/public/#StochasticPrograms.AbstractSampler","page":"Public interface","title":"StochasticPrograms.AbstractSampler","text":"AbstractSampler\n\nAbstract supertype for sampler objects.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.Sampler","page":"Public interface","title":"StochasticPrograms.Sampler","text":"Sampler\n\nGeneral purpose sampler object that samples Scenario.\n\nSee also: Scenario, @scenario, @sampler\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.sample","page":"Public interface","title":"StochasticPrograms.sample","text":"sample(sampler::AbstractSampler{S})\n\nSample a scenario of type S using sampler.\n\n\n\n\n\nsample(sampler::AbstractSampler{S}, π::AbstractSampler)\n\nSample a scenario of type S using sampler and set the probability of the sampled scenario to π.\n\n\n\n\n\n","category":"function"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [SMPS]\nPages   = [\"scenario.jl\", \"sampler.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.SMPS.SMPSScenario","page":"Public interface","title":"StochasticPrograms.SMPS.SMPSScenario","text":"SMPSScenario\n\nConveniece type that adheres to the AbstractScenario abstraction. Obtained when reading scenarios specified in SMPS format.\n\nSee also: SMPSSampler\n\n\n\n\n\n","category":"type"},{"location":"library/public/#StochasticPrograms.SMPS.SMPSSampler","page":"Public interface","title":"StochasticPrograms.SMPS.SMPSSampler","text":"SMPSSampler\n\nSampler object for SMPS scenarios. Obtained by reading from a model defined in SMPS format.\n\nSee also: SMPSScenario\n\n\n\n\n\n","category":"type"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"DocTestSetup = quote\n    using StochasticPrograms\nend","category":"page"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"@scenario\n@define_scenario\n@zero\n@expectation\n@sampler\n@sample","category":"page"},{"location":"library/public/#StochasticPrograms.@scenario","page":"Public interface","title":"StochasticPrograms.@scenario","text":"@scenario(args..., probability = )\n\nCreate Scenario matching some @uncertain declaration with a supplied probability.\n\n@scenario(var1 = val1, var2 = val2, ..., probability = 1.0)\n\nCreate Scenario matching @uncertain annotation of the form @uncertain var1, var2, ...\n\n@scenario(ξ[i=..., j=..., ...] = values, probability = 1.0)\n\nCreate Scenario matching @uncertain annotation of the form @uncertain ξ[i=..., j=..., ...]. values must have the same dimension as the specified index sets.\n\n@scenario(ξ[i=..., j=..., ...], expr, probability = 1.0, requested_container = :Auto)\n\nCreate Scenario matching @uncertain annotation of the form @uncertain ξ[i=..., j=..., ...]. Wraps JuMP's @container macro to create DenseAxisArray or SparseAxisArray as underlying data. See @container for further syntax information.\n\nExamples\n\nThe following are equivalent ways of creating an instance of the random vector q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ)  of probability 04 and values 240 280 5000 1000.\n\n@scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4\n\n@scenario ξ[i in 1:4] = [24.0, 28.0, 500.0, 100.0] probability = 0.4\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@define_scenario","page":"Public interface","title":"StochasticPrograms.@define_scenario","text":"@define_scenario(def)\n\nDefine a scenario type compatible with StochasticPrograms using the syntax\n\n@define_scenario name = begin\n    ...structdef...\n\n    [@zero begin\n        ...\n        return zero(scenario)\n    end]\n\n    [@expectation begin\n        ...\n        return expected(scenarios)\n     end]\nend\n\nThe generated type is referenced through name and a default constructor is always generated. This constructor accepts the keyword probability to set the probability of the scenario occuring. Otherwise, any internal variables and specialized constructors are defined in the @define_scenario block as they would be in any Julia struct.\n\nIf possible, a zero method and an expected method will be generated for the defined type. Otherwise, or if the default implementation is not desired, these can be user provided through @zero and @expectation.\n\nThe defined scenario type will be available on all Julia processes.\n\nExamples\n\nThe following defines a simple scenario ξ with a single value.\n\n@define_scenario ExampleScenario = begin\n    ξ::Float64\nend\n\nExampleScenario(1.0, probability = 0.5)\n\n# output\n\nExampleScenario with probability 0.5\n  ξ: 1.0\n\n\nSee also: @zero, @expectation, @sampler\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@zero","page":"Public interface","title":"StochasticPrograms.@zero","text":"@zero(def)\n\nDefine the additive zero scenario inside a @scenario block using the syntax:\n\n@zero begin\n    ...\n    return zero_scenario\nend\n\nExamples\n\nThe following defines a zero scenario for the example scenario defined in @define_scenario\n\n@zero begin\n    return ExampleScenario(0.0)\nend\n\nSee also @define_scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@expectation","page":"Public interface","title":"StochasticPrograms.@expectation","text":"@expectation(def)\n\nDefine how to form the expected scenario inside a @define_scenario block. The scenario collection is accessed through the reserved keyword scenarios.\n\n@zero begin\n    ...\n    return zero_scenario\nend\n\nExamples\n\nThe following defines expectation for the example scenario defined in @scenario\n\n@expectation begin\n    return ExampleScenario(sum([probability(s)*s.ξ for s in scenarios]))\nend\n\nSee also @define_scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@sampler","page":"Public interface","title":"StochasticPrograms.@sampler","text":"@sampler(def)\n\nDefine a sampler type for some scenariotype compatible with StochasticPrograms using the syntax\n\n@sampler samplername = begin\n    ...internals...\n\n    @sample scenariotype begin\n        ...\n        return scenario\n    end\nend\n\nAny internal state required by the sampler, as well as any specialized constructor, are defined in the @sampler block as they would be in any Julia struct. Define the sample operation inside the @sample block and specify the scenariotype that the sampler returns. The defined sampler will be available on all Julia processes.\n\nExamples\n\nThe following defines a simple dummy sampler, with some internal weight value, for the scenario defined in @scenario, and samples one scenario.\n\n@sampler ExampleSampler = begin\n    w::Float64\n\n    ExampleSampler(w::AbstractFloat) = new(w)\n\n    @sample ExampleScenario begin\n        @parameters w\n        return ExampleScenario(w*randn(), probability = rand())\n    end\nend\ns = ExampleSampler(2.0)\ns()\n\n# output\n\nExampleScenario with probability 0.29\n  ξ: 1.48\n\n\n\nSee also: @sample, @scenario\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@sample","page":"Public interface","title":"StochasticPrograms.@sample","text":"@sample(def)\n\nDefine the sample operaton inside a @sampler block, using the syntax\n\n@sample begin\n    ...\n    return sampled_scenario\nend\n\nThe sampler object is referenced through the reserved keyword sampler, from which any internals can be accessed.\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#Model-definition","page":"Public interface","title":"Model definition","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"@stage\n@first_stage\n@second_stage\n@decision\n@recourse\n@known\n@parameters\n@uncertain\n@stochastic_model","category":"page"},{"location":"library/public/#StochasticPrograms.@stage","page":"Public interface","title":"StochasticPrograms.@stage","text":"@stage(def)\n\nAdd a stage model generation recipe to stochasticprogram using the syntax\n\n@stage stage stochasticprogram::StochasticProgram = begin\n    @parameters param1 param2 ...\n    @decision(stochasticprogram, var) ...\n    @uncertain ξ\n    ... JuMPdef ...\n    ...\nend\n\nwhere stage is the stage number and JuMP syntax is used inside the block to define the stage model. During definition, the stage model is referenced using the same variable name as stochasticprogram.\n\nExamples\n\nThe following defines the first stage model given by:\n\n  minimize 100x₁ + 150x₂\n    st  x₁ + x₂  120\n         x₁  40\n         x₂  20\n\nand the second-stage model given by:\n\n  maximize q₁(ξ)y₁ + q₂(ξ)y₂\n    st  6y₁ + 10y₂  60x₁\n         8y₁ + 5y₂  60x₂\n         0  y₁  d₁(ξ)\n         0  y₂  d₂(ξ)\n\nwhere q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) depend on the scenario ξ and x₁ x₂ are first stage variables. Two scenarios are added so that two second stage models are generated.\n\nξ₁ = @scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4\nξ₂ = @scenario q₁ = 28.0 q₂ = 32.0 d₁ = 300.0 d₂ = 300.0 probability = 0.6\n\nsp = StochasticProgram([ξ₁, ξ₂])\n\n@stage 1 sp = begin\n    @decision(sp, x₁ >= 40)\n    @decision(sp, x₂ >= 20)\n    @objective(sp, Min, 100*x₁ + 150*x₂)\n    @constraint(sp, x₁ + x₂ <= 120)\nend\n\n@stage 2 sp = begin\n    @uncertain q₁ q₂ d₁ d₂\n    @variable(sp, 0 <= y₁ <= d₁)\n    @variable(sp, 0 <= y₂ <= d₂)\n    @objective(sp, Max, q₁*y₁ + q₂*y₂)\n    @constraint(sp, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(sp, 8*y₁ + 5*y₂ <= 80*x₂)\nend\n\n# output\n\nStochastic program with:\n * 2 decision variables\n * 2 scenarios of type Scenario\nSolver is default solver\n\n\nSee also: @parameters, @decision, @uncertain\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@first_stage","page":"Public interface","title":"StochasticPrograms.@first_stage","text":"@first_stage(def)\n\nAdd a first stage model generation recipe to stochasticprogram using the syntax\n\n@first_stage stochasticprogram::StochasticProgram = begin\n    ...\nend [defer]\n\nwhere JuMP syntax is used inside the block to define the first stage model. During definition, the first stage model is referenced through the reserved keyword matching the name of stochasticprogram.\n\nExamples\n\nThe following defines the first stage model given by:\n\n  minimize 100x₁ + 150x₂\n    st  x₁ + x₂  120\n         x₁  40\n         x₂  20\n\n@first_stage sp = begin\n    @decision(sp, x₁ >= 40)\n    @decision(sp, x₂ >= 20)\n    @objective(sp, Min, 100*x₁ + 150*x₂)\n    @constraint(sp, x₁ + x₂ <= 120)\nend\n\nSee also: @second_stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@second_stage","page":"Public interface","title":"StochasticPrograms.@second_stage","text":"@second_stage(def)\n\nAdd a second stage model generation recipe to stochasticprogram using the syntax\n\n@second_stage stochasticprogram::StochasticProgram = begin\n    @known var1 var2 ...\n    ...\nend\n\nwhere JuMP syntax is used inside the block to define the second stage model. During definition, the second stage model is referenced through the reserved keyword matching the name of stochasticprogram.\n\nExamples\n\nThe following defines the second stage model given by:\n\n  minimize q₁(ξ)y₁ + q₂(ξ)y₂\n    st  6y₁ + 10y₂  60x₁\n         8y₁ + 5y₂  60x₂\n         0  y₁  d₁(ξ)\n         0  y₂  d₂(ξ)\n\nwhere q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) depend on the scenario ξ and x₁ x₂ are first stage variables. Two scenarios are added so that two second stage models are generated.\n\n@second_stage sp = begin\n    @known(sp, x₁, x₂)\n    @uncertain q₁ q₂ d₁ d₂\n    @variable(sp, 0 <= y₁ <= d₁)\n    @variable(sp, 0 <= y₂ <= d₂)\n    @objective(sp, Min, q₁*y₁ + q₂*y₂)\n    @constraint(sp, 6*y₁ + 10*y₂ <= 60*x₁)\n    @constraint(sp, 8*y₁ + 5*y₂ <= 80*x₂)\nend\n\nSee also: @first_stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@decision","page":"Public interface","title":"StochasticPrograms.@decision","text":"@decision(model, expr, args..., kw_args...)\n\nAdd a decision variable to model described by the expression expr. If used inside a @stage block, the created variable can be used in subsequent stage blocks. @recourse should be used to mark decisions in the final stage. See @variable for syntax details.\n\nExamples\n\n@decision(model, x >= 40)\n\nSee also @recourse, @parameters, @uncertain, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@recourse","page":"Public interface","title":"StochasticPrograms.@recourse","text":"@recourse(model, expr, args..., kw_args...)\n\nAdd a recourse decision variable to model described by the expression expr. Replaces @decision in the @stage block of the final stage, and can only be used there. See @variable for syntax details.\n\nExamples\n\n@recourse(model, 0 <= y <= 1)\n\nSee also @decision, @parameters, @uncertain, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@known","page":"Public interface","title":"StochasticPrograms.@known","text":"@known(def)\n\nAnnotate each decision taken in the previous stage. Any @decision included in a @stochastic_model definition will implicitly add @known annotations to subsequent stages.\n\nExamples\n\n@known x₁, x₂\n\nSee also @decision, @parameters, @uncertain, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@parameters","page":"Public interface","title":"StochasticPrograms.@parameters","text":"@parameters(def)\n\nDefine the problem parameters in a @stage block\n\n@parameters param1, param2, ...\n\npossibly with default values. Any defined parameter without a default value must be supplied as a keyword argument to instantiate when creating models.\n\nExamples\n\n@parameters d\n\n@parameters begin\n    Crops = [:wheat, :corn, :beets]\n    Cost = Dict(:wheat=>150, :corn=>230, :beets=>260)\n    Budget = 500\nend\n\nSee also @decision, @uncertain, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@uncertain","page":"Public interface","title":"StochasticPrograms.@uncertain","text":"@uncertain(def)\n\nIn a @stage block, annotate each uncertain variable using the syntax\n\n@uncertain var1, var2, ...\n\nor using JuMP's container syntax\n\n@uncertain ξ[i=..., j=..., ...]\n\nThis assumes that the [Scenario] type is used. Matching scenario data is then conveniently created using @scenario.\n\nAlternatively, user-defined scenarios can be specified by annotating the type. Also, inside a @stochasticmodel block, user-defined scenarios can be created during the @uncertain annotation, using [`@definescenario`](@ref) syntax.\n\nExamples\n\nThe following are equivalent ways of declaring a random vector q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) in a @stage block, and creating a matching scenario instance of probability 04 and values 240 280 5000 1000.ö\n\n@uncertain q₁ q₂ d₁ d₂\nξ₁ = @scenario q₁ = 24.0 q₂ = 28.0 d₁ = 500.0 d₂ = 100.0 probability = 0.4\n\n@uncertain ξ[i in 1:4]\nξ₁ = @scenario ξ[i in 1:4] = [24.0, 28.0, 500.0, 100.0] probability = 0.4\n\n@define_scenario SimpleScenario = begin\n    q₁::Float64\n    q₂::Float64\n    d₁::Float64\n    d₂::Float64\nend\n@uncertain ξ::SimpleScenario\nξ₁ = SimpleScenario(24.0, 28.0, 500.0, 100.0, probability = 0.4)\n\n@stochastic_model begin\n    ...\n    @uncertain ξ::SimpleScenario = begin\n        q₁::Float64\n        q₂::Float64\n        d₁::Float64\n        d₂::Float64\n    end\n    ...\nend\nξ₁ = SimpleScenario(24.0, 28.0, 500.0, 100.0 probability = 0.4)\n\nSee also @scenario, @define_scenario, @parameters, @decision, @stage\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#StochasticPrograms.@stochastic_model","page":"Public interface","title":"StochasticPrograms.@stochastic_model","text":"@stochastic_model(def)\n\nDefine a stochastic model capable of instantiating stochastic programs, using the syntax\n\n@stochastic_model model_name begin\n    ...\n    @stage x begin\n      ...\n    end\n    ...\nend\n\nwhere the inner blocks are @stage blocks. At least two stages must be specified in consecutive order. A stochastic model object can later be used to instantiate stochastic programs using a given set of scenarios or by using samplers. The model is referenced using model_name in the @stage blocks. If model_name is left out, the macro returns an anonymous model object, and the reserved keyword model must be used in the @stage blocks. Otherwise, the resulting stochastic model object is stored in a variable named model_name.\n\nExamples\n\nThe following defines a stochastic model consisitng of the first stage model given by:\n\n  minimize 100x₁ + 150x₂\n    st  x₁ + x₂  120\n         x₁  40\n         x₂  20\n\nand the second-stage model given by:\n\n  minimize q₁(ξ)y₁ + q₂(ξ)y₂\n    st  6y₁ + 10y₂  60x₁\n         8y₁ + 5y₂  60x₂\n         0  y₁  d₁(ξ)\n         0  y₂  d₂(ξ)\n\nwhere q₁(ξ) q₂(ξ) d₁(ξ) d₂(ξ) depend on the scenario ξ.\n\n@stochastic_model sm begin\n    @stage 1 begin\n        @decision(sm, x₁ >= 40)\n        @decision(sm, x₂ >= 20)\n        @objective(sm, Min, 100*x₁ + 150*x₂)\n        @constraint(sm, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @uncertain q₁ q₂ d₁ d₂\n        @variable(sm, 0 <= y₁ <= d₁)\n        @variable(sm, 0 <= y₂ <= d₂)\n        @objective(sm, Min, q₁*y₁ + q₂*y₂)\n        @constraint(sm, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(sm, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend\n\nor alternatively using anonymous syntax:\n\nsm = @stochastic_model begin\n    @stage 1 begin\n        @decision(model, x₁ >= 40)\n        @decision(model, x₂ >= 20)\n        @objective(model, Min, 100*x₁ + 150*x₂)\n        @constraint(model, x₁ + x₂ <= 120)\n    end\n    @stage 2 begin\n        @uncertain q₁ q₂ d₁ d₂\n        @variable(model, 0 <= y₁ <= d₁)\n        @variable(model, 0 <= y₂ <= d₂)\n        @objective(model, Min, q₁*y₁ + q₂*y₂)\n        @constraint(model, 6*y₁ + 10*y₂ <= 60*x₁)\n        @constraint(model, 8*y₁ + 5*y₂ <= 80*x₂)\n    end\nend\n\nwhere the reserved keyword model is used throughout.\n\nSee also: @stage, @parameters, @decision, @uncertain\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#API","page":"Public interface","title":"API","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"api.jl\", \"generation.jl\", \"evaluation.jl\"]","category":"page"},{"location":"library/public/#Base.getindex-Tuple{StochasticProgram, Integer, Symbol}","page":"Public interface","title":"Base.getindex","text":"Base.getindex(stochasticprogram::StochasticProgram, stage::Integer, name::Symbol)\n\nReturns the decision, or group of decisions, or decision constraint, or group of decision constraints, of the given name and stage of the stochasticprogram which were added to the model. This errors if regular variables or constraints are queried. If so, either annotate the relevant variables with @decision or first query the relevant JuMP subproblem and use the regular [] syntax.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual_status-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.dual_status","text":"dual_status(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver of the node at stage stage and scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual_status-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.dual_status","text":"dual_status(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver of scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.dual_status-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.dual_status","text":"dual_status(stochasticprogram::StochasticProgram; result::Int = 1)\n\nReturn the status of the most recent dual solution of the solver of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.get_optimizer_attribute-Tuple{StochasticProgram, MathOptInterface.AbstractOptimizerAttribute}","page":"Public interface","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(stochasticprogram::StochasticProgram, attr::MOI.AbstractOptimizerAttribute)\n\nReturn the value of the solver-specific attribute attr in stochasticprogram.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.get_optimizer_attribute-Tuple{StochasticProgram, String}","page":"Public interface","title":"JuMP.get_optimizer_attribute","text":"get_optimizer_attribute(stochasticprogram::StochasticProgram, name::String)\n\nReturn the value associated with the solver-specific attribute named name in stochasticprogram.\n\nSee also: set_optimizer_attribute, set_optimizer_attributes.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.num_variables-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"JuMP.num_variables","text":"num_variables(stochasticprogram::StochasticProgram, stage::Integer = 1)\n\nReturn the total number of variables at stage in the stochasticprogram. Defaults to the first stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.objective_value-Tuple{StochasticModel}","page":"Public interface","title":"JuMP.objective_value","text":"objective_value(stochasticmodel::StochasticModel; result::Int = 1)\n\nReturns a confidence interval around the value of the recourse problem after a call to optimize!(stochasticmodel).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.optimize!-Tuple{StochasticModel, AbstractSampler}","page":"Public interface","title":"JuMP.optimize!","text":"optimize!(stochasticmodel::StochasticModel, sampler::AbstractSampler; crash::AbstractCrash = Crash.None(), kw...)\n\nApproximately optimize the stochasticmodel when the underlying scenario distribution is inferred by sampler. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.optimize!-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"JuMP.optimize!","text":"optimize!(stochasticprogram::StochasticProgram; crash::AbstractCrash = Crash.None(), cache::Bool = false; kw...)\n\nOptimize the stochasticprogram in expectation. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown. An optional crash procedure can be set to warm-start. Setting the cache flag to true will, upon sucessful termination, try to cache the solution values for all relevant attributes in the model. The values will then persist after future evaluate calls that would otherwise overwrite the optimal solution.\n\nExamples\n\nThe following solves the stochastic program sp using the L-shaped algorithm.\n\nset_optimizer(sp, LShaped.Optimizer)\nset_optimizer_attribute(sp, MasterOptimizer(), GLPK.Optimizer)\nset_optimizer_attribute(sp, SubProblemOptimizer(), GLPK.Optimizer)\noptimize!(sp);\n\n# output\n\nL-Shaped Gap  Time: 0:00:02 (6 iterations)\n  Objective:       -855.8333333333358\n  Gap:             0.0\n  Number of cuts:  8\n  Iterations:      6\n\nThe following solves the stochastic program sp using GLPK on the extended form.\n\nusing GLPK\n\nset_optimizer(sp, GLPK.Optimizer)\noptimize!(sp)\n\n\nSee also: VRP\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.primal_status-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.primal_status","text":"primal_status(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver of the node at stage stage and scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.primal_status-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.primal_status","text":"primal_status(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver of the scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.primal_status-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.primal_status","text":"primal_status(stochasticprogram::StochasticProgram; result::Int = 1)\n\nReturn the status of the most recent primal solution of the solver of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.raw_status-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.raw_status","text":"raw_status(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the reason why the solver of the node at stage stage and scenario scenario_index stopped in its own words.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.raw_status-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.raw_status","text":"raw_status(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer)\n\nReturn the reason why the solver of scenario scenario_index stopped in its own words.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.raw_status-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.raw_status","text":"raw_status(stochasticprogram::StochasticProgram)\n\nReturn the reason why the solver of the stochasticprogram stopped in its own words.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_optimizer-Tuple{StochasticModel, Any}","page":"Public interface","title":"JuMP.set_optimizer","text":"set_optimizer(stochasticmodel::StochasticModel, optimizer)\n\nSet the optimizer of the stochasticmodel.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_optimizer-Tuple{StochasticProgram, Any}","page":"Public interface","title":"JuMP.set_optimizer","text":"set_optimizer(stochasticprogram::StochasticProgram, optimizer)\n\nSet the optimizer of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_optimizer_attribute-Tuple{StochasticProgram, MathOptInterface.AbstractOptimizerAttribute, Any}","page":"Public interface","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(stochasticprogram::StochasticProgram, attr::MOI.AbstractOptimizerAttribute, value)\n\nSet the solver-specific attribute attr in stochasticprogram to value.\n\nSee also: get_optimizer_attribute\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_optimizer_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}","page":"Public interface","title":"JuMP.set_optimizer_attribute","text":"set_optimizer_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)\n\nSets solver-specific attribute identified by name to value in the stochasticprogram.\n\nSee also: get_optimizer_attribute\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.set_optimizer_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}","page":"Public interface","title":"JuMP.set_optimizer_attributes","text":"set_optimizer_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)\n\nGiven a list of attribute => value pairs or a collection of keyword arguments, calls set_optimizer_attribute(stochasticprogram, attribute, value) for each pair.\n\nSee also: get_optimizer_attribute\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.solve_time-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.solve_time","text":"solve_time(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nIf available, returns the solve time reported by the solver of the node at stage stage and scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.solve_time-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.solve_time","text":"solve_time(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer)\n\nIf available, returns the solve time reported by the solver of scenario scenario_index.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.solve_time-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.solve_time","text":"solve_time(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nIf available, returns the solve time reported by the solver of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.termination_status-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"JuMP.termination_status","text":"termination_status(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the reason why the solver of the node at stage stage and scenario scenario_index stopped.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.termination_status-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"JuMP.termination_status","text":"termination_status(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer)\n\nReturn the reason why the solver of scenario scenario_index stopped.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#JuMP.termination_status-Tuple{StochasticProgram}","page":"Public interface","title":"JuMP.termination_status","text":"termination_status(stochasticprogram::StochasticProgram)\n\nReturn the reason why the solver of the stochasticprogram stopped.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenario!-Tuple{Function, StochasticProgram, Integer}","page":"Public interface","title":"StochasticPrograms.add_scenario!","text":"add_scenario!(scenariogenerator::Function, stochasticprogram::StochasticProgram, stage::Integer)\n\nStore the scenario returned by scenariogenerator in the stage of the stochasticprogram. If the stochasticprogram is distributed, the scenario will be defined on the node that currently has the fewest scenarios.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenario!-Tuple{Function, StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.add_scenario!","text":"add_scenario!(scenariogenerator::Function, stochasticprogram::StochasticProgram)\n\nStore the scenario returned by scenariogenerator in the two-stage stochasticprogram. If the stochasticprogram is distributed, the scenario will be defined on the node that currently has the fewest scenarios.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenario!-Tuple{StochasticProgram, Integer, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.add_scenario!","text":"add_scenario!(stochasticprogram::StochasticProgram, stage::Integer, scenario::AbstractScenario)\n\nStore the second stage scenario in the stochasticprogram at stage.\n\nIf the stochasticprogram is distributed, the scenario will be defined on the node that currently has the fewest scenarios.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenario!-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.add_scenario!","text":"add_scenario!(stochasticprogram::TwoStageStochasticProgram, scenario::AbstractScenario)\n\nStore the second stage scenario in the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenarios!-Tuple{Function, StochasticProgram, Integer, Integer}","page":"Public interface","title":"StochasticPrograms.add_scenarios!","text":"add_scenarios!(scenariogenerator::Function, stochasticprogram::StochasticProgram, stage::Integer, n::Integer)\n\nGenerate n scenarios using scenariogenerator and store in the stochasticprogram at stage. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenarios!-Tuple{Function, StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"StochasticPrograms.add_scenarios!","text":"add_scenarios!(scenariogenerator::Function, stochasticprogram::TwoStageStochasticProgram, n::Integer)\n\nGenerate n scenarios using scenariogenerator and store in the two-stage stochasticprogram. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenarios!-Tuple{StochasticProgram, Integer, Vector{var\"#s145\"} where var\"#s145\"<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.add_scenarios!","text":"add_scenarios!(stochasticprogram::StochasticProgram, stage::Integer, scenarios::Vector{<:AbstractScenario})\n\nStore the collection of scenarios in the stochasticprogram at stage. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_scenarios!-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Vector{var\"#s145\"} where var\"#s145\"<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.add_scenarios!","text":"add_scenarios!(stochasticprogram::TwoStageStochasticProgram, scenarios::Vector{<:AbstractScenario})\n\nStore the collection of scenarios in the two-stage stochasticprogram. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenario!-Tuple{Function, StochasticProgram, Integer, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenario!","text":"add_worker_scenario!(scenariogenerator::Function, stochasticprogram::StochasticProgram, stage::Integer, w::Integer)\n\nStore the scenario returned by scenariogenerator in worker node w of the stochasticprogram at stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenario!-Tuple{Function, StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenario!","text":"add_worker_scenario!(scenariogenerator::Function, stochasticprogram::TwoStageStochasticProgram, w::Integer)\n\nStore the scenario returned by scenariogenerator in worker node w of the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenario!-Tuple{StochasticProgram, Integer, AbstractScenario, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenario!","text":"add_worker_scenario!(stochasticprogram::StochasticProgram, stage::Integer, scenario::AbstractScenario, w::Integer)\n\nStore the second stage scenario in worker node w of the stochasticprogram at stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenario!-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractScenario, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenario!","text":"add_worker_scenario!(stochasticprogram::StochasticProgram, stage::Integer, scenario::AbstractScenario, w::Integer)\n\nStore the second stage scenario in worker node w of the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenarios!-Tuple{Function, StochasticProgram, Integer, Integer, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenarios!","text":"add_worker_scenarios!(scenariogenerator::Function, stochasticprogram::StochasticProgram, stage::Integer, n::Integer, w::Integer)\n\nGenerate n scenarios using scenariogenerator and store them in worker node w of the stochasticprogram at stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenarios!-Tuple{Function, StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenarios!","text":"add_worker_scenarios!(scenariogenerator::Function, stochasticprogram::TwoStageStochasticProgram, n::Integer, w::Integer)\n\nGenerate n scenarios using scenariogenerator and store them in worker node w of the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenarios!-Tuple{StochasticProgram, Integer, Vector{var\"#s145\"} where var\"#s145\"<:AbstractScenario, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenarios!","text":"add_worker_scenarios!(stochasticprogram::StochasticProgram, stage::Integer, scenarios::Vector{<:AbstractScenario}, w::Integer)\n\nStore the collection of scenarios in in worker node w of the stochasticprogram at stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.add_worker_scenarios!-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Vector{var\"#s145\"} where var\"#s145\"<:AbstractScenario, Integer}","page":"Public interface","title":"StochasticPrograms.add_worker_scenarios!","text":"add_worker_scenarios!(stochasticprogram::StochasticProgram, stage::Integer, scenarios::Vector{<:AbstractScenario}, w::Integer)\n\nStore the collection of scenarios in in worker node w of the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.all_decision_variables-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.all_decision_variables","text":"all_decision_variables(stochasticprogram::StochasticProgram{N}, stage::Integer = 1) where N\n\nReturns a list of all decisions currently in the stochasticprogram at stage. The decisions are ordered by creation time.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.all_decision_variables-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}} where N","page":"Public interface","title":"StochasticPrograms.all_decision_variables","text":"all_decision_variables(stochasticprogram::StochasticProgram{N}) where N\n\nReturns a stage-wise list of all decisions currently in the stochasticprogram. The decisions are ordered by creation time. Defaults to the first stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.cache_solution!-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.cache_solution!","text":"cache_solution!(stochasticprogram::StochasticProgram)\n\nCache the optimal solution, including as many model/variable/constraints attributes as possible, after a call to optimize!\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision-Tuple{StochasticProgram, MathOptInterface.VariableIndex}","page":"Public interface","title":"StochasticPrograms.decision","text":"decision(stochasticprogram::StochasticProgram, index::MOI.VariableIndex)\n\nReturn the current value of the first-stage decision at index of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.decision-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.decision","text":"decision(stochasticprogram::StochasticProgram)\n\nReturn the current first-stage decision values of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.deferred-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.deferred","text":"deferred(stochasticprogram::StochasticProgram)\n\nReturn true if stochasticprogram is not fully generated.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.distributed","page":"Public interface","title":"StochasticPrograms.distributed","text":"distributed(stochasticprogram::StochasticProgram, s::Integer = 2)\n\nReturn true if the stochasticprogram is memory distributed at stage s. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.expected-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.expected","text":"expected(stochasticprogram::StochasticProgram, stage::Integer = 2)\n\nReturn the exected scenario of all scenarios of the stochasticprogram at stage. Defaults to the second stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.first_stage-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.first_stage","text":"first_stage(stochasticprogram::StochasticProgram)\n\nReturn the first stage of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.generator-Tuple{StochasticProgram, Symbol}","page":"Public interface","title":"StochasticPrograms.generator","text":"generator(stochasticprogram::StochasticProgram, key::Symbol)\n\nReturn the problem generator associated with key in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.has_generator-Tuple{StochasticProgram, Symbol}","page":"Public interface","title":"StochasticPrograms.has_generator","text":"has_generator(stochasticprogram::StochasticProgram, key::Symbol)\n\nReturn true if a problem generator with key exists in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.instantiate-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, Vector{var\"#s77\"} where var\"#s77\"<:AbstractScenario}","page":"Public interface","title":"StochasticPrograms.instantiate","text":"instantiate(stochasticmodel::StochasticModel{2},\n            scenarios::Vector{<:AbstractScenario};\n            instantiation::StochasticInstantiation = UnspecifiedInstantiation(),\n            optimizer = nothing;\n            defer::Bool = false,\n            kw...)\n\nInstantiate a two-stage stochastic program using the model definition stored in the two-stage stochasticmodel, and the given collection of scenarios. Optionally, supply an optimizer. If no explicit instantiation is provided, the structure is induced by the optimizer. The structure is Deterministic by default.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.instantiate-Union{Tuple{M}, Tuple{N}, Tuple{StochasticModel{N, P} where P<:Tuple{Vararg{StageParameters, N}}, Tuple{Vararg{Vector{var\"#s77\"} where var\"#s77\"<:AbstractScenario, M}}}} where {N, M}","page":"Public interface","title":"StochasticPrograms.instantiate","text":"instantiate(stochasticmodel::StochasticModel,\n            scenarios::Vector{<:AbstractScenario};\n            instantiation::StochasticInstantiation = UnspecifiedInstantiation(),\n            optimizer = nothing,\n            defer::Bool = false,\n            kw...)\n\nInstantiate a stochastic program using the model definition stored in stochasticmodel, and the given collection of scenarios. Optionally, supply an optimizer. If no explicit instantiation is provided, the structure is induced by the optimizer. The structure is Deterministic by default.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.instantiate-Union{Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}}, Tuple{S}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.instantiate","text":"instantiate(stochasticmodel::StochasticModel{2};\n            instantiation::StochasticInstantiation = UnspecifiedInstantiation(),\n            optimizer = nothing,\n            scenario_type::Type{S} = Scenario,\n            defer::Bool = false,\n            kw...) where S <: AbstractScenario\n\nInstantiate a deferred two-stage stochastic program using the model definition stored in the two-stage stochasticmodel over the scenario type S. Optionally, supply an optimizer. If no explicit instantiation is provided, the structure is induced by the optimizer. The structure is Deterministic by default.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.instantiate-Union{Tuple{S}, Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler{S}, Integer}} where S<:AbstractScenario","page":"Public interface","title":"StochasticPrograms.instantiate","text":"instantiate(stochasticmodel::StochasticModel,\n            sampler::AbstractSampler,\n            n::Integer;\n            instantiation::StochasticInstantiation = UnspecifiedInstantiation(),\n            optimizer = nothing,\n            defer::Bool = false,\n            kw...)\n\nGenerate a sampled instance of size n using the model stored in the two-stage stochasticmodel, and the provided sampler. Optionally, supply an optimizer. If no explicit instantiation is provided, the structure is induced by the optimizer. The structure is Deterministic by default.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.master_optimizer-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.master_optimizer","text":"master_optimizer(stochasticprogram::StochasticProgram)\n\nReturn a MOI optimizer using the currently provided optimizer of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.num_decisions-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.num_decisions","text":"num_decisions(stochasticprogram::StochasticProgram, stage::Integer = 1)\n\nReturn the number of decisions at stage in the stochasticprogram. Defaults to the first stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.num_scenarios","page":"Public interface","title":"StochasticPrograms.num_scenarios","text":"num_scenarios(stochasticprogram::StochasticProgram, stage::Integer = 2)\n\nReturn the number of scenarios in the stochasticprogram at stage. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.num_stages-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}} where N","page":"Public interface","title":"StochasticPrograms.num_stages","text":"num_stages(stochasticprogram::StochasticProgram)\n\nReturn the number of stages in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.num_subproblems","page":"Public interface","title":"StochasticPrograms.num_subproblems","text":"num_subproblems(stochasticprogram::StochasticProgram, stage::Integer = 2)\n\nReturn the number of subproblems in the stochasticprogram at stage. Defaults to the second stage.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticModel}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticmodel::StochasticModel)\n\nReturn the optimal first stage decision of stochasticmodel, after a call to optimize!(stochasticmodel).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the optimal decision in the node at stage stage and scenario scenario_index of stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer)\n\nReturn the optimal decision in scenario scenario_index of the two-stage stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_decision-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.optimal_decision","text":"optimal_decision(stochasticprogram::StochasticProgram)\n\nReturn the optimal first stage decision of stochasticprogram, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimal_recourse_decision-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.optimal_recourse_decision","text":"optimal_recourse_decision(stochasticprogram::StochasticProgram, scenario_index::Integer)\n\nReturn the optimal recourse decision in the final stage of stochasticprogram in the scenario scenario_index, after a call to optimize!(stochasticprogram).\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimizer-Tuple{StochasticModel}","page":"Public interface","title":"StochasticPrograms.optimizer","text":"optimizer(stochasticmodel::StochasticModel)\n\nReturn the optimizer attached to stochasticmodel.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimizer-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.optimizer","text":"optimizer(stochasticprogram::StochasticProgram)\n\nReturn the optimizer attached to stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimizer_constructor-Tuple{StochasticModel}","page":"Public interface","title":"StochasticPrograms.optimizer_constructor","text":"optimizer_constructor(stochasticmodel::StochasticModel)\n\nReturn any optimizer constructor supplied to the stochasticmodel.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimizer_constructor-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.optimizer_constructor","text":"optimizer_constructor(stochasticprogram::StochasticProgram)\n\nReturn any optimizer constructor supplied to the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimizer_name-Tuple{StochasticModel}","page":"Public interface","title":"StochasticPrograms.optimizer_name","text":"optimizer_name(stochasticmodel::StochasticModel)\n\nReturn the currently provided optimizer type of stochasticmodel.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.optimizer_name-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.optimizer_name","text":"optimizer_name(stochasticprogram::StochasticProgram)\n\nReturn the currently provided optimizer type of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.probability-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"StochasticPrograms.probability","text":"probability(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer)\n\nReturn the probability of the scenario at scenario_index in the two-stage stochasticprogram occuring.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.probability-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, Integer}} where N","page":"Public interface","title":"StochasticPrograms.probability","text":"probability(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the probability of the scenario at scenario_index in the stochasticprogram at stage occuring.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.proxy-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.proxy","text":"proxy(stochasticprogram::StochasticProgram, stage::Integer)\n\nReturn the proxy model of the stochasticprogram at stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.sample!-Tuple{StochasticProgram, Integer, AbstractSampler, Integer}","page":"Public interface","title":"StochasticPrograms.sample!","text":"sample!(stochasticprogram::StochasticProgram, stage::Integer, sampler::AbstractSampler, n::Integer)\n\nSample n scenarios using sampler and add to the stochasticprogram at stage. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.sample!-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractSampler, Integer}","page":"Public interface","title":"StochasticPrograms.sample!","text":"sample!(stochasticprogram::TwoStageStochasticProgram, sampler::AbstractSampler, n::Integer)\n\nSample n scenarios using sampler and add to the two-stage stochasticprogram. If the stochasticprogram is distributed, scenarios will be distributed evenly across workers.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenario-Union{Tuple{N}, Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.scenario","text":"scenario(stochasticprogram::TwoStageStochasticProgram, scenario_index::Integer)\n\nReturn the scenario at scenario_index of the two-stage stochasticprogram\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenario-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, Integer}} where N","page":"Public interface","title":"StochasticPrograms.scenario","text":"scenario(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the scenario at scenario_index of stochasticprogram at stage stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenario_type-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.scenario_type","text":"scenario_type(stochasticprogram::StochasticProgram, stage::Integer = 2)\n\nReturn the type of the scenario structure associated with stochasticprogram at stage. Defaults to the second stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenario_types-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.scenario_types","text":"scenario_types(stochasticprogram::StochasticProgram)\n\nReturn a stage-wise list of the scenario types of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.scenarios-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.scenarios","text":"scenarios(stochasticprogram::StochasticProgram, stage::Integer = 2)\n\nReturn an array of all scenarios of the stochasticprogram at stage. Defaults to the second stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_parameters-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.stage_parameters","text":"stage_parameters(stochasticprogram::StochasticProgram, stage::Integer)\n\nReturn the parameters at stage in stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_probability-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.stage_probability","text":"stage_probability(stochasticprogram::StochasticProgram, stage::Integer = 2)\n\nReturn the probability of any scenario in the stochasticprogram at stage occuring. A well defined model should return 1. Defaults to the second stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.structure-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.structure","text":"structure(stochasticprogram::StochasticProgram)\n\nReturn the underlying structure of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.structure_name-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.structure_name","text":"structure_name(stochasticprogram::StochasticProgram)\n\nReturn the name of the underlying structure of the stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.subproblem-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, Integer}","page":"Public interface","title":"StochasticPrograms.subproblem","text":"subproblem(stochasticprogram::TwoStasgeStochasticProgram, scenario_index::Integer)\n\nReturn the subproblem at scenario_index of the two-stage stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.subproblem-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, Integer}} where N","page":"Public interface","title":"StochasticPrograms.subproblem","text":"subproblem(stochasticprogram::StochasticProgram, stage::Integer, scenario_index::Integer)\n\nReturn the subproblem at scenario_index of the stochasticprogram at stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.subproblem_optimizer-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.subproblem_optimizer","text":"subproblem_optimizer(stochasticprogram::StochasticProgram)\n\nReturn a MOI optimizer for solving subproblems using the currently provided optimizer of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.subproblems-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer}} where N","page":"Public interface","title":"StochasticPrograms.subproblems","text":"subproblems(stochasticprogram::StochasticProgram, stage::Integer = 2)\n\nReturn an array of all subproblems of the stochasticprogram at stage. Defaults to the second stage.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.update_decisions!-Tuple{StochasticProgram, Integer, Integer}","page":"Public interface","title":"StochasticPrograms.update_decisions!","text":"update_decisions!(stochasticprogram::Stochasticprogram, stage::Integer, scenario_index::Integer)\n\nUpdate all known decision values in the node at stage stage and scenario scenario_index of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.update_known_decisions!-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.update_known_decisions!","text":"update_known_decisions!(stochasticprogram::Stochasticprogram)\n\nUpdate all known decision values in the first-stage of stochasticprogram.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.clear!-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}} where N","page":"Public interface","title":"StochasticPrograms.clear!","text":"clear!(stochasticprogram::StochasticProgram)\n\nClear the stochasticprogram, removing all model definitions.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.generate!-Union{Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}}, Tuple{N}} where N","page":"Public interface","title":"StochasticPrograms.generate!","text":"generate!(stochasticprogram::StochasticProgram)\n\nGenerate the stochasticprogram using the model definitions from @stage and available data.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.outcome_model-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractVector{T} where T, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.outcome_model","text":"outcome_model(stochasticprogram::TwoStageStochasticProgram,\n              decision::AbstractVector,\n              scenario::AbstractScenario;\n              optimizer = nothing)\n\nReturn the resulting second stage model if decision is the first-stage decision in the provided scenario, in stochasticprogram. The supplied decision must match the defined decision variables in stochasticprogram. Optionally, supply a capable optimizer to the outcome model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.outcome_model-Union{Tuple{M}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Tuple{Vararg{AbstractVector{T} where T, M}}, Tuple{Vararg{AbstractScenario, M}}}} where {N, M}","page":"Public interface","title":"StochasticPrograms.outcome_model","text":"outcome_model(stochasticprogram::StochasticProgram{N},\n              decisions::NTuple{N-1,AbstractVector}\n              scenario_path::NTuple{N-1,AbstractScenario},\n              optimizer = nothing)\n\nReturn the resulting N:th stage model if decisions are the decisions taken in the previous stages and scenario_path are the realized scenarios up to stage N in stochasticprogram. Optionally, supply a capable solver to the outcome model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_model-Union{Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S<:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST<:AbstractStochasticStructure{N}}, Integer, AbstractScenario}} where N","page":"Public interface","title":"StochasticPrograms.stage_model","text":"stage_model(stochasticprogram::StochasticProgram, stage::Integer, scenario::AbstractScenario; optimizer = nothing)\n\nReturn a generated stage model corresponding to scenario, in stochasticprogram. Optionally, supply a capable optimizer to the stage model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.stage_one_model-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.stage_one_model","text":"stage_one_model(stochasticprogram::StochasticProgram; optimizer = nothing)\n\nReturn a generated copy of the first stage model in stochasticprogram. Optionally, supply a capable optimizer to the stage model.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.confidence_interval-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.confidence_interval","text":"confidence_interval(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler)\n\nGenerate a confidence interval around the true optimum of the two-stage stochasticmodel at level confidence using SAA, over the scenario distribution induced by sampler.\n\nThe attribute NumSamples is the size of the sampled models used to generate the interval and generally governs how tight it is. The attribute NumLowerTrials is the number of sampled models used in the lower bound calculation and the attribute NumUpperTrials is the number of sampled models used in the upper bound calculation. The attribute NumEvalSamples is the size of the sampled models used in the upper bound calculation. The confidence level can be set through the Confidence attribute.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractVector{T} where T, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.evaluate_decision","text":"evaluate_decision(stochasticmodel::StochasticModel{2}, decision::AbstractVector, sampler::AbstractSampler; kw...)\n\nReturn a statistical estimate of the objective of the two-stage stochasticmodel at decision in the form of a confidence interval at the current confidence level, over the scenario distribution induced by sampler.\n\nIn other words, evaluate decision on a sampled model and generate an confidence interval using the sample variance of the evaluation. The confidence level can be set through the Confidence attribute and the sample size can be set through the NumEvalSamples attribute.\n\nThe supplied decision must match the defined decision variables in stochasticmodel. If a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: confidence_interval\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractVector{T} where T, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.evaluate_decision","text":"evaluate_decision(stochasticprogram::TwoStageStochasticProgram, decision::AbstractVector, scenario::AbstractScenario)\n\nEvaluate the result of taking the first-stage decision if scenario is the actual outcome in stochasticprogram. The supplied decision must match the defined decision variables in stochasticprogram. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractVector{T} where T}","page":"Public interface","title":"StochasticPrograms.evaluate_decision","text":"evaluate_decision(stochasticprogram::TwoStageStochasticProgram, decision::AbstractVector)\n\nEvaluate the first-stage decision in stochasticprogram.\n\nIn other words, evaluate the first-stage objective at decision and solve outcome models of decision for every available scenario. The supplied decision must match the defined decision variables in stochasticprogram. If a optimal solution to stochasticprogram has been determined, but cache_solution! has not been called, then the solution will be overwritten by this call. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.gap-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractVector{T} where T, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.gap","text":"gap(stochasticmodel::StochasticModel{2}, decision::UnionAbstractVector, sampler::AbstractSampler)\n\nGenerate a confidence interval around the gap between the result of using decision and the true optimum of the two-stage stochasticmodel at the current confidence level, over the scenario distribution induced by sampler.\n\nThe attribute NumSamples is the size of the sampled models used to generate the interval and generally governs how tight it is. The attribute NumLowerTrials is the number of sampled models used in the lower bound calculation and the attribute NumUpperTrials is the number of sampled models used in the upper bound calculation. The attribute NumEvalSamples is the size of the sampled models used in the upper bound calculation. The confidence level can be set through the Confidence attribute.\n\nThe supplied decision must match the defined decision variables in stochasticmodel. If a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.lower_confidence_interval-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.lower_confidence_interval","text":"lower_confidence_interval(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; kw...)\n\nGenerate a confidence interval around a lower bound on the true optimum of the two-stage stochasticmodel at the current confidence level, over the scenario distribution induced by sampler.\n\nThe attribute NumSamples is the size of the sampled models used to generate the interval and generally governs how tight it is. The attribute NumLowerTrials is the number of sampled models. The confidence level can be set through the Confidence attribute.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.recourse_decision-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractVector{T} where T, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.recourse_decision","text":"recourse_decision(stochasticprogram::TwoStageStochasticProgram, decision::AbstractVector, scenario::AbstractScenario)\n\nDetermine the optimal recourse decision after taking the first-stage decision if scenario is the actual outcome in stochasticprogram. The supplied decision must match the defined decision variables in stochasticprogram. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.statistically_evaluate_decision-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractVector{T} where T}","page":"Public interface","title":"StochasticPrograms.statistically_evaluate_decision","text":"statistically_evaluate_decision(stochasticprogram::TwoStageStochasticProgram, decision::AbstractVector)\n\nStatistically evaluate the first-stage decision in stochasticprogram, returning the evaluated value and the spread over the scenarios.\n\nThe supplied decision must match the defined decision variables in stochasticprogram. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.upper_confidence_interval-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.upper_confidence_interval","text":"upper_confidence_interval(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; kw...)\n\nGenerate a confidence interval around an upper bound of the true optimum of the two-stage stochasticmodel at the current confidence level, over the scenario distribution induced by sampler, by generating and evaluating a candidate decision.\n\nThe attribute NumSamples is the size of the sampled model used to generate a candidate decision. The attribute NumUpperTrials is the number of sampled models and the attribute NumEvalSamples is the size of the evaluation models. The confidence level can be set through the Confidence attribute.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.upper_confidence_interval-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractVector{T} where T, AbstractSampler, Vararg{Any, N} where N}","page":"Public interface","title":"StochasticPrograms.upper_confidence_interval","text":"upper_confidence_interval(stochasticmodel::StochasticModel{2}, decision::AbstractVector, sampler::AbstractSampler; kw...)\n\nGenerate a confidence interval around an upper bound of the expected value of decision in the two-stage stochasticmodel at the current confidence level, over the scenario distribution induced by sampler.\n\nThe attribute NumUpperTrials is the number of sampled models and the attribute NumEvalSamples is the size of the evaluation models. The confidence level can be set through the Confidence attribute.\n\nThe supplied decision must match the defined decision variables in stochasticmodel. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#Stochastic-programming-constructs","page":"Public interface","title":"Stochastic programming constructs","text":"","category":"section"},{"location":"library/public/","page":"Public interface","title":"Public interface","text":"Modules = [StochasticPrograms]\nPages   = [\"spconstructs.jl\"]","category":"page"},{"location":"library/public/#StochasticPrograms.DEP-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.DEP","text":"DEP(stochasticprogram::TwoStageStochasticProgram; optimizer = nothing)\n\nGenerate the deterministically equivalent problem (DEP) of the two-stage stochasticprogram, unless a cached version already exists.\n\nIn other words, generate the extended form the stochasticprogram as a single JuMP model. Optionally, a capable optimizer can be supplied to DEP.\n\nSee also: VRP, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EEV-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.EEV","text":"EEV(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler)\n\nApproximately calculate the expected value of the expected value decision (EEV) of the two-stage stochasticmodel to the current confidence level, over the scenario distribution induced by sampler.\n\nThe attribute NumEEVSamples is the size of the sampled models used in the eev calculation. The confidence level can be set through the Confidence attribute.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: EVP, EV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EEV-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.EEV","text":"EEV(stochasticprogram::TwoStageStochasticProgram)\n\nCalculate the expected value of the expected value solution (EEV) of the two-stage stochasticprogram.\n\nIn other words, evaluate the EVP decision. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: EVP, EV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EV-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.EV","text":"EV(stochasticprogram::TwoStageStochasticProgram)\n\nCalculate the optimal value of the EVP of the two-stage stochasticprogram.\n\nIf an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: EVP, expected_value_decision, EEV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EVP-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.EVP","text":"EVP(stochasticprogram::TwoStageStochasticProgram; optimizer = nothing)\n\nGenerate the expected value problem (EVP) of the two-stage stochasticprogram.\n\nIn other words, generate a wait-and-see model corresponding to the expected scenario over all available scenarios in stochasticprogram. Optionally, a capable optimizer can be supplied to WS.\n\nSee also: expected_value_decision, EEV, EV, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EVPI-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.EVPI","text":"EVPI(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler)\n\nApproximately calculate the expected value of perfect information (EVPI) of the two-stage stochasticmodel to the current confidence level, over the scenario distribution induced by sampler.\n\nIn other words, calculate confidence intervals around VRP and EWS. If they do not overlap, the EVPI is statistically significant, and a confidence interval is calculated and returned.\n\nThe attribute NumSamples is the size of the sampled models used to generate the interval and generally governs how tight it is. The attribute NumLowerTrials is the number of sampled models used in the lower bound calculation and the attribute NumUpperTrials is the number of sampled models used in the upper bound calculation. The attribute NumEvalSamples is the size of the sampled models used in the upper bound calculation. The confidence level can be set through the Confidence attribute.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: VRP, EWS, VSS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EVPI-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.EVPI","text":"EVPI(stochasticprogram::TwoStageStochasticProgram)\n\nCalculate the expected value of perfect information (EVPI) of the two-stage stochasticprogram.\n\nIn other words, calculate the gap between VRP and EWS. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: VRP, EWS, VSS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EWS-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.EWS","text":"EWS(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler)\n\nApproximately calculate the expected wait-and-see result (EWS) of the two-stage stochasticmodel to the current confidence level, over the scenario distribution induced by sampler.\n\nThe attribute NumEWSSamples is the size of the sampled models used to generate the interval and generally governs how tight it is. The confidence level can be set through the Confidence attribute.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: VRP, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.EWS-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.EWS","text":"EWS(stochasticprogram::StochasticProgram)\n\nCalculate the expected wait-and-see result (EWS) of the stochasticprogram.\n\nIn other words, calculate the expectated result of all possible wait-and-see models, using the provided scenarios in stochasticprogram.\n\nIf an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: VRP, WS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VRP-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.VRP","text":"VRP(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler; confidence = 0.95)\n\nReturn a confidence interval around the value of the recouse problem (VRP) of stochasticmodel to the given confidence level.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: EVPI, VSS, EWS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VRP-Tuple{StochasticProgram}","page":"Public interface","title":"StochasticPrograms.VRP","text":"VRP(stochasticprogram::StochasticProgram)\n\nCalculate the value of the recourse problem (VRP) in stochasticprogram.\n\nIn other words, optimize the stochastic program and return the optimal value.\n\nIf an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: EVPI, EWS\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VSS-Tuple{StochasticModel{2, P} where P<:Tuple{StageParameters, StageParameters}, AbstractSampler}","page":"Public interface","title":"StochasticPrograms.VSS","text":"VSS(stochasticmodel::StochasticModel{2}, sampler::AbstractSampler)\n\nApproximately calculate the value of the stochastic solution (VSS) of the two-stage stochasticmodel to the current confidence level, over the scenario distribution induced by sampler.\n\nIn other words, calculate confidence intervals around EEV and VRP. If they do not overlap, the VSS is statistically significant, and a confidence interval is calculated and returned. Ñ is the number of samples in the out-of-sample evaluation of EEV.\n\nThe attribute NumSamples is the size of the sampled models used to generate the interval and generally governs how tight it is. The same size is used to generate the expected value decision. The attribute NumLowerTrials is the number of sampled models used in the lower bound calculation and the attribute NumUpperTrials is the number of sampled models used in the upper bound calculation. The attribute NumEvalSamples is the size of the sampled models used in the upper bound calculation and the attribute [NumEEVSamples] is the size of the sampled models used in the EEV calculation. The confidence level can be set through the Confidence attribute.\n\nIf a sample-based optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: VRP, EEV, EVPI\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.VSS-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.VSS","text":"VSS(stochasticprogram::TwoStageStochasticProgram)\n\nCalculate the value of the stochastic solution (VSS) of the two-stage stochasticprogram.\n\nIn other words, calculate the gap between EEV and VRP. If an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.WS-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.WS","text":"WS(stochasticprogram::TwoStageStochasticProgram, scenario::AbstractScenarioaData; optimizer = nothing)\n\nGenerate a wait-and-see (WS) model of the two-stage stochasticprogram, corresponding to scenario.\n\nIn other words, generate the first stage and the second stage of the stochasticprogram as if scenario is known to occur. Optionally, a capable optimizer can be supplied to WS.\n\nSee also: DEP, EVP\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.expected_value_decision-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}}","page":"Public interface","title":"StochasticPrograms.expected_value_decision","text":"expected_value_decision(stochasticprogram::TwoStageStochasticProgram)\n\nCalculate the optimizer of the EVP of the two-stage stochasticprogram.\n\nIf an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: EVP, EV, EEV\n\n\n\n\n\n","category":"method"},{"location":"library/public/#StochasticPrograms.wait_and_see_decision-Tuple{StochasticProgram{2, S, ST} where {S<:Tuple{StochasticPrograms.Stage, StochasticPrograms.Stage}, ST<:AbstractStochasticStructure{2}}, AbstractScenario}","page":"Public interface","title":"StochasticPrograms.wait_and_see_decision","text":"wait_and_see_decision(stochasticprogram::TwoStageStochasticProgram, scenario::AbstractScenario, optimizer_constructor = nothing)\n\nCalculate the optimizer of the wait-and-see (WS) model of the two-stage stochasticprogram, corresponding to scenario.\n\nIf an optimizer has not been set yet (see set_optimizer), a NoOptimizer error is thrown.\n\nSee also: WS\n\n\n\n\n\n","category":"method"},{"location":"manual/structuredsolvers/#Structured-solvers","page":"Structured solvers","title":"Structured solvers","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"A stochastic program has a structure that can be exploited in solver algorithms through decomposition. This can heavily reduce the computation time required to optimize the stochastic program, compared to solving the extensive form directly. Moreover, a distributed stochastic program is by definition decomposed and a structured solver that can operate in parallel will be much more efficient.","category":"page"},{"location":"manual/structuredsolvers/#Stochastic-structure","page":"Structured solvers","title":"Stochastic structure","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"StochasticPrograms provides multiple alternatives for how finite stochastic program instances are represented and stored in memory. We refer to these alternatives as the structure of the stochastic program. Certain operations are more efficient in certain structures. We summarize the available structures in the following. For code examples, see the Quick start.","category":"page"},{"location":"manual/structuredsolvers/#Deterministic-Equivalent","page":"Structured solvers","title":"Deterministic Equivalent","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The DeterministicEquivalent, instantiated using Deterministic, is the default structure in StochasticPrograms. A stochastic program instance is represented by one large optimization problem that considers all scenarios at once. This structure is supported by any standard third-party MathOptInterface solver. Moreover, it is the most efficient choice for smaller problem sizes.","category":"page"},{"location":"manual/structuredsolvers/#Stage-decomposition","page":"Structured solvers","title":"Stage-decomposition","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The StageDecompositionStructure, instantiated using StageDecomposition or Vertical, decomposes the stochastic program into stages. It is the structure induced by the L-shaped and quasi-gradient algorithms and is more efficient for larger instances. It is especially efficient for decision evaluation problems, such as when calculating VSS. In a distributed environment, the subproblems in later stages can be distributed on worker nodes. This distributed stage-decomposition structure is instantiated using either DistributedStageDecomposition or DistributedVertical.","category":"page"},{"location":"manual/structuredsolvers/#Scenario-decomposition","page":"Structured solvers","title":"Scenario-decomposition","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The ScenarioDecompositionStructure, instantiated using ScenarioDecomposition or Horizontal, decomposes the stochastic program by scenarios. It is the structure induced by the progressive-hedging algorithm and is more efficient for larger instances. It is especially efficient for solving wait-and-see type problems, such as when calculating EVPI. In a distributed environment, the subproblems in later stages can be distributed on worker nodes. This distributed scenario-decomposition structure is instantiated using either DistributedScenarioDecomposition or DistributedHorizontal.","category":"page"},{"location":"manual/structuredsolvers/#Solver-interface","page":"Structured solvers","title":"Solver interface","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The structured solver interface mimics that of MathOptInterface, and it needs to be implemented by any structured solver to be compatible with StochasticPrograms. We distinguish between structure-exploiting solvers for solving finite stochastic programs and sampled-bases solvers for approximately solving stochastic models, even though they can be based on the same algorithm.","category":"page"},{"location":"manual/structuredsolvers/#Stochastic-programs","page":"Structured solvers","title":"Stochastic programs","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"To interface a new structure-exploiting solver, define a AbstractStructuredOptimizer object. To follow the style of MathOptInterface, name the object Optimizer so that users can set_optimizer(sp, SOLVER_MODULE.Optimizer) to use the optimizer. Next, implement load_structure!, which loads any stochastic structure supported by the solver. Define supports_structure to inform StochasticPrograms what structures are supported by the solver and define default_structure to ensure that an appropriate structure is used when instantiating a stochastic program with your solver. After a call to load_structure!, optimize! should solve the stochastic program or otherwise throw UnloadedStructure. After a call to optimize!, calling restore_structure! should remove any changes made to the model by the solver. For example, calling this method after running an L-shaped procedure removes all cutting planes from the first stage. The solver should at least be able to return a solver for solving subproblems through subproblem_optimizer and can also optionally support a master_optimizer. Finally, the solver can optionally support a custom solver name through optimizer_name.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"In summary, the solver interface that a new AbstractStructuredOptimizer should adhere to is given by","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"supports_structure\ndefault_structure\ncheck_loadable\nload_structure!\nrestore_structure!\noptimize!\noptimizer_name\nnum_iterations\nmaster_optimizer\nsubproblem_optimizer","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"In addition, the solver can include support getting/setting/modiyfing any MathOptInterface attributes. See also the subtypes of AbstractStructuredOptimizerAttribute for special attributes defined by the framework. For more thorough examples of implementing the structured solver interface, see the L-shaped or Progressive-hedging implementations.","category":"page"},{"location":"manual/structuredsolvers/#Stochastic-models","page":"Structured solvers","title":"Stochastic models","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"To interface a new structure-exploiting solver, define a AbstractSampledOptimizer object. Next, implement load_model!, which should load a provided StochasticModel object into the solver. A call to optimize! should then approximately solve the model. Afterwards, a call to optimal_instance can optionally return a sampled instance with an optimal value within the confidence interval of the solution. Again, a custom solver name can be provided in optimizer_name.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"In summary, the solver interface that a new AbstractSampledOptimizer should adhere to is given by","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"load_model!\noptimize!\noptimizer_name\noptimal_instance","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"See also the subtypes of AbstractSampledOptimizerAttribute for special attributes defined by the framework. For a thorough example, consider the SAA implementation.","category":"page"},{"location":"manual/structuredsolvers/#Crash-methods","page":"Structured solvers","title":"Crash methods","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Some structure-exploiting algorithms benefit from crash starting in various ways. For example, a good initial guess in combination with a regularization procedure can improve convergence.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following Crash methods are available in StochasticPrograms:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Crash.None (default)\nCrash.EVP\nCrash.Scenario\nCrash.PreSolve\nCrash.Custom","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"To use a Crash procedure, set the crash keyword in the call to optimize!.","category":"page"},{"location":"manual/structuredsolvers/#L-shaped-solvers","page":"Structured solvers","title":"L-shaped solvers","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"StochasticPrograms includes a collection of L-shaped algorithms in the submodule LShaped. All algorithm variants are based on the L-shaped method by Van Slyke and Wets. LShaped interfaces with StochasticPrograms through the structured solver interface. Every algorithm variant is an instance of the functor object LShapedAlgorithm, and are instanced using the API object LShaped.Optimizer. Consider subtypes of AbstractLShapedAttribute for a summary of available configurations.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As an example, we solve the simple problem introduced in the Quick start:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"set_optimizer(sp, LShaped.Optimizer)\nset_optimizer_attribute(sp, MasterOptimizer(), GLPK.Optimizer)\nset_optimizer_attribute(sp, SubProblemOptimizer(), GLPK.Optimizer)\noptimize!(sp)","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"L-Shaped Gap  Time: 0:00:02 (6 iterations)\n  Objective:       -855.8333333333358\n  Gap:             0.0\n  Number of cuts:  8\n  Iterations:      6","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that an LP capable AbstractOptimizer is required to solve emerging subproblems.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"LShaped uses a policy-based design. This allows combinatorially many variants of the original algorithm to be instanced by supplying linearly many policies to the factory function LShaped.Optimizer. We briefly describe the various policies in the following.","category":"page"},{"location":"manual/structuredsolvers/#Feasibility-cuts","page":"Structured solvers","title":"Feasibility cuts","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"If the stochastic program does not have complete, or relatively complete, recourse then subproblems may be infeasible for some master iterates. Convergence can be maintained through the use of feasibility cuts. To reduce overhead and memory usage, feasibility issues are ignored by default. If you know that your problem does not have complete recourse, or if the algorithm terminates due to infeasibility, set the FeasibilityStrategy attribute to FeasibilityCuts:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"set_optimizer_attribute(sp, FeasibilityStrategy(), FeasibilityCuts())\noptimize!(sp)","category":"page"},{"location":"manual/structuredsolvers/#Integer-strategies","page":"Structured solvers","title":"Integer strategies","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"If the stochastic program includes binary or integer decisions, especially in the second-stage, special strategies are required for the L-shaped algorihm to stay effective. Integer restrictions are ignored by default and the procedure will generally not converge if they are present.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"set_optimizer_attribute(sp, IntegerStrategy(), CombinatorialCuts())\noptimize!(sp)","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following L-shaped integer strategies are available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"IgnoreIntegers (default)\nCombinatorialCuts\nConvexification","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that CombinatorialCuts requires a third-party subproblem optimizer with integer capabilities. Convexification solves linear subproblems through cutting-plane approximations, determined by a convexification strategy. The currently availiable strategies are:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Gomory\nLiftAndProject\nCuttingPlaneTree","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The Gomory strategy is cheapest and often the most effective. The latter strategies involves solving extra linear programs using a supplied optimizer.","category":"page"},{"location":"manual/structuredsolvers/#Regularization","page":"Structured solvers","title":"Regularization","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"A Regularization procedure can improve algorithm performance. The idea is to limit the candidate search to a neighborhood of the current best iterate in the master problem. This can result in more effective cutting planes. Moreover, regularization enables warm-starting the L-shaped procedure with Crash decisions. Regularization is enabled by setting the Regularizer attribute.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following L-shaped regularizations are available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"NoRegularization (default)\nRegularizedDecomposition\nTrustRegion\nLevelSet","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that RegularizedDecomposition and LevelSet require an AbstractOptimizer capable of solving QP problems. Alternatively, the quadratic proximal term in the objective can be approximated through various linear terms. This is achieved by supplying a AbstractPenaltyTerm object through penaltyterm in either RD or LV. The alternatives are given below:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Quadratic (default)\nInfNorm\nManhattanNorm","category":"page"},{"location":"manual/structuredsolvers/#Aggregation","page":"Structured solvers","title":"Aggregation","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Cut aggregation can be applied to reduce communication latency and load imbalance. This can yield major performance improvements in distributed settings. Aggregation is enabled by setting the Aggregator attribute.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following aggregation schemes are available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"NoAggregation (default)\nPartialAggregation\nDynamicAggregation\nClusterAggregation\nHybridAggregation","category":"page"},{"location":"manual/structuredsolvers/#Consolidation","page":"Structured solvers","title":"Consolidation","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"If cut consolidation is enabled, cuts from previous iterations that are no longer active are aggregated to reduce the size of the master. Consolidation is enabled by setting the Consolidator attribute to Consolidate. See Consolidation for further details.","category":"page"},{"location":"manual/structuredsolvers/#Execution","page":"Structured solvers","title":"Execution","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"There are three currently available modes of execution:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Serial (default)\nSynchronous\nAsynchronous","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Running a distributed L-shaped algorithm, either synchronously or asynchronously, required adding Julia worker cores with [addprocs]. The execution policy can be changed by setting the Execution attribute.","category":"page"},{"location":"manual/structuredsolvers/#Solver-examples","page":"Structured solvers","title":"Solver examples","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Below are a few examples of L-shaped algorithm with advanced policy configurations:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"function tr_with_partial_aggregation()\n    opt = LShaped.Optimizer()\n    MOI.set(opt, MasterOptimizer(), GLPK.Optimizer)\n    MOI.set(opt, SubProblemOptimizer(), GLPK.Optimizer)\n    MOI.set(opt, Regularizer(), TR()) # Set regularization to trust-region\n    MOI.set(opt, Aggregator(), PartialAggregate(36)) # Use partial aggregation in groups of 36 cuts\n    return opt\nend\n\nfunction lv_with_kmedoids_aggregation_and_consolidation()\n    opt = LShaped.Optimizer()\n    MOI.set(opt, MasterOptimizer(), Gurobi.Optimizer)\n    MOI.set(opt, SubProblemOptimizer(), Gurobi.Optimizer)\n    MOI.set(opt, Regularizer(), LV()) # Use level-set regularization\n    MOI.set(opt, Aggregator(), ClusterAggregate(Kmedoids(20, distance = angular_distance) # Use K-medoids cluster aggregation\n    MOI.set(opt, Consolidator(), Consolidate()) # Enable consolidation\n    return opt\nend\n\n# Employ advanced solvers\nset_optimizer(sp, tr_with_partial_aggregation)\noptimize!(sp)\n\nset_optimizer(sp, lv_with_kmedoids_aggregation_and_consolidation)\noptimize!(sp)","category":"page"},{"location":"manual/structuredsolvers/#References","page":"Structured solvers","title":"References","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Van Slyke, R. and Wets, R. (1969), L-Shaped Linear Programs with Applications to Optimal Control and Stochastic Programming, SIAM Journal on Applied Mathematics, vol. 17, no. 4, pp. 638-663.\nRuszczyński, A (1986), A regularized decomposition method for minimizing a sum of polyhedral functions, Mathematical Programming, vol. 35, no. 3, pp. 309-333.\nLinderoth, J. and Wright, S. (2003), Decomposition Algorithms for Stochastic Programming on a Computational Grid, Computational Optimization and Applications, vol. 24, no. 2-3, pp. 207-250.\nFábián, C. and Szőke, Z. (2006), Solving two-stage stochastic programming problems with level decomposition, Computational Management Science, vol. 4, no. 4, pp. 313-353.\nWolf, C. and Koberstein, A. (2013), Dynamic sequencing and cut con-solidation for the parallel hybrid-cut nested l-shaped method, European Journal of Operational Research, vol. 230, no. 1, pp. 143-156.\nBiel, M. and Johansson, M. (2018), Distributed L-shaped Algorithms in Julia, 2018 IEEE/ACM Parallel Applications Workshop, Alternatives To MPI (PAW-ATM).\nBiel, M. and Johansson, M. (2019), Dynamic cut aggregation in L-shaped algorithms, arXiv preprint arXiv:1910.13752.","category":"page"},{"location":"manual/structuredsolvers/#Progressive-hedging-solvers","page":"Structured solvers","title":"Progressive-hedging solvers","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"StochasticPrograms also includes a collection of progressive-hedging algorithms in the submodule ProgressiveHedging. All algorithm variants are based on the original progressive-hedging algorithm by Rockafellar and Wets. ProgressiveHedging interfaces with StochasticPrograms through the structured solver interface. Every algorithm variant is an instance of the functor object ProgressiveHedgingAlgorithm, and are instanced using the API object ProgressiveHedging.Optimizer. Consider subtypes of AbstractProgressiveHedgingAttribute for a summary of available configurations.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As an example, we solve the simple problem introduced in the Quick start:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"set_optimizer(sp, ProgressiveHedging.Optimizer)\nset_optimizer_attribute(sp, SubProblemOptimizer(), Ipopt.Optimizer)\noptimize!(sp)","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Progressive Hedging Time: 0:00:05 (303 iterations)\n  Objective:   -855.5842547490254\n  Primal gap:  7.2622997706326046e-6\n  Dual gap:    8.749063651111478e-6\n  Iterations:  302","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that an QP/LP capable AbstractOptimizer is required to solve emerging subproblems.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"ProgressiveHedging also uses a policy-based design. See ProgressiveHedging.Optimizer for options. We briefly describe the various policies in the following.","category":"page"},{"location":"manual/structuredsolvers/#Penalty","page":"Structured solvers","title":"Penalty","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"There are two options for the penalty parameter used in the progressive-hedging algorithm. The alternatives are","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Fixed (default)\nAdaptive","category":"page"},{"location":"manual/structuredsolvers/#Execution-2","page":"Structured solvers","title":"Execution","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The same execution policies as for LShaped are available in ProgressiveHedging, i.e.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Serial (default)\nSynchronous\nAsynchronous","category":"page"},{"location":"manual/structuredsolvers/#Penalty-term","page":"Structured solvers","title":"Penalty term","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As with the L-shaped variants with quadratic 2-norm terms, the 2-norm term in progressive-hedging subproblems can be approximated. This enables the use of an AbstractOptimizer that only support linear problems. The alternatives are as before:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Quadratic (default)\nInfNorm\nManhattanNorm","category":"page"},{"location":"manual/structuredsolvers/#References-2","page":"Structured solvers","title":"References","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"R. T. Rockafellar and Roger J.-B. Wets (1991), Scenarios and Policy Aggregation in Optimization Under Uncertainty, Mathematics of Operations Research, vol. 16, no. 1, pp. 119-147.\nZehtabian. S and Bastin. F (2016), Penalty parameter update strategies in progressive hedging algorithm","category":"page"},{"location":"manual/structuredsolvers/#Quasi-gradient-solvers","page":"Structured solvers","title":"Quasi-gradient solvers","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"StochasticPrograms also includes a collection of quasi-gradient algorithms in the submodule QuasiGradient. All algorithm variants are based on projected subgradient methods. QuasiGradient interfaces with StochasticPrograms through the structured solver interface. Every algorithm variant is an instance of the functor object QuasiGradientAlgorithm, and are instanced using the API object QuasiGradient.Optimizer. Consider subtypes of AbstractQuasiGradientAttribute for a summary of available configurations.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"As an example, we solve the simple problem introduced in the Quick start:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"set_optimizer(sp, QuasiGradient.Optimizer)\nset_optimizer_attribute(sp, MasterOptimizer(), Ipopt.Optimizer)\nset_optimizer_attribute(sp, SubProblemOptimizer(), GLPK.Optimizer)\noptimize!(sp)","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Quasi-gradient Progress 100%|██████████████████████████████████████████████████████████████████| Time: 0:00:08\n  Objective:   -854.9691513511461\n  ||∇Q||::     34.64997546896679\n  Iterations:  1000","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Note, that an QP/LP capable AbstractOptimizer is required to solve emerging subproblems.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"QuasiGradient also uses a policy-based design. See QuasiGradient.Optimizer for options. We briefly describe the various policies in the following.","category":"page"},{"location":"manual/structuredsolvers/#Step-size","page":"Structured solvers","title":"Step-size","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following step-size policies are available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Constant (default)\nDiminishing\nPolyak\nBB","category":"page"},{"location":"manual/structuredsolvers/#Prox","page":"Structured solvers","title":"Prox","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"A proximal step is taken each iteration in a projected (sub)gradient method. The following prox steps are currently available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"NoProx\nPolyhedron (default)\nAndersonAcceleration\nNesterov\nDryFriction","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"At the very least, a polyhedral projection on the first-stage constraints are required when solving stochastic programs.","category":"page"},{"location":"manual/structuredsolvers/#Termination","page":"Structured solvers","title":"Termination","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following termination criteria are available:","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"AfterMaximumIterations (default)\nAtObjectiveThreshold\nAtGradientThreshold","category":"page"},{"location":"manual/structuredsolvers/#Execution-3","page":"Structured solvers","title":"Execution","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"The following execution policies are available in QuasiGradient, i.e.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Serial (default)\nSynchronous","category":"page"},{"location":"manual/structuredsolvers/#Smoothing","page":"Structured solvers","title":"Smoothing","text":"","category":"section"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"A smooth approximation can be applied to the subproblems to enable gradient-based method that require smooth properties. The smoothing procedure is based on Moreau envelopes.","category":"page"},{"location":"manual/structuredsolvers/","page":"Structured solvers","title":"Structured solvers","text":"Unaltered (default)\nSmoothed","category":"page"}]
}
