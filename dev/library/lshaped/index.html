<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>L-shaped solvers · StochasticPrograms.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StochasticPrograms.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/quickstart/">Quick start</a></li><li><a class="tocitem" href="../../manual/data/">Stochastic data</a></li><li><a class="tocitem" href="../../manual/model/">Stochastic models</a></li><li><a class="tocitem" href="../../manual/decisions/">Decision API</a></li><li><a class="tocitem" href="../../manual/distributed/">Distributed stochastic programs</a></li><li><a class="tocitem" href="../../manual/structuredsolvers/">Structured solvers</a></li><li><a class="tocitem" href="../../manual/examples/">Examples</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public interface</a></li><li><a class="tocitem" href="../solverinterface/">Solver interface</a></li><li><a class="tocitem" href="../crash/">Crash</a></li><li class="is-active"><a class="tocitem" href>L-shaped solvers</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Execution"><span>Execution</span></a></li><li><a class="tocitem" href="#Feasibility"><span>Feasibility</span></a></li><li><a class="tocitem" href="#Integers"><span>Integers</span></a></li><li><a class="tocitem" href="#Regularization"><span>Regularization</span></a></li><li><a class="tocitem" href="#Aggregation"><span>Aggregation</span></a></li><li><a class="tocitem" href="#Consolidation"><span>Consolidation</span></a></li></ul></li><li><a class="tocitem" href="../progressivehedging/">Progressive-hedging solvers</a></li><li><a class="tocitem" href="../quasigradient/">Quasi-gradient solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>L-shaped solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>L-shaped solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/library/lshaped.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="L-shaped-solvers"><a class="docs-heading-anchor" href="#L-shaped-solvers">L-shaped solvers</a><a id="L-shaped-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#L-shaped-solvers" title="Permalink"></a></h1><p>Documentation for <code>StochasticPrograms.jl</code>&#39;s L-shaped solvers.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#StochasticPrograms.LShaped.AbstractLShapedAttribute"><code>StochasticPrograms.LShaped.AbstractLShapedAttribute</code></a></li><li><a href="#StochasticPrograms.LShaped.Aggregate"><code>StochasticPrograms.LShaped.Aggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.AggregationParameter"><code>StochasticPrograms.LShaped.AggregationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.Aggregator"><code>StochasticPrograms.LShaped.Aggregator</code></a></li><li><a href="#StochasticPrograms.LShaped.AsynchronousExecution"><code>StochasticPrograms.LShaped.AsynchronousExecution</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterAggregate"><code>StochasticPrograms.LShaped.ClusterAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterAggregation"><code>StochasticPrograms.LShaped.ClusterAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}"><code>StochasticPrograms.LShaped.ClusterByReference</code></a></li><li><a href="#StochasticPrograms.LShaped.CombinatorialCuts"><code>StochasticPrograms.LShaped.CombinatorialCuts</code></a></li><li><a href="#StochasticPrograms.LShaped.CombinatorialCutsMaster"><code>StochasticPrograms.LShaped.CombinatorialCutsMaster</code></a></li><li><a href="#StochasticPrograms.LShaped.CombinatorialCutsWorker"><code>StochasticPrograms.LShaped.CombinatorialCutsWorker</code></a></li><li><a href="#StochasticPrograms.LShaped.Consolidate"><code>StochasticPrograms.LShaped.Consolidate</code></a></li><li><a href="#StochasticPrograms.LShaped.Consolidation"><code>StochasticPrograms.LShaped.Consolidation</code></a></li><li><a href="#StochasticPrograms.LShaped.ConsolidationParameter"><code>StochasticPrograms.LShaped.ConsolidationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.Consolidator"><code>StochasticPrograms.LShaped.Consolidator</code></a></li><li><a href="#StochasticPrograms.LShaped.Convexification"><code>StochasticPrograms.LShaped.Convexification</code></a></li><li><a href="#StochasticPrograms.LShaped.ConvexificationMaster"><code>StochasticPrograms.LShaped.ConvexificationMaster</code></a></li><li><a href="#StochasticPrograms.LShaped.ConvexificationWorker"><code>StochasticPrograms.LShaped.ConvexificationWorker</code></a></li><li><a href="#StochasticPrograms.LShaped.DontAggregate"><code>StochasticPrograms.LShaped.DontAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.DontConsolidate"><code>StochasticPrograms.LShaped.DontConsolidate</code></a></li><li><a href="#StochasticPrograms.LShaped.DontRegularize"><code>StochasticPrograms.LShaped.DontRegularize</code></a></li><li><a href="#StochasticPrograms.LShaped.DynamicAggregate"><code>StochasticPrograms.LShaped.DynamicAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.DynamicAggregation"><code>StochasticPrograms.LShaped.DynamicAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.FeasibilityCuts"><code>StochasticPrograms.LShaped.FeasibilityCuts</code></a></li><li><a href="#StochasticPrograms.LShaped.FeasibilityCutsMaster"><code>StochasticPrograms.LShaped.FeasibilityCutsMaster</code></a></li><li><a href="#StochasticPrograms.LShaped.FeasibilityCutsWorker"><code>StochasticPrograms.LShaped.FeasibilityCutsWorker</code></a></li><li><a href="#StochasticPrograms.LShaped.FeasibilityStrategy"><code>StochasticPrograms.LShaped.FeasibilityStrategy</code></a></li><li><a href="#StochasticPrograms.LShaped.GranulatedAggregate"><code>StochasticPrograms.LShaped.GranulatedAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.GranulatedAggregation"><code>StochasticPrograms.LShaped.GranulatedAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.Hierarchical"><code>StochasticPrograms.LShaped.Hierarchical</code></a></li><li><a href="#StochasticPrograms.LShaped.HybridAggregate"><code>StochasticPrograms.LShaped.HybridAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.HybridAggregation"><code>StochasticPrograms.LShaped.HybridAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.IgnoreFeasibility"><code>StochasticPrograms.LShaped.IgnoreFeasibility</code></a></li><li><a href="#StochasticPrograms.LShaped.IgnoreIntegers"><code>StochasticPrograms.LShaped.IgnoreIntegers</code></a></li><li><a href="#StochasticPrograms.LShaped.IntegerParameter"><code>StochasticPrograms.LShaped.IntegerParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.IntegerStrategy"><code>StochasticPrograms.LShaped.IntegerStrategy</code></a></li><li><a href="#StochasticPrograms.LShaped.Kmedoids"><code>StochasticPrograms.LShaped.Kmedoids</code></a></li><li><a href="#StochasticPrograms.LShaped.LShapedAlgorithm"><code>StochasticPrograms.LShaped.LShapedAlgorithm</code></a></li><li><a href="#StochasticPrograms.LShaped.LV"><code>StochasticPrograms.LShaped.LV</code></a></li><li><a href="#StochasticPrograms.LShaped.LevelSet"><code>StochasticPrograms.LShaped.LevelSet</code></a></li><li><a href="#StochasticPrograms.LShaped.NoAggregation"><code>StochasticPrograms.LShaped.NoAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.NoConsolidation"><code>StochasticPrograms.LShaped.NoConsolidation</code></a></li><li><a href="#StochasticPrograms.LShaped.NoFeasibilityAlgorithm"><code>StochasticPrograms.LShaped.NoFeasibilityAlgorithm</code></a></li><li><a href="#StochasticPrograms.LShaped.NoIntegerAlgorithm"><code>StochasticPrograms.LShaped.NoIntegerAlgorithm</code></a></li><li><a href="#StochasticPrograms.LShaped.NoRegularization"><code>StochasticPrograms.LShaped.NoRegularization</code></a></li><li><a href="#StochasticPrograms.LShaped.Optimizer"><code>StochasticPrograms.LShaped.Optimizer</code></a></li><li><a href="#StochasticPrograms.LShaped.PartialAggregate"><code>StochasticPrograms.LShaped.PartialAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.PartialAggregation"><code>StochasticPrograms.LShaped.PartialAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.RD"><code>StochasticPrograms.LShaped.RD</code></a></li><li><a href="#StochasticPrograms.LShaped.RawConsolidationParameter"><code>StochasticPrograms.LShaped.RawConsolidationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.RawIntegerParameter"><code>StochasticPrograms.LShaped.RawIntegerParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.RawRegularizationParameter"><code>StochasticPrograms.LShaped.RawRegularizationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.RegularizationParameter"><code>StochasticPrograms.LShaped.RegularizationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>StochasticPrograms.LShaped.RegularizedDecomposition</code></a></li><li><a href="#StochasticPrograms.LShaped.Regularizer"><code>StochasticPrograms.LShaped.Regularizer</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectClosest"><code>StochasticPrograms.LShaped.SelectClosest</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectDecaying"><code>StochasticPrograms.LShaped.SelectDecaying</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectRandom"><code>StochasticPrograms.LShaped.SelectRandom</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectUniform"><code>StochasticPrograms.LShaped.SelectUniform</code></a></li><li><a href="#StochasticPrograms.LShaped.SerialExecution"><code>StochasticPrograms.LShaped.SerialExecution</code></a></li><li><a href="#StochasticPrograms.LShaped.SortByReference"><code>StochasticPrograms.LShaped.SortByReference</code></a></li><li><a href="#StochasticPrograms.LShaped.StaticCluster"><code>StochasticPrograms.LShaped.StaticCluster</code></a></li><li><a href="#StochasticPrograms.LShaped.SynchronousExecution"><code>StochasticPrograms.LShaped.SynchronousExecution</code></a></li><li><a href="#StochasticPrograms.LShaped.TR"><code>StochasticPrograms.LShaped.TR</code></a></li><li><a href="#StochasticPrograms.LShaped.TrustRegion"><code>StochasticPrograms.LShaped.TrustRegion</code></a></li><li><a href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T&lt;:AbstractFloat"><code>StochasticPrograms.LShaped.FullAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>StochasticPrograms.LShaped.absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>StochasticPrograms.LShaped.angular_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.at_tolerance-Tuple{}"><code>StochasticPrograms.LShaped.at_tolerance</code></a></li><li><a href="#StochasticPrograms.LShaped.get_aggregation_attribute-Tuple{StochasticProgram, String}"><code>StochasticPrograms.LShaped.get_aggregation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.get_consolidation_attribute-Tuple{StochasticProgram, String}"><code>StochasticPrograms.LShaped.get_consolidation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.get_regularization_attribute-Tuple{StochasticProgram, String}"><code>StochasticPrograms.LShaped.get_regularization_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attribute"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attributes"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attribute"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attributes"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attribute"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attributes"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.spatioangular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>StochasticPrograms.LShaped.spatioangular_distance</code></a></li></ul><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.LShapedAlgorithm" href="#StochasticPrograms.LShaped.LShapedAlgorithm"><code>StochasticPrograms.LShaped.LShapedAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LShapedAlgorithm</code></pre><p>Functor object for the L-shaped algorithm.</p><p>...</p><p><strong>Algorithm parameters</strong></p><ul><li><code>τ::AbstractFloat = 1e-6</code>: Relative tolerance for convergence checks.</li><li><code>debug::Bool = false</code>: Specifies if extra information should be saved for debugging purposes. Defaults to false for memory efficiency.</li><li><code>cut_scaling::AbstractFloat = 1.0</code>: Rescaling factor for cutting planes to improve numerical stability.</li><li><code>log::Bool = true</code>: Specifices if L-shaped procedure should be logged on standard output or not.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/solver.jl#L44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.AbstractLShapedAttribute" href="#StochasticPrograms.LShaped.AbstractLShapedAttribute"><code>StochasticPrograms.LShaped.AbstractLShapedAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLShapedAttribute</code></pre><p>Abstract supertype for attribute objects specific to the L-shaped algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.AggregationParameter" href="#StochasticPrograms.LShaped.AggregationParameter"><code>StochasticPrograms.LShaped.AggregationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AggregationParameter</code></pre><p>Abstract supertype for aggregation-specific attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Aggregator" href="#StochasticPrograms.LShaped.Aggregator"><code>StochasticPrograms.LShaped.Aggregator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Aggregator</code></pre><p>An optimizer attribute for specifying an aggregation procedure to be used in the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.NoAggregation"><code>NoAggregation</code></a>:  Multi-cut L-shaped algorithm (default)</li><li><a href="#StochasticPrograms.LShaped.PartialAggregation"><code>PartialAggregation</code></a>:  ?PartialAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T&lt;:AbstractFloat"><code>FullAggregation</code></a>:  ?FullAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.DynamicAggregation"><code>DynamicAggregation</code></a>:  ?DynamicAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.ClusterAggregation"><code>ClusterAggregation</code></a>:  ?ClusterAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.HybridAggregation"><code>HybridAggregation</code></a>:  ?HybridAggregation for parameter descriptions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ConsolidationParameter" href="#StochasticPrograms.LShaped.ConsolidationParameter"><code>StochasticPrograms.LShaped.ConsolidationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConsolidationParameter</code></pre><p>Abstract supertype for consolidation-specific attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Consolidator" href="#StochasticPrograms.LShaped.Consolidator"><code>StochasticPrograms.LShaped.Consolidator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Consolidator</code></pre><p>An optimizer attribute for specifying a consolidation procedure to be used in the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.NoConsolidation"><code>NoConsolidation</code></a> (default)</li><li><a href="#StochasticPrograms.LShaped.Consolidation"><code>Consolidation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L74-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.FeasibilityStrategy" href="#StochasticPrograms.LShaped.FeasibilityStrategy"><code>StochasticPrograms.LShaped.FeasibilityStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeasibilityStrategy</code></pre><p>An optimizer attribute for specifying a strategy for dealing with second-stage feasibility the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.IgnoreFeasibility"><code>IgnoreFeasibility</code></a> (default)</li><li><a href="#StochasticPrograms.LShaped.FeasibilityCuts"><code>FeasibilityCuts</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.IntegerParameter" href="#StochasticPrograms.LShaped.IntegerParameter"><code>StochasticPrograms.LShaped.IntegerParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntegerParameter</code></pre><p>Abstract supertype for integer-specific attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.IntegerStrategy" href="#StochasticPrograms.LShaped.IntegerStrategy"><code>StochasticPrograms.LShaped.IntegerStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IntegerStrategy</code></pre><p>An optimizer attribute for specifying a strategy for dealing with integers the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.IgnoreIntegers"><code>IgnoreIntegers</code></a> (default)</li><li><a href="#StochasticPrograms.LShaped.CombinatorialCuts"><code>CombinatorialCuts</code></a></li><li><a href="#StochasticPrograms.LShaped.Convexification"><code>Convexification</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RegularizationParameter" href="#StochasticPrograms.LShaped.RegularizationParameter"><code>StochasticPrograms.LShaped.RegularizationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizationParameter</code></pre><p>Abstract supertype for regularization-specific attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Regularizer" href="#StochasticPrograms.LShaped.Regularizer"><code>StochasticPrograms.LShaped.Regularizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Regularizer</code></pre><p>An optimizer attribute for specifying a regularization procedure to be used in the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.NoRegularization"><code>NoRegularization</code></a>:  L-shaped algorithm (default)</li><li><a href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>RegularizedDecomposition</code></a>:  Regularized decomposition ?RegularizedDecomposition for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.TrustRegion"><code>TrustRegion</code></a>:  Trust-region ?TrustRegion for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.LevelSet"><code>LevelSet</code></a>:  Level-set ?LevelSet for parameter descriptions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/attributes.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Optimizer" href="#StochasticPrograms.LShaped.Optimizer"><code>StochasticPrograms.LShaped.Optimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Optimizer(; &lt;keyword arguments&gt;)</code></pre><p>Return an L-shaped optimizer. ...</p><p><strong>Arguments</strong></p><ul><li><code>master_optimizer::AbstractOptimizer</code>: MathOptInterface solver capable of solving linear (and possibly quadratic) programs.</li><li><code>subproblem_optimizer::AbstractOptimizer</code>: Optionally specify a different solver for the subproblems.</li><li><code>feasibility_cuts::Bool = false</code>: Specify if feasibility cuts should be used</li><li><code>regularize::AbstractRegularizer = DontRegularize()</code>: Specify regularization procedure (DontRegularize, RegularizedDecomposition/RD/WithRegularizedDecomposition, TrustRegion/TR/WithTrustRegion, LevelSet/LV/WithLevelSets).</li><li><code>aggregate::AbstractAggregator = DontAggregate()</code>: Specify aggregation procedure (DontAggregate, Aggregate, PartialAggregate, DynamicAggregate, ClusterAggregate, GranulatedAggregate, HybridAggregate)</li><li><code>consolidate::AbstractConsolidator = DontConsolidate()</code>: Specify consolidation procedure (DontConsolidate, Consolidate)</li><li><code>execution::Execution = Serial</code>: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.</li><li>&lt;keyword arguments&gt;: Algorithm specific parameters, See <code>?LShaped</code> for list of possible arguments and default values.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L23-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.get_aggregation_attribute-Tuple{StochasticProgram, String}" href="#StochasticPrograms.LShaped.get_aggregation_attribute-Tuple{StochasticProgram, String}"><code>StochasticPrograms.LShaped.get_aggregation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_aggregation_attribute(stochasticprogram::StochasticProgram, name::String)</code></pre><p>Return the value associated with the aggregation-specific attribute named <code>name</code> in <code>stochasticprogram</code>.</p><p>See also: <a href="#StochasticPrograms.LShaped.set_aggregation_attribute"><code>set_aggregation_attribute</code></a>, <a href="#StochasticPrograms.LShaped.set_aggregation_attributes"><code>set_aggregation_attributes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L623-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.get_consolidation_attribute-Tuple{StochasticProgram, String}" href="#StochasticPrograms.LShaped.get_consolidation_attribute-Tuple{StochasticProgram, String}"><code>StochasticPrograms.LShaped.get_consolidation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_consolidation_attribute(stochasticprogram::StochasticProgram, name::String)</code></pre><p>Return the value associated with the consolidation-specific attribute named <code>name</code> in <code>stochasticprogram</code>.</p><p>See also: <a href="#StochasticPrograms.LShaped.set_consolidation_attribute"><code>set_consolidation_attribute</code></a>, <a href="#StochasticPrograms.LShaped.set_consolidation_attributes"><code>set_consolidation_attributes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L659-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.get_regularization_attribute-Tuple{StochasticProgram, String}" href="#StochasticPrograms.LShaped.get_regularization_attribute-Tuple{StochasticProgram, String}"><code>StochasticPrograms.LShaped.get_regularization_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_regularization_attribute(stochasticprogram::StochasticProgram, name::String)</code></pre><p>Return the value associated with the regularization-specific attribute named <code>name</code> in <code>stochasticprogram</code>.</p><p>See also: <a href="#StochasticPrograms.LShaped.set_regularization_attribute"><code>set_regularization_attribute</code></a>, <a href="#StochasticPrograms.LShaped.set_regularization_attributes"><code>set_regularization_attributes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L587-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}" href="#StochasticPrograms.LShaped.set_aggregation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_aggregation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the aggregation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L633-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}" href="#StochasticPrograms.LShaped.set_aggregation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_aggregation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_aggregation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L642-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}" href="#StochasticPrograms.LShaped.set_consolidation_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_consolidation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the consolidation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L669-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}" href="#StochasticPrograms.LShaped.set_consolidation_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_consolidation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_consolidation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L678-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}" href="#StochasticPrograms.LShaped.set_regularization_attribute-Tuple{StochasticProgram, Union{String, Symbol}, Any}"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_regularization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the regularization-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L597-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}" href="#StochasticPrograms.LShaped.set_regularization_attributes-Tuple{StochasticProgram, Vararg{Pair, N} where N}"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_regularization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_regularization_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L606-L612">source</a></section></article><h2 id="Execution"><a class="docs-heading-anchor" href="#Execution">Execution</a><a id="Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Execution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SerialExecution" href="#StochasticPrograms.LShaped.SerialExecution"><code>StochasticPrograms.LShaped.SerialExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SerialExecution</code></pre><p>Functor object for using serial execution in a lshaped algorithm. Create by supplying a <a href="../solverinterface/#StochasticPrograms.Serial"><code>Serial</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/execution/serial.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SynchronousExecution" href="#StochasticPrograms.LShaped.SynchronousExecution"><code>StochasticPrograms.LShaped.SynchronousExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SynchronousExecution</code></pre><p>Functor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a <a href="../solverinterface/#StochasticPrograms.Synchronous"><code>Synchronous</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/execution/synchronous.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.AsynchronousExecution" href="#StochasticPrograms.LShaped.AsynchronousExecution"><code>StochasticPrograms.LShaped.AsynchronousExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AsynchronousExecution</code></pre><p>Functor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a <a href="../solverinterface/#StochasticPrograms.Asynchronous"><code>Asynchronous</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/execution/asynchronous.jl#L29-L34">source</a></section></article><h2 id="Feasibility"><a class="docs-heading-anchor" href="#Feasibility">Feasibility</a><a id="Feasibility-1"></a><a class="docs-heading-anchor-permalink" href="#Feasibility" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoFeasibilityAlgorithm" href="#StochasticPrograms.LShaped.NoFeasibilityAlgorithm"><code>StochasticPrograms.LShaped.NoFeasibilityAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoFeasibilityAlgorithm</code></pre><p>Empty functor object for running an L-shaped algorithm without dealing with second-stage feasibility.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/feasibility.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.IgnoreFeasibility" href="#StochasticPrograms.LShaped.IgnoreFeasibility"><code>StochasticPrograms.LShaped.IgnoreFeasibility</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IgnoreFeasibility</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoFeasibilityAlgorithm"><code>NoFeasibilityAlgorithm</code></a>. Passed by default to <code>feasibility_strategy</code> in <code>LShaped.Optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/feasibility.jl#L235-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.FeasibilityCutsMaster" href="#StochasticPrograms.LShaped.FeasibilityCutsMaster"><code>StochasticPrograms.LShaped.FeasibilityCutsMaster</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeasibilityCutsMaster</code></pre><p>Master functor object for using feasibility cuts in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.FeasibilityCuts"><code>FeasibilityCuts</code></a> object through <code>feasibility_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.FeasibilityStrategy"><code>FeasibilityStrategy</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/feasibility.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.FeasibilityCutsWorker" href="#StochasticPrograms.LShaped.FeasibilityCutsWorker"><code>StochasticPrograms.LShaped.FeasibilityCutsWorker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeasibilityCutsWorker</code></pre><p>Worker functor object for using feasibility cuts in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.FeasibilityCuts"><code>FeasibilityCuts</code></a> object through <code>feasibility_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.FeasibilityStrategy"><code>FeasibilityStrategy</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/feasibility.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.FeasibilityCuts" href="#StochasticPrograms.LShaped.FeasibilityCuts"><code>StochasticPrograms.LShaped.FeasibilityCuts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IgnoreFeasibility</code></pre><p>Factory object for using feasibility cuts in an L-shaped algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/types/feasibility.jl#L254-L259">source</a></section></article><h2 id="Integers"><a class="docs-heading-anchor" href="#Integers">Integers</a><a id="Integers-1"></a><a class="docs-heading-anchor-permalink" href="#Integers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RawIntegerParameter" href="#StochasticPrograms.LShaped.RawIntegerParameter"><code>StochasticPrograms.LShaped.RawIntegerParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawIntegerAlgorithmParameter</code></pre><p>An optimizer attribute used for raw parameters of the integer algorithm. Defers to <code>RawParameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/integer.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.IgnoreIntegers" href="#StochasticPrograms.LShaped.IgnoreIntegers"><code>StochasticPrograms.LShaped.IgnoreIntegers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IgnoreIntegers</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoIntegerAlgorithm"><code>NoIntegerAlgorithm</code></a>. Passed by default to <code>integer_strategy</code> in <code>LShaped.Optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/ignore_integers.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoIntegerAlgorithm" href="#StochasticPrograms.LShaped.NoIntegerAlgorithm"><code>StochasticPrograms.LShaped.NoIntegerAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoIntegerAlgorithm</code></pre><p>Empty functor object for running an L-shaped algorithm without dealing with integer variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/ignore_integers.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.CombinatorialCuts" href="#StochasticPrograms.LShaped.CombinatorialCuts"><code>StochasticPrograms.LShaped.CombinatorialCuts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinatorialCuts</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.CombinatorialCuts"><code>CombinatorialCuts</code></a>. Pass to <code>integer_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.IntegerStrategy"><code>IntegerStrategy</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>lower_bound::AbstractFloat = -1e10</code>: Set a lower bound on the second-stage objective, removing the need to approximate it.</li><li><code>alternate::Bool = false</code>: Specify if algorithm should alternate between solving relaxed problems (generating regular optimality cuts) and unrelaxed problems (generating combinatorial cuts)</li><li><code>update_L_every::Integer = 0</code>: Set the frequency at which the lower bound approximation should be updated. Only approximate once if set to zero.</li><li><code>optimizer = nothing</code>: Optionally specify an optimizer used to solve auxilliary problems in the <code>LiftAndProject</code> or <code>CuttingPlaneTree</code> strategies.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/combinatorial_cuts.jl#L256-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.CombinatorialCutsMaster" href="#StochasticPrograms.LShaped.CombinatorialCutsMaster"><code>StochasticPrograms.LShaped.CombinatorialCutsMaster</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinatorialCutsMaster</code></pre><p>Master functor object for using weak optimality cuts in an integer L-shaped algorithm. Requires all first-stage decisions to be binary. Create by supplying a <a href="#StochasticPrograms.LShaped.CombinatorialCuts"><code>CombinatorialCuts</code></a> object through <code>integer_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.IntegerStrategy"><code>IntegerStrategy</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/combinatorial_cuts.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.CombinatorialCutsWorker" href="#StochasticPrograms.LShaped.CombinatorialCutsWorker"><code>StochasticPrograms.LShaped.CombinatorialCutsWorker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinatorialCutsWorker</code></pre><p>Worker functor object for using weak optimality cuts in an integer L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.CombinatorialCuts"><code>CombinatorialCuts</code></a> object through <code>integer_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.IntegerStrategy"><code>IntegerStrategy</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/combinatorial_cuts.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Convexification" href="#StochasticPrograms.LShaped.Convexification"><code>StochasticPrograms.LShaped.Convexification</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Convexification</code></pre><p>Factory object for using convexification to handle integer recourse. Pass to <code>integer_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.IntegerStrategy"><code>IntegerStrategy</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>maximum_iterations::Integer = 1</code>: Determines the number of iterations spent generating cutting-planes each time a subproblem is solved.</li><li><code>strategy::ConvexificationStrategy = Gomory()</code>: Specify convexification strategy (<code>Gomory</code>, <code>LiftAndProject</code>, <code>CuttingPlaneTree</code>)</li><li><code>optimizer = nothing</code>: Optionally specify an optimizer used to solve auxilliary problems in the <code>LiftAndProject</code> or <code>CuttingPlaneTree</code> strategies.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/convexification.jl#L802-L814">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ConvexificationMaster" href="#StochasticPrograms.LShaped.ConvexificationMaster"><code>StochasticPrograms.LShaped.ConvexificationMaster</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvexificationMaster</code></pre><p>Master functor object for using weak optimality cuts in an integer L-shaped algorithm. Requires all first-stage decisions to be binary. Create by supplying a <a href="#StochasticPrograms.LShaped.Convexification"><code>Convexification</code></a> object through <code>integer_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.IntegerStrategy"><code>IntegerStrategy</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/convexification.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ConvexificationWorker" href="#StochasticPrograms.LShaped.ConvexificationWorker"><code>StochasticPrograms.LShaped.ConvexificationWorker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvexificationWorker</code></pre><p>Worker functor object for using weak optimality cuts in an integer L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.Convexification"><code>Convexification</code></a> object through <code>integer_strategy</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.IntegerStrategy"><code>IntegerStrategy</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/integer/convexification.jl#L67-L72">source</a></section></article><h2 id="Regularization"><a class="docs-heading-anchor" href="#Regularization">Regularization</a><a id="Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attribute" href="#StochasticPrograms.LShaped.set_regularization_attribute"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_regularization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the regularization-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L597-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attributes" href="#StochasticPrograms.LShaped.set_regularization_attributes"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_regularization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_regularization_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L606-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RawRegularizationParameter" href="#StochasticPrograms.LShaped.RawRegularizationParameter"><code>StochasticPrograms.LShaped.RawRegularizationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawRegularizationParameter</code></pre><p>An optimizer attribute used for raw parameters of the regularizer. Defers to <code>RawParameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/regularization.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoRegularization" href="#StochasticPrograms.LShaped.NoRegularization"><code>StochasticPrograms.LShaped.NoRegularization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoRegularization</code></pre><p>Empty functor object for running an L-shaped algorithm without regularization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/no_regularization.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DontRegularize" href="#StochasticPrograms.LShaped.DontRegularize"><code>StochasticPrograms.LShaped.DontRegularize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DontRegularize</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoRegularization"><code>NoRegularization</code></a>. Passed by default to <code>regularize</code> in <code>LShaped.Optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/no_regularization.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RegularizedDecomposition" href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>StochasticPrograms.LShaped.RegularizedDecomposition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RegularizedDecomposition</code></pre><p>Functor object for using regularized decomposition regularization in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShaped.RD"><code>RD</code></a> object through <code>regularize</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Regularizer"><code>Regularizer</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>σ::AbstractFloat = 1.0</code>: Initial value of regularization parameter. Controls the relative penalty of the deviation from the current major iterate.</li><li><code>σ̅::AbstractFloat = 4.0</code>: Maximum value of the regularization parameter.</li><li><code>σ̲::AbstractFloat = 0.5</code>: Minimum value of the regularization parameter.</li><li><code>log::Bool = true</code>: Specifices if L-shaped procedure should be logged on standard output or not.</li><li><code>penaltyterm::PenaltyTerm = Quadratic</code>: Specify penaltyterm variant (<a href="../solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a>, <a href="../solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a>, [<code>ManhattanNorm</code>][@ref])</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/rd.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RD" href="#StochasticPrograms.LShaped.RD"><code>StochasticPrograms.LShaped.RD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RD</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>RegularizedDecomposition</code></a>. Pass to <code>regularize</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Regularizer"><code>Regularizer</code></a> attribute. Equivalent factory calls: <code>RD</code>, <code>WithRD</code>, <code>RegularizedDecomposition</code>, <code>WithRegularizedDecomposition</code>. See ?RegularizedDecomposition for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/rd.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.TrustRegion" href="#StochasticPrograms.LShaped.TrustRegion"><code>StochasticPrograms.LShaped.TrustRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TrustRegion</code></pre><p>Functor object for using trust-region regularization in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.TR"><code>TR</code></a> object through <code>regularize</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Regularizer"><code>Regularizer</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>γ::T = 1e-4</code>: Relative tolerance for deciding if a minor iterate should be accepted as a new major iterate.</li><li><code>Δ::AbstractFloat = 1.0</code>: Initial size of ∞-norm trust-region.</li><li><code>Δ̅::AbstractFloat = 1000.0</code>: Maximum size of ∞-norm trust-region.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/tr.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.TR" href="#StochasticPrograms.LShaped.TR"><code>StochasticPrograms.LShaped.TR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TR</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.TrustRegion"><code>TrustRegion</code></a>. Pass to <code>regularize</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Regularizer"><code>Regularizer</code></a> attribute.. Equivalent factory calls: <code>TR</code>, <code>WithTR</code>, <code>TrustRegion</code>, <code>WithTrustRegion</code>. See ?TrustRegion for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/tr.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.LevelSet" href="#StochasticPrograms.LShaped.LevelSet"><code>StochasticPrograms.LShaped.LevelSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LevelSet</code></pre><p>Functor object for using level-set regularization in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShaped.LV"><code>LV</code></a> object through <code>regularize</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Regularizer"><code>Regularizer</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>λ::AbstractFloat = 0.5</code>: Controls the level position L = (1-λ)<em>θ + λ</em>Q̃, a convex combination of the current lower and upper bound.</li><li><code>penaltyterm::PenaltyTerm = Quadratic</code>: Specify penaltyterm variant (<a href="../solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a>, <a href="../solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a>, [<code>ManhattanNorm</code>][@ref])</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/lv.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.LV" href="#StochasticPrograms.LShaped.LV"><code>StochasticPrograms.LShaped.LV</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LV</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.LevelSet"><code>LevelSet</code></a>. Pass to <code>regularize</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Regularizer"><code>Regularizer</code></a> attribute. Equivalent factory calls: <code>LV</code>, <code>WithLV</code>, <code>LevelSet</code>, <code>WithLevelSets</code>. See ?LevelSet for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/regularizers/lv.jl#L240-L245">source</a></section></article><h2 id="Aggregation"><a class="docs-heading-anchor" href="#Aggregation">Aggregation</a><a id="Aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attribute" href="#StochasticPrograms.LShaped.set_aggregation_attribute"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_aggregation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the aggregation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L633-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attributes" href="#StochasticPrograms.LShaped.set_aggregation_attributes"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_aggregation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_aggregation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L642-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DontAggregate" href="#StochasticPrograms.LShaped.DontAggregate"><code>StochasticPrograms.LShaped.DontAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DontAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoAggregation"><code>NoAggregation</code></a>. Passed by default to <code>aggregate</code> in <code>LShaped.Optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/no_aggregation.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoAggregation" href="#StochasticPrograms.LShaped.NoAggregation"><code>StochasticPrograms.LShaped.NoAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoAggregation</code></pre><p>Empty functor object for running an L-shaped algorithm without aggregation (multi-cut L-shaped).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/no_aggregation.jl#L25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Aggregate" href="#StochasticPrograms.LShaped.Aggregate"><code>StochasticPrograms.LShaped.Aggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Aggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T&lt;:AbstractFloat"><code>FullAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by set the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.PartialAggregate" href="#StochasticPrograms.LShaped.PartialAggregate"><code>StochasticPrograms.LShaped.PartialAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.PartialAggregation"><code>PartialAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.  See ?PartialAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.PartialAggregation" href="#StochasticPrograms.LShaped.PartialAggregation"><code>StochasticPrograms.LShaped.PartialAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialAggregation</code></pre><p>Functor object for using partial aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.PartialAggregate"><code>PartialAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>size::Int</code>: Number of cuts in each aggregate</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T&lt;:AbstractFloat" href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer, Integer, Type{T}}} where T&lt;:AbstractFloat"><code>StochasticPrograms.LShaped.FullAggregation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FullAggregation</code></pre><p>Functor object for using complete aggregation in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShaped.Aggregate"><code>Aggregate</code></a> object through <code>aggregate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L43-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DynamicAggregate" href="#StochasticPrograms.LShaped.DynamicAggregate"><code>StochasticPrograms.LShaped.DynamicAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicAggregate(num_aggregates::Integer, rule::AbstractSelectionRule; lock_after::Function = (τ,n)-&gt;false)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.DynamicAggregation"><code>DynamicAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute. See ?DynamicAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/dynamic_aggregation.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DynamicAggregation" href="#StochasticPrograms.LShaped.DynamicAggregation"><code>StochasticPrograms.LShaped.DynamicAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DynamicAggregation</code></pre><p>Functor object for using dynamic aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.DynamicAggregate"><code>DynamicAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>The following selection rules are available</p><ul><li><a href="#StochasticPrograms.LShaped.SelectUniform"><code>SelectUniform</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectDecaying"><code>SelectDecaying</code></a></li><li>[<code>SelectRandom</code>](@ref</li><li><a href="#StochasticPrograms.LShaped.SelectClosest"><code>SelectClosest</code></a></li><li><a href="#StochasticPrograms.LShaped.SortByReference"><code>SortByReference</code></a></li></ul><p>...</p><p><strong>Parameters</strong></p><ul><li><code>num_aggregates::Int</code>: Number of aggregates</li><li><code>rule::SelectionRule</code>: Rule that determines which aggregate an incoming cut should be placed in</li><li><code>lock_after::Function = (τ,n)-&gt;false</code>: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap <code>τ</code> and the number of iterations <code>n</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/dynamic_aggregation.jl#L23-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ClusterAggregate" href="#StochasticPrograms.LShaped.ClusterAggregate"><code>StochasticPrograms.LShaped.ClusterAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClusterAggregate(rule::AbstractClusterRule; lock_after::Function = (τ,n)-&gt;false)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.ClusterAggregation"><code>ClusterAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute. See ?ClusterAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/cluster_aggregation.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ClusterAggregation" href="#StochasticPrograms.LShaped.ClusterAggregation"><code>StochasticPrograms.LShaped.ClusterAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ClusterAggregation</code></pre><p>Functor object for using cluster aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.ClusterAggregate"><code>ClusterAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>The following cluster rules are available</p><ul><li><a href="#StochasticPrograms.LShaped.StaticCluster"><code>StaticCluster</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}"><code>ClusterByReference</code></a></li><li>[<code>Kmedoids</code>](@ref</li><li><a href="#StochasticPrograms.LShaped.Hierarchical"><code>Hierarchical</code></a></li></ul><p>...</p><p><strong>Parameters</strong></p><ul><li><code>rule::ClusterRule</code>: Rule that determines how cuts should be sorted into clusters</li><li><code>lock_after::Function = (τ,n)-&gt;false</code>: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap <code>τ</code> and the number of iterations <code>n</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/cluster_aggregation.jl#L23-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.GranulatedAggregate" href="#StochasticPrograms.LShaped.GranulatedAggregate"><code>StochasticPrograms.LShaped.GranulatedAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GranulatedAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.GranulatedAggregation"><code>GranulatedAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.  See ?GranulatedAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/granulated_aggregation.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.GranulatedAggregation" href="#StochasticPrograms.LShaped.GranulatedAggregation"><code>StochasticPrograms.LShaped.GranulatedAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GranulatedAggregation</code></pre><p>Functor object for using partial aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.GranulatedAggregate"><code>GranulatedAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>size::Int</code>: Number of cuts in each aggregate</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/granulated_aggregation.jl#L23-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.HybridAggregate" href="#StochasticPrograms.LShaped.HybridAggregate"><code>StochasticPrograms.LShaped.HybridAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HybridAggregate(initial::AbstractAggregator, final::AbstractAggregator, τ::AbstractFloat)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.HybridAggregation"><code>HybridAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute. See ?HybridAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/hybrid_aggregation.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.HybridAggregation" href="#StochasticPrograms.LShaped.HybridAggregation"><code>StochasticPrograms.LShaped.HybridAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HybridAggregation</code></pre><p>Functor object for using hybrid aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.HybridAggregate"><code>HybridAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>initial::AbstractAggregator</code>: Initial aggregation scheme</li><li><code>final::AbstractAggregator</code>: Final aggregation scheme</li><li><code>τ::T</code>: The active aggregation scheme is switched from <code>initial</code> to <code>final</code> when the optimality gap decreases below <code>τ</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/hybrid_aggregation.jl#L37-L48">source</a></section></article><h3 id="Selection-rules"><a class="docs-heading-anchor" href="#Selection-rules">Selection rules</a><a id="Selection-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectClosest" href="#StochasticPrograms.LShaped.SelectClosest"><code>StochasticPrograms.LShaped.SelectClosest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SelectClosest(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Incoming cuts are placed into the closest aggregate, according the supplied <code>distance</code> function. An empty aggregate is chosen if no aggregate is within the tolerance <code>τ</code></p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectDecaying" href="#StochasticPrograms.LShaped.SelectDecaying"><code>StochasticPrograms.LShaped.SelectDecaying</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SelectDecaying(T₀::Integer, T̲::Integer = 1, γ::T)</code></pre><p>Behaves like <a href="#StochasticPrograms.LShaped.SelectUniform"><code>SelectUniform</code></a>, but the uniform aggregate size decays by <code>γ</code> each iteration, starting from <code>T₀</code>. <code>T̲</code> is an optional lower bound on the aggregate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectRandom" href="#StochasticPrograms.LShaped.SelectRandom"><code>StochasticPrograms.LShaped.SelectRandom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SelectRandom(max = Inf)</code></pre><p>Incoming cuts are placed into aggregates randomly. An optional maximum number of cuts <code>max</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectUniform" href="#StochasticPrograms.LShaped.SelectUniform"><code>StochasticPrograms.LShaped.SelectUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SelectUniform(n::Integer)</code></pre><p>Incoming cuts are placed into aggregates uniformly, so that each aggregate has at most <code>n</code> cuts. Behaves as <a href="#StochasticPrograms.LShaped.PartialAggregation"><code>PartialAggregation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L29-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SortByReference" href="#StochasticPrograms.LShaped.SortByReference"><code>StochasticPrograms.LShaped.SortByReference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SortByReference(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Incoming cuts are placed into an aggregate based on the distance to a reference cut, according the supplied <code>distance</code> function. Behaves as <a href="#StochasticPrograms.LShaped.SelectClosest"><code>SelectClosest</code></a> if not withing the tolerance <code>τ</code> to the reference cut.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L156-L166">source</a></section></article><h3 id="Cluster-rules"><a class="docs-heading-anchor" href="#Cluster-rules">Cluster rules</a><a id="Cluster-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}" href="#StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}"><code>StochasticPrograms.LShaped.ClusterByReference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ClusterByReference(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Buffered cuts are aggregated if within the tolerance <code>τ</code> to a reference cut, according the supplied <code>distance</code> function. Behaves as multi-cut otherwise.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L68-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Hierarchical" href="#StochasticPrograms.LShaped.Hierarchical"><code>StochasticPrograms.LShaped.Hierarchical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hierarchical(nclusters::Int; distance::Function = absolute_distance, linkage::Symbol = :single)</code></pre><p>Buffered cuts are sorted into <code>nclusters</code> clusters, using a Hierarchical algorithm, with the given <code>linkage</code>, over a generalized <code>distance</code> matrix.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L162-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Kmedoids" href="#StochasticPrograms.LShaped.Kmedoids"><code>StochasticPrograms.LShaped.Kmedoids</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Kmedoids(nclusters::Int; distance::Function = absolute_distance)</code></pre><p>Buffered cuts are sorted into <code>nclusters</code> clusters, using a K-medoids algorithm over a generalized <code>distance</code> matrix.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L108-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.StaticCluster" href="#StochasticPrograms.LShaped.StaticCluster"><code>StochasticPrograms.LShaped.StaticCluster</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StaticCluster(clusters::Vector{Float64})</code></pre><p>Buffered cuts are sorting according to the supplied weights <code>clusters</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L25-L30">source</a></section></article><h3 id="Distance-measures"><a class="docs-heading-anchor" href="#Distance-measures">Distance measures</a><a id="Distance-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-measures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}" href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>StochasticPrograms.LShaped.absolute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">absolute_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Absolute distance between two optimality cuts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}" href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>StochasticPrograms.LShaped.angular_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Angular distance between two optimality cuts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.spatioangular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}" href="#StochasticPrograms.LShaped.spatioangular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}, Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T, A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut, T, A}} where {T, A}}"><code>StochasticPrograms.LShaped.spatioangular_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">spatioangular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Spatioangular distance between two optimality cuts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L57-L62">source</a></section></article><h2 id="Consolidation"><a class="docs-heading-anchor" href="#Consolidation">Consolidation</a><a id="Consolidation-1"></a><a class="docs-heading-anchor-permalink" href="#Consolidation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attribute" href="#StochasticPrograms.LShaped.set_consolidation_attribute"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_consolidation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the consolidation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L669-L674">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attributes" href="#StochasticPrograms.LShaped.set_consolidation_attributes"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_consolidation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_consolidation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/MOI_wrapper.jl#L678-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Consolidate" href="#StochasticPrograms.LShaped.Consolidate"><code>StochasticPrograms.LShaped.Consolidate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Consolidate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.Consolidation"><code>Consolidation</code></a>. Pass to <code>consolidate</code> in <code>LShaped.Optimizer</code> or set the <a href="#StochasticPrograms.LShaped.Consolidator"><code>Consolidator</code></a> attribute. See ?Consolidation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/consolidators/consolidation.jl#L219-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Consolidation" href="#StochasticPrograms.LShaped.Consolidation"><code>StochasticPrograms.LShaped.Consolidation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Consolidation</code></pre><p>Functor object for using consolidation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.Consolidate"><code>Consolidate</code></a> object through <code>consolidate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Consolidator"><code>Consolidator</code></a> attribute.</p><p>...</p><p><strong>Algorithm parameters</strong></p><ul><li><code>tresh::T</code> = 0.95: Relative amount of redundant cuts in a former iteration required to consider the iteration redundant</li><li><code>at::Int = 5.0</code>: Number of times an iteration can be redundant before consolidation is triggered</li><li><code>rebuild::Function = at_tolerance()</code>: Function deciding when the master model should be rebuilt according to performed consolidations</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/consolidators/consolidation.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DontConsolidate" href="#StochasticPrograms.LShaped.DontConsolidate"><code>StochasticPrograms.LShaped.DontConsolidate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DontConsolidate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoConsolidation"><code>NoConsolidation</code></a>. Passed by default to <code>consolidate</code> in <code>LShaped.Optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/consolidators/consolidation.jl#L207-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoConsolidation" href="#StochasticPrograms.LShaped.NoConsolidation"><code>StochasticPrograms.LShaped.NoConsolidation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoConsolidation</code></pre><p>Empty functor object for running the L-shaped algorithm without consolidation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/consolidators/consolidation.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RawConsolidationParameter" href="#StochasticPrograms.LShaped.RawConsolidationParameter"><code>StochasticPrograms.LShaped.RawConsolidationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RawConsolidationParameter</code></pre><p>An optimizer attribute used for raw parameters of the consolidator. Defers to <code>RawParameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/consolidators/consolidation.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.at_tolerance-Tuple{}" href="#StochasticPrograms.LShaped.at_tolerance-Tuple{}"><code>StochasticPrograms.LShaped.at_tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">at_tolerance(τ = 0.4, miniter = 0)</code></pre><p>Rebuild master when at least nconsolidations*<code>miniter</code> iterations has passed and the ratio of number of cuts in the consolidated collection and the number of cuts in the master model has decreased below <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/6a5b16d7c681271f103d2d98c35354c6ddd53dca/src/solvers/structured/lshaped/consolidators/consolidation.jl#L192-L197">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../crash/">« Crash</a><a class="docs-footer-nextpage" href="../progressivehedging/">Progressive-hedging solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Tuesday 3 May 2022 12:27">Tuesday 3 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
