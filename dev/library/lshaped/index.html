<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>L-shaped solvers · StochasticPrograms.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StochasticPrograms.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/quickstart/">Quick start</a></li><li><a class="tocitem" href="../../manual/data/">Stochastic data</a></li><li><a class="tocitem" href="../../manual/model/">Stochastic models</a></li><li><a class="tocitem" href="../../manual/decisions/">Multi-stage decisions</a></li><li><a class="tocitem" href="../../manual/distributed/">Distributed stochastic programs</a></li><li><a class="tocitem" href="../../manual/structuredsolvers/">Structured solvers</a></li><li><a class="tocitem" href="../../manual/examples/">Examples</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../public/">Public interface</a></li><li><a class="tocitem" href="../solverinterface/">Solver interface</a></li><li><a class="tocitem" href="../crash/">Crash</a></li><li class="is-active"><a class="tocitem" href>L-shaped solvers</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li><li><a class="tocitem" href="#Execution"><span>Execution</span></a></li><li><a class="tocitem" href="#Regularization"><span>Regularization</span></a></li><li><a class="tocitem" href="#Aggregation"><span>Aggregation</span></a></li><li><a class="tocitem" href="#Consolidation"><span>Consolidation</span></a></li></ul></li><li><a class="tocitem" href="../progressivehedging/">Progressive-hedging solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>L-shaped solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>L-shaped solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/library/lshaped.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="L-shaped-solvers"><a class="docs-heading-anchor" href="#L-shaped-solvers">L-shaped solvers</a><a id="L-shaped-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#L-shaped-solvers" title="Permalink"></a></h1><p>Documentation for <code>StochasticPrograms.jl</code>&#39;s L-shaped solvers.</p><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#StochasticPrograms.LShaped.AbstractLShapedAttribute"><code>StochasticPrograms.LShaped.AbstractLShapedAttribute</code></a></li><li><a href="#StochasticPrograms.LShaped.Aggregate"><code>StochasticPrograms.LShaped.Aggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.AggregationParameter"><code>StochasticPrograms.LShaped.AggregationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.Aggregator"><code>StochasticPrograms.LShaped.Aggregator</code></a></li><li><a href="#StochasticPrograms.LShaped.AsynchronousExecution"><code>StochasticPrograms.LShaped.AsynchronousExecution</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterAggregate"><code>StochasticPrograms.LShaped.ClusterAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterAggregation"><code>StochasticPrograms.LShaped.ClusterAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}"><code>StochasticPrograms.LShaped.ClusterByReference</code></a></li><li><a href="#StochasticPrograms.LShaped.Consolidate"><code>StochasticPrograms.LShaped.Consolidate</code></a></li><li><a href="#StochasticPrograms.LShaped.Consolidation"><code>StochasticPrograms.LShaped.Consolidation</code></a></li><li><a href="#StochasticPrograms.LShaped.ConsolidationParameter"><code>StochasticPrograms.LShaped.ConsolidationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.Consolidator"><code>StochasticPrograms.LShaped.Consolidator</code></a></li><li><a href="#StochasticPrograms.LShaped.DontAggregate"><code>StochasticPrograms.LShaped.DontAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.DontConsolidate"><code>StochasticPrograms.LShaped.DontConsolidate</code></a></li><li><a href="#StochasticPrograms.LShaped.DontRegularize"><code>StochasticPrograms.LShaped.DontRegularize</code></a></li><li><a href="#StochasticPrograms.LShaped.DynamicAggregate"><code>StochasticPrograms.LShaped.DynamicAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.DynamicAggregation"><code>StochasticPrograms.LShaped.DynamicAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.FeasibilityCuts"><code>StochasticPrograms.LShaped.FeasibilityCuts</code></a></li><li><a href="#StochasticPrograms.LShaped.GranulatedAggregate"><code>StochasticPrograms.LShaped.GranulatedAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.GranulatedAggregation"><code>StochasticPrograms.LShaped.GranulatedAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.Hierarchical"><code>StochasticPrograms.LShaped.Hierarchical</code></a></li><li><a href="#StochasticPrograms.LShaped.HybridAggregate"><code>StochasticPrograms.LShaped.HybridAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.HybridAggregation"><code>StochasticPrograms.LShaped.HybridAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.Kmedoids"><code>StochasticPrograms.LShaped.Kmedoids</code></a></li><li><a href="#StochasticPrograms.LShaped.LShapedAlgorithm"><code>StochasticPrograms.LShaped.LShapedAlgorithm</code></a></li><li><a href="#StochasticPrograms.LShaped.LV"><code>StochasticPrograms.LShaped.LV</code></a></li><li><a href="#StochasticPrograms.LShaped.LevelSet"><code>StochasticPrograms.LShaped.LevelSet</code></a></li><li><a href="#StochasticPrograms.LShaped.NoAggregation"><code>StochasticPrograms.LShaped.NoAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.NoConsolidation"><code>StochasticPrograms.LShaped.NoConsolidation</code></a></li><li><a href="#StochasticPrograms.LShaped.NoRegularization"><code>StochasticPrograms.LShaped.NoRegularization</code></a></li><li><a href="#StochasticPrograms.LShaped.Optimizer"><code>StochasticPrograms.LShaped.Optimizer</code></a></li><li><a href="#StochasticPrograms.LShaped.PartialAggregate"><code>StochasticPrograms.LShaped.PartialAggregate</code></a></li><li><a href="#StochasticPrograms.LShaped.PartialAggregation"><code>StochasticPrograms.LShaped.PartialAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.RD"><code>StochasticPrograms.LShaped.RD</code></a></li><li><a href="#StochasticPrograms.LShaped.RawConsolidationParameter"><code>StochasticPrograms.LShaped.RawConsolidationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.RawRegularizationParameter"><code>StochasticPrograms.LShaped.RawRegularizationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.RegularizationParameter"><code>StochasticPrograms.LShaped.RegularizationParameter</code></a></li><li><a href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>StochasticPrograms.LShaped.RegularizedDecomposition</code></a></li><li><a href="#StochasticPrograms.LShaped.Regularizer"><code>StochasticPrograms.LShaped.Regularizer</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectClosest"><code>StochasticPrograms.LShaped.SelectClosest</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectDecaying"><code>StochasticPrograms.LShaped.SelectDecaying</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectRandom"><code>StochasticPrograms.LShaped.SelectRandom</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectUniform"><code>StochasticPrograms.LShaped.SelectUniform</code></a></li><li><a href="#StochasticPrograms.LShaped.SerialExecution"><code>StochasticPrograms.LShaped.SerialExecution</code></a></li><li><a href="#StochasticPrograms.LShaped.SortByReference"><code>StochasticPrograms.LShaped.SortByReference</code></a></li><li><a href="#StochasticPrograms.LShaped.StaticCluster"><code>StochasticPrograms.LShaped.StaticCluster</code></a></li><li><a href="#StochasticPrograms.LShaped.SynchronousExecution"><code>StochasticPrograms.LShaped.SynchronousExecution</code></a></li><li><a href="#StochasticPrograms.LShaped.TR"><code>StochasticPrograms.LShaped.TR</code></a></li><li><a href="#StochasticPrograms.LShaped.TrustRegion"><code>StochasticPrograms.LShaped.TrustRegion</code></a></li><li><a href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>StochasticPrograms.LShaped.FullAggregation</code></a></li><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShaped.absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShaped.angular_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.at_tolerance-Tuple{}"><code>StochasticPrograms.LShaped.at_tolerance</code></a></li><li><a href="#StochasticPrograms.LShaped.get_aggregation_attribute-Tuple{StochasticProgram,String}"><code>StochasticPrograms.LShaped.get_aggregation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.get_consolidation_attribute-Tuple{StochasticProgram,String}"><code>StochasticPrograms.LShaped.get_consolidation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.get_regularization_attribute-Tuple{StochasticProgram,String}"><code>StochasticPrograms.LShaped.get_regularization_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attribute"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_aggregation_attributes"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attribute"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_consolidation_attributes"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attribute"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attributes"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.set_regularization_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a></li><li><a href="#StochasticPrograms.LShaped.spatioangular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShaped.spatioangular_distance</code></a></li></ul><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.LShapedAlgorithm" href="#StochasticPrograms.LShaped.LShapedAlgorithm"><code>StochasticPrograms.LShaped.LShapedAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LShapedAlgorithm</code></pre><p>Functor object for the L-shaped algorithm.</p><p>...</p><p><strong>Algorithm parameters</strong></p><ul><li><code>τ::AbstractFloat = 1e-6</code>: Relative tolerance for convergence checks.</li><li><code>debug::Bool = false</code>: Specifies if extra information should be saved for debugging purposes. Defaults to false for memory efficiency.</li><li><code>cut_scaling::AbstractFloat = 1.0</code>: Rescaling factor for cutting planes to improve numerical stability.</li><li><code>log::Bool = true</code>: Specifices if L-shaped procedure should be logged on standard output or not.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/solver.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.AbstractLShapedAttribute" href="#StochasticPrograms.LShaped.AbstractLShapedAttribute"><code>StochasticPrograms.LShaped.AbstractLShapedAttribute</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractLShapedAttribute</code></pre><p>Abstract supertype for attribute objects specific to the L-shaped algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.AggregationParameter" href="#StochasticPrograms.LShaped.AggregationParameter"><code>StochasticPrograms.LShaped.AggregationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AggregationParameter</code></pre><p>Abstract supertype for aggregation-specific attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Aggregator" href="#StochasticPrograms.LShaped.Aggregator"><code>StochasticPrograms.LShaped.Aggregator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Aggregator</code></pre><p>An optimizer attribute for specifying an aggregation procedure to be used in the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.NoAggregation"><code>NoAggregation</code></a>:  Multi-cut L-shaped algorithm (default)</li><li><a href="#StochasticPrograms.LShaped.PartialAggregation"><code>PartialAggregation</code></a>:  ?PartialAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>FullAggregation</code></a>:  ?FullAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.DynamicAggregation"><code>DynamicAggregation</code></a>:  ?DynamicAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.ClusterAggregation"><code>ClusterAggregation</code></a>:  ?ClusterAggregation for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.HybridAggregation"><code>HybridAggregation</code></a>:  ?HybridAggregation for parameter descriptions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L26-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ConsolidationParameter" href="#StochasticPrograms.LShaped.ConsolidationParameter"><code>StochasticPrograms.LShaped.ConsolidationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConsolidationParameter</code></pre><p>Abstract supertype for consolidation-specific attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Consolidator" href="#StochasticPrograms.LShaped.Consolidator"><code>StochasticPrograms.LShaped.Consolidator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Consolidator</code></pre><p>An optimizer attribute for specifying a consolidation procedure to be used in the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.NoConsolidation"><code>NoConsolidation</code></a></li><li><a href="#StochasticPrograms.LShaped.Consolidation"><code>Consolidation</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.FeasibilityCuts" href="#StochasticPrograms.LShaped.FeasibilityCuts"><code>StochasticPrograms.LShaped.FeasibilityCuts</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FeasibilityCuts</code></pre><p>An optimizer attribute for specifying if feasibility cuts should be used in the L-shaped algorithm. Options are <code>true</code> of <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RegularizationParameter" href="#StochasticPrograms.LShaped.RegularizationParameter"><code>StochasticPrograms.LShaped.RegularizationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizationParameter</code></pre><p>Abstract supertype for regularization-specific attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Regularizer" href="#StochasticPrograms.LShaped.Regularizer"><code>StochasticPrograms.LShaped.Regularizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Regularizer</code></pre><p>An optimizer attribute for specifying a regularization procedure to be used in the L-shaped algorithm. Options are:</p><ul><li><a href="#StochasticPrograms.LShaped.NoRegularization"><code>NoRegularization</code></a>:  L-shaped algorithm (default)</li><li><a href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>RegularizedDecomposition</code></a>:  Regularized decomposition ?RegularizedDecomposition for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.TrustRegion"><code>TrustRegion</code></a>:  Trust-region ?TrustRegion for parameter descriptions.</li><li><a href="#StochasticPrograms.LShaped.LevelSet"><code>LevelSet</code></a>:  Level-set ?LevelSet for parameter descriptions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/types/attributes.jl#L15-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Optimizer" href="#StochasticPrograms.LShaped.Optimizer"><code>StochasticPrograms.LShaped.Optimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Optimizer(; &lt;keyword arguments&gt;)</code></pre><p>Return an L-shaped optimizer. ...</p><p><strong>Arguments</strong></p><ul><li><code>master_optimizer::AbstractOptimizer</code>: MathOptInterface solver capable of solving linear (and possibly quadratic) programs.</li><li><code>subproblem_optimizer::AbstractOptimizer</code>: Optionally specify a different solver for the subproblems.</li><li><code>feasibility_cuts::Bool = false</code>: Specify if feasibility cuts should be used</li><li><code>regularize::AbstractRegularizer = DontRegularize()</code>: Specify regularization procedure (DontRegularize, RegularizedDecomposition/RD/WithRegularizedDecomposition, TrustRegion/TR/WithTrustRegion, LevelSet/LV/WithLevelSets).</li><li><code>aggregate::AbstractAggregator = DontAggregate()</code>: Specify aggregation procedure (DontAggregate, Aggregate, PartialAggregate, DynamicAggregate, ClusterAggregate, GranulatedAggregate, HybridAggregate)</li><li><code>consolidate::AbstractConsolidator = DontConsolidate()</code>: Specify consolidation procedure (DontConsolidate, Consolidate)</li><li><code>execution::Execution = Serial</code>: Specify how algorithm should be executed (Serial, Synchronous, Asynchronous). Distributed variants requires worker cores.</li><li>&lt;keyword arguments&gt;: Algorithm specific parameters, See <code>?LShaped</code> for list of possible arguments and default values.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.get_aggregation_attribute-Tuple{StochasticProgram,String}" href="#StochasticPrograms.LShaped.get_aggregation_attribute-Tuple{StochasticProgram,String}"><code>StochasticPrograms.LShaped.get_aggregation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_aggregation_attribute(stochasticprogram::StochasticProgram, name::String)</code></pre><p>Return the value associated with the aggregation-specific attribute named <code>name</code> in <code>stochasticprogram</code>.</p><p>See also: <a href="#StochasticPrograms.LShaped.set_aggregation_attribute"><code>set_aggregation_attribute</code></a>, <a href="#StochasticPrograms.LShaped.set_aggregation_attributes"><code>set_aggregation_attributes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L579-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.get_consolidation_attribute-Tuple{StochasticProgram,String}" href="#StochasticPrograms.LShaped.get_consolidation_attribute-Tuple{StochasticProgram,String}"><code>StochasticPrograms.LShaped.get_consolidation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_consolidation_attribute(stochasticprogram::StochasticProgram, name::String)</code></pre><p>Return the value associated with the consolidation-specific attribute named <code>name</code> in <code>stochasticprogram</code>.</p><p>See also: <a href="#StochasticPrograms.LShaped.set_consolidation_attribute"><code>set_consolidation_attribute</code></a>, <a href="#StochasticPrograms.LShaped.set_consolidation_attributes"><code>set_consolidation_attributes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L615-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.get_regularization_attribute-Tuple{StochasticProgram,String}" href="#StochasticPrograms.LShaped.get_regularization_attribute-Tuple{StochasticProgram,String}"><code>StochasticPrograms.LShaped.get_regularization_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_regularization_attribute(stochasticprogram::StochasticProgram, name::String)</code></pre><p>Return the value associated with the regularization-specific attribute named <code>name</code> in <code>stochasticprogram</code>.</p><p>See also: <a href="#StochasticPrograms.LShaped.set_regularization_attribute"><code>set_regularization_attribute</code></a>, <a href="#StochasticPrograms.LShaped.set_regularization_attributes"><code>set_regularization_attributes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L543-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}" href="#StochasticPrograms.LShaped.set_aggregation_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_aggregation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the aggregation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L589-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}" href="#StochasticPrograms.LShaped.set_aggregation_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_aggregation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_aggregation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L598-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}" href="#StochasticPrograms.LShaped.set_consolidation_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_consolidation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the consolidation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L625-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}" href="#StochasticPrograms.LShaped.set_consolidation_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_consolidation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_consolidation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L634-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}" href="#StochasticPrograms.LShaped.set_regularization_attribute-Tuple{StochasticProgram,Union{String, Symbol},Any}"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_regularization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the regularization-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}" href="#StochasticPrograms.LShaped.set_regularization_attributes-Tuple{StochasticProgram,Vararg{Pair,N} where N}"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_regularization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_regularization_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L562-L568">source</a></section></article><h2 id="Execution"><a class="docs-heading-anchor" href="#Execution">Execution</a><a id="Execution-1"></a><a class="docs-heading-anchor-permalink" href="#Execution" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SerialExecution" href="#StochasticPrograms.LShaped.SerialExecution"><code>StochasticPrograms.LShaped.SerialExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SerialExecution</code></pre><p>Functor object for using serial execution in a lshaped algorithm. Create by supplying a <a href="../solverinterface/#StochasticPrograms.Serial"><code>Serial</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/execution/serial.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SynchronousExecution" href="#StochasticPrograms.LShaped.SynchronousExecution"><code>StochasticPrograms.LShaped.SynchronousExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SynchronousExecution</code></pre><p>Functor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a <a href="../solverinterface/#StochasticPrograms.Synchronous"><code>Synchronous</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/execution/synchronous.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.AsynchronousExecution" href="#StochasticPrograms.LShaped.AsynchronousExecution"><code>StochasticPrograms.LShaped.AsynchronousExecution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AsynchronousExecution</code></pre><p>Functor object for using synchronous execution in an L-shaped algorithm (assuming multiple Julia cores are available). Create by supplying a <a href="../solverinterface/#StochasticPrograms.Asynchronous"><code>Asynchronous</code></a> object through <code>execution</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/execution/asynchronous.jl#L7-L12">source</a></section></article><h2 id="Regularization"><a class="docs-heading-anchor" href="#Regularization">Regularization</a><a id="Regularization-1"></a><a class="docs-heading-anchor-permalink" href="#Regularization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attribute" href="#StochasticPrograms.LShaped.set_regularization_attribute"><code>StochasticPrograms.LShaped.set_regularization_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_regularization_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the regularization-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_regularization_attributes" href="#StochasticPrograms.LShaped.set_regularization_attributes"><code>StochasticPrograms.LShaped.set_regularization_attributes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_regularization_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_regularization_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L562-L568">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RawRegularizationParameter" href="#StochasticPrograms.LShaped.RawRegularizationParameter"><code>StochasticPrograms.LShaped.RawRegularizationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawRegularizationParameter</code></pre><p>An optimizer attribute used for raw parameters of the regularizer. Defers to <code>RawParameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/regularization.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoRegularization" href="#StochasticPrograms.LShaped.NoRegularization"><code>StochasticPrograms.LShaped.NoRegularization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoRegularization</code></pre><p>Empty functor object for running an L-shaped algorithm without regularization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/no_regularization.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DontRegularize" href="#StochasticPrograms.LShaped.DontRegularize"><code>StochasticPrograms.LShaped.DontRegularize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DontRegularize</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoRegularization"><code>NoRegularization</code></a>. Passed by default to <code>regularize</code> in the <code>LShapedSolver</code> factory function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/no_regularization.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RegularizedDecomposition" href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>StochasticPrograms.LShaped.RegularizedDecomposition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RegularizedDecomposition</code></pre><p>Functor object for using regularized decomposition regularization in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShaped.RD"><code>RD</code></a> object through <code>regularize</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>σ::AbstractFloat = 1.0</code>: Initial value of regularization parameter. Controls the relative penalty of the deviation from the current major iterate.</li><li><code>σ̅::AbstractFloat = 4.0</code>: Maximum value of the regularization parameter.</li><li><code>σ̲::AbstractFloat = 0.5</code>: Minimum value of the regularization parameter.</li><li><code>log::Bool = true</code>: Specifices if L-shaped procedure should be logged on standard output or not.</li><li><code>penaltyterm::PenaltyTerm = Quadratic</code>: Specify penaltyterm variant (<a href="../solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a>, <a href="../solverinterface/#StochasticPrograms.Linearized"><code>Linearized</code></a>, <a href="../solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a>, [<code>ManhattanNorm</code>][@ref])</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/rd.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RD" href="#StochasticPrograms.LShaped.RD"><code>StochasticPrograms.LShaped.RD</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RD</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.RegularizedDecomposition"><code>RegularizedDecomposition</code></a>. Pass to <code>regularize</code> in the <code>LShapedSolver</code> factory function. Equivalent factory calls: <code>RD</code>, <code>WithRD</code>, <code>RegularizedDecomposition</code>, <code>WithRegularizedDecomposition</code>. See ?RegularizedDecomposition for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/rd.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.TrustRegion" href="#StochasticPrograms.LShaped.TrustRegion"><code>StochasticPrograms.LShaped.TrustRegion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TrustRegion</code></pre><p>Functor object for using trust-region regularization in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.TR"><code>TR</code></a> object through <code>regularize</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>γ::T = 1e-4</code>: Relative tolerance for deciding if a minor iterate should be accepted as a new major iterate.</li><li><code>Δ::AbstractFloat = 1.0</code>: Initial size of ∞-norm trust-region.</li><li><code>Δ̅::AbstractFloat = 1000.0</code>: Maximum size of ∞-norm trust-region.</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/tr.jl#L20-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.TR" href="#StochasticPrograms.LShaped.TR"><code>StochasticPrograms.LShaped.TR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TR</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.TrustRegion"><code>TrustRegion</code></a>. Pass to <code>regularize</code> in the <code>LShapedSolver</code> factory function. Equivalent factory calls: <code>TR</code>, <code>WithTR</code>, <code>TrustRegion</code>, <code>WithTrustRegion</code>. See ?TrustRegion for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/tr.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.LevelSet" href="#StochasticPrograms.LShaped.LevelSet"><code>StochasticPrograms.LShaped.LevelSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LevelSet</code></pre><p>Functor object for using level-set regularization in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShaped.LV"><code>LV</code></a> object through <code>regularize</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>λ::AbstractFloat = 0.5</code>: Controls the level position L = (1-λ)<em>θ + λ</em>Q̃, a convex combination of the current lower and upper bound.</li><li><code>penaltyterm::PenaltyTerm = Quadratic</code>: Specify penaltyterm variant (<a href="../solverinterface/#StochasticPrograms.Quadratic"><code>Quadratic</code></a>, <a href="../solverinterface/#StochasticPrograms.Linearized"><code>Linearized</code></a>, <a href="../solverinterface/#StochasticPrograms.InfNorm"><code>InfNorm</code></a>, [<code>ManhattanNorm</code>][@ref])</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/lv.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.LV" href="#StochasticPrograms.LShaped.LV"><code>StochasticPrograms.LShaped.LV</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LV</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.LevelSet"><code>LevelSet</code></a>. Pass to <code>regularize</code> in the <code>LShapedSolver</code> factory function. Equivalent factory calls: <code>LV</code>, <code>WithLV</code>, <code>LevelSet</code>, <code>WithLevelSets</code>. See ?LevelSet for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/regularizers/lv.jl#L209-L214">source</a></section></article><h2 id="Aggregation"><a class="docs-heading-anchor" href="#Aggregation">Aggregation</a><a id="Aggregation-1"></a><a class="docs-heading-anchor-permalink" href="#Aggregation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attribute" href="#StochasticPrograms.LShaped.set_aggregation_attribute"><code>StochasticPrograms.LShaped.set_aggregation_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_aggregation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the aggregation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L589-L594">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_aggregation_attributes" href="#StochasticPrograms.LShaped.set_aggregation_attributes"><code>StochasticPrograms.LShaped.set_aggregation_attributes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_aggregation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_aggregation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L598-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DontAggregate" href="#StochasticPrograms.LShaped.DontAggregate"><code>StochasticPrograms.LShaped.DontAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DontAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoAggregation"><code>NoAggregation</code></a>. Passed by default to <code>aggregate</code> in <code>LShaped.Optimizer</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/no_aggregation.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoAggregation" href="#StochasticPrograms.LShaped.NoAggregation"><code>StochasticPrograms.LShaped.NoAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoAggregation</code></pre><p>Empty functor object for running an L-shaped algorithm without aggregation (multi-cut L-shaped).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/no_aggregation.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Aggregate" href="#StochasticPrograms.LShaped.Aggregate"><code>StochasticPrograms.LShaped.Aggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Aggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>FullAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.PartialAggregate" href="#StochasticPrograms.LShaped.PartialAggregate"><code>StochasticPrograms.LShaped.PartialAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartialAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.PartialAggregation"><code>PartialAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.  See ?PartialAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.PartialAggregation" href="#StochasticPrograms.LShaped.PartialAggregation"><code>StochasticPrograms.LShaped.PartialAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PartialAggregation</code></pre><p>Functor object for using partial aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.PartialAggregate"><code>PartialAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>size::Int</code>: Number of cuts in each aggregate</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat" href="#StochasticPrograms.LShaped.FullAggregation-Union{Tuple{T}, Tuple{Integer,Integer,Type{T}}} where T&lt;:AbstractFloat"><code>StochasticPrograms.LShaped.FullAggregation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">FullAggregation</code></pre><p>Functor object for using complete aggregation in an L-shaped algorithm. Create by supplying an <a href="#StochasticPrograms.LShaped.Aggregate"><code>Aggregate</code></a> object through <code>aggregate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/partial_aggregation.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DynamicAggregate" href="#StochasticPrograms.LShaped.DynamicAggregate"><code>StochasticPrograms.LShaped.DynamicAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DynamicAggregate(num_aggregates::Integer, rule::AbstractSelectionRule; lock_after::Function = (τ,n)-&gt;false)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.DynamicAggregation"><code>DynamicAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute. See ?DynamicAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/dynamic_aggregation.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DynamicAggregation" href="#StochasticPrograms.LShaped.DynamicAggregation"><code>StochasticPrograms.LShaped.DynamicAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DynamicAggregation</code></pre><p>Functor object for using dynamic aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.DynamicAggregate"><code>DynamicAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>The following selection rules are available</p><ul><li><a href="#StochasticPrograms.LShaped.SelectUniform"><code>SelectUniform</code></a></li><li><a href="#StochasticPrograms.LShaped.SelectDecaying"><code>SelectDecaying</code></a></li><li>[<code>SelectRandom</code>](@ref</li><li><a href="#StochasticPrograms.LShaped.SelectClosest"><code>SelectClosest</code></a></li><li><a href="#StochasticPrograms.LShaped.SortByReference"><code>SortByReference</code></a></li></ul><p>...</p><p><strong>Parameters</strong></p><ul><li><code>num_aggregates::Int</code>: Number of aggregates</li><li><code>rule::SelectionRule</code>: Rule that determines which aggregate an incoming cut should be placed in</li><li><code>lock_after::Function = (τ,n)-&gt;false</code>: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap <code>τ</code> and the number of iterations <code>n</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/dynamic_aggregation.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ClusterAggregate" href="#StochasticPrograms.LShaped.ClusterAggregate"><code>StochasticPrograms.LShaped.ClusterAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterAggregate(rule::AbstractClusterRule; lock_after::Function = (τ,n)-&gt;false)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.ClusterAggregation"><code>ClusterAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute. See ?ClusterAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/cluster_aggregation.jl#L130-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ClusterAggregation" href="#StochasticPrograms.LShaped.ClusterAggregation"><code>StochasticPrograms.LShaped.ClusterAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ClusterAggregation</code></pre><p>Functor object for using cluster aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.ClusterAggregate"><code>ClusterAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>The following cluster rules are available</p><ul><li><a href="#StochasticPrograms.LShaped.StaticCluster"><code>StaticCluster</code></a></li><li><a href="#StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}"><code>ClusterByReference</code></a></li><li>[<code>Kmedoids</code>](@ref</li><li><a href="#StochasticPrograms.LShaped.Hierarchical"><code>Hierarchical</code></a></li></ul><p>...</p><p><strong>Parameters</strong></p><ul><li><code>rule::ClusterRule</code>: Rule that determines how cuts should be sorted into clusters</li><li><code>lock_after::Function = (τ,n)-&gt;false</code>: Function that determines if the current aggregation scheme should be fixed, based on the current optimality gap <code>τ</code> and the number of iterations <code>n</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/cluster_aggregation.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.GranulatedAggregate" href="#StochasticPrograms.LShaped.GranulatedAggregate"><code>StochasticPrograms.LShaped.GranulatedAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GranulatedAggregate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.GranulatedAggregation"><code>GranulatedAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.  See ?GranulatedAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/granulated_aggregation.jl#L107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.GranulatedAggregation" href="#StochasticPrograms.LShaped.GranulatedAggregation"><code>StochasticPrograms.LShaped.GranulatedAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GranulatedAggregation</code></pre><p>Functor object for using partial aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.GranulatedAggregate"><code>GranulatedAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>size::Int</code>: Number of cuts in each aggregate</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/granulated_aggregation.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.HybridAggregate" href="#StochasticPrograms.LShaped.HybridAggregate"><code>StochasticPrograms.LShaped.HybridAggregate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HybridAggregate(initial::AbstractAggregator, final::AbstractAggregator, τ::AbstractFloat)</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.HybridAggregation"><code>HybridAggregation</code></a>. Pass to <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute. See ?HybridAggregation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/hybrid_aggregation.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.HybridAggregation" href="#StochasticPrograms.LShaped.HybridAggregation"><code>StochasticPrograms.LShaped.HybridAggregation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HybridAggregation</code></pre><p>Functor object for using hybrid aggregation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.HybridAggregate"><code>HybridAggregate</code></a> object through <code>aggregate</code> in <code>LShaped.Optimizer</code> or by setting the <a href="#StochasticPrograms.LShaped.Aggregator"><code>Aggregator</code></a> attribute.</p><p>...</p><p><strong>Parameters</strong></p><ul><li><code>initial::AbstractAggregator</code>: Initial aggregation scheme</li><li><code>final::AbstractAggregator</code>: Final aggregation scheme</li><li><code>τ::T</code>: The active aggregation scheme is switched from <code>initial</code> to <code>final</code> when the optimality gap decreases below <code>τ</code></li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/hybrid_aggregation.jl#L15-L26">source</a></section></article><h3 id="Selection-rules"><a class="docs-heading-anchor" href="#Selection-rules">Selection rules</a><a id="Selection-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Selection-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectClosest" href="#StochasticPrograms.LShaped.SelectClosest"><code>StochasticPrograms.LShaped.SelectClosest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectClosest(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Incoming cuts are placed into the closest aggregate, according the supplied <code>distance</code> function. An empty aggregate is chosen if no aggregate is within the tolerance <code>τ</code></p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectDecaying" href="#StochasticPrograms.LShaped.SelectDecaying"><code>StochasticPrograms.LShaped.SelectDecaying</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectDecaying(T₀::Integer, T̲::Integer = 1, γ::T)</code></pre><p>Behaves like <a href="#StochasticPrograms.LShaped.SelectUniform"><code>SelectUniform</code></a>, but the uniform aggregate size decays by <code>γ</code> each iteration, starting from <code>T₀</code>. <code>T̲</code> is an optional lower bound on the aggregate size.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectRandom" href="#StochasticPrograms.LShaped.SelectRandom"><code>StochasticPrograms.LShaped.SelectRandom</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectRandom(max = Inf)</code></pre><p>Incoming cuts are placed into aggregates randomly. An optional maximum number of cuts <code>max</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L70-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SelectUniform" href="#StochasticPrograms.LShaped.SelectUniform"><code>StochasticPrograms.LShaped.SelectUniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SelectUniform(n::Integer)</code></pre><p>Incoming cuts are placed into aggregates uniformly, so that each aggregate has at most <code>n</code> cuts. Behaves as <a href="#StochasticPrograms.LShaped.PartialAggregation"><code>PartialAggregation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.SortByReference" href="#StochasticPrograms.LShaped.SortByReference"><code>StochasticPrograms.LShaped.SortByReference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SortByReference(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Incoming cuts are placed into an aggregate based on the distance to a reference cut, according the supplied <code>distance</code> function. Behaves as <a href="#StochasticPrograms.LShaped.SelectClosest"><code>SelectClosest</code></a> if not withing the tolerance <code>τ</code> to the reference cut.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/selection_rules.jl#L134-L144">source</a></section></article><h3 id="Cluster-rules"><a class="docs-heading-anchor" href="#Cluster-rules">Cluster rules</a><a id="Cluster-rules-1"></a><a class="docs-heading-anchor-permalink" href="#Cluster-rules" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}" href="#StochasticPrograms.LShaped.ClusterByReference-Tuple{AbstractFloat}"><code>StochasticPrograms.LShaped.ClusterByReference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ClusterByReference(τ::AbstractFloat; distance::Function = absolute_distance)</code></pre><p>Buffered cuts are aggregated if within the tolerance <code>τ</code> to a reference cut, according the supplied <code>distance</code> function. Behaves as multi-cut otherwise.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L46-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Hierarchical" href="#StochasticPrograms.LShaped.Hierarchical"><code>StochasticPrograms.LShaped.Hierarchical</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hierarchical(nclusters::Int; distance::Function = absolute_distance, linkage::Symbol = :single)</code></pre><p>Buffered cuts are sorted into <code>nclusters</code> clusters, using a Hierarchical algorithm, with the given <code>linkage</code>, over a generalized <code>distance</code> matrix.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L140-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Kmedoids" href="#StochasticPrograms.LShaped.Kmedoids"><code>StochasticPrograms.LShaped.Kmedoids</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Kmedoids(nclusters::Int; distance::Function = absolute_distance)</code></pre><p>Buffered cuts are sorted into <code>nclusters</code> clusters, using a K-medoids algorithm over a generalized <code>distance</code> matrix.</p><p>The following distance measures are available</p><ul><li><a href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>absolute_distance</code></a></li><li><a href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>angular_distance</code></a></li><li>[<code>spatioangular_distance</code>](@ref</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L86-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.StaticCluster" href="#StochasticPrograms.LShaped.StaticCluster"><code>StochasticPrograms.LShaped.StaticCluster</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StaticCluster(clusters::Vector{Float64})</code></pre><p>Buffered cuts are sorting according to the supplied weights <code>clusters</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/cluster_rules.jl#L3-L8">source</a></section></article><h3 id="Distance-measures"><a class="docs-heading-anchor" href="#Distance-measures">Distance measures</a><a id="Distance-measures-1"></a><a class="docs-heading-anchor-permalink" href="#Distance-measures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}" href="#StochasticPrograms.LShaped.absolute_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShaped.absolute_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">absolute_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Absolute distance between two optimality cuts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}" href="#StochasticPrograms.LShaped.angular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShaped.angular_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Angular distance between two optimality cuts</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.spatioangular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}" href="#StochasticPrograms.LShaped.spatioangular_distance-Tuple{Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T,Union{StochasticPrograms.LShaped.AggregatedOptimalityCut{T,A}, StochasticPrograms.LShaped.HyperPlane{StochasticPrograms.LShaped.OptimalityCut,T,A}} where A where T}"><code>StochasticPrograms.LShaped.spatioangular_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spatioangular_distance(c₁::AnyOptimalityCut, c₂::AnyOptimalityCut)</code></pre><p>Spatioangular distance between two optimality cuts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/aggregators/distance_measures.jl#L35-L40">source</a></section></article><h2 id="Consolidation"><a class="docs-heading-anchor" href="#Consolidation">Consolidation</a><a id="Consolidation-1"></a><a class="docs-heading-anchor-permalink" href="#Consolidation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attribute" href="#StochasticPrograms.LShaped.set_consolidation_attribute"><code>StochasticPrograms.LShaped.set_consolidation_attribute</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_consolidation_attribute(stochasticprogram::StochasticProgram, name::Union{Symbol, String}, value)</code></pre><p>Sets the consolidation-specific attribute identified by <code>name</code> to <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L625-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.set_consolidation_attributes" href="#StochasticPrograms.LShaped.set_consolidation_attributes"><code>StochasticPrograms.LShaped.set_consolidation_attributes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_consolidation_attributes(stochasticprogram::StochasticProgram, pairs::Pair...)</code></pre><p>Given a list of <code>attribute =&gt; value</code> pairs or a collection of keyword arguments, calls <code>set_consolidation_attribute(stochasticprogram, attribute, value)</code> for each pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/MOI_wrapper.jl#L634-L640">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Consolidate" href="#StochasticPrograms.LShaped.Consolidate"><code>StochasticPrograms.LShaped.Consolidate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Consolidate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.Consolidation"><code>Consolidation</code></a>. Pass to <code>consolidate</code> in the <code>LShapedSolver</code> factory function. See ?Consolidation for parameter descriptions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/consolidators/consolidation.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.Consolidation" href="#StochasticPrograms.LShaped.Consolidation"><code>StochasticPrograms.LShaped.Consolidation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Consolidation</code></pre><p>Functor object for using consolidation in an L-shaped algorithm. Create by supplying a <a href="#StochasticPrograms.LShaped.Consolidate"><code>Consolidate</code></a> object through <code>consolidate</code> in the <code>LShapedSolver</code> factory function and then pass to a <code>StochasticPrograms.jl</code> model.</p><p>...</p><p><strong>Algorithm parameters</strong></p><ul><li><code>tresh::T</code> = 0.95: Relative amount of redundant cuts in a former iteration required to consider the iteration redundant</li><li><code>at::Int = 5.0</code>: Number of times an iteration can be redundant before consolidation is triggered</li><li><code>rebuild::Function = at_tolerance()</code>: Function deciding when the master model should be rebuilt according to performed consolidations</li></ul><p>...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/consolidators/consolidation.jl#L52-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.DontConsolidate" href="#StochasticPrograms.LShaped.DontConsolidate"><code>StochasticPrograms.LShaped.DontConsolidate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DontConsolidate</code></pre><p>Factory object for <a href="#StochasticPrograms.LShaped.NoConsolidation"><code>NoConsolidation</code></a>. Passed by default to <code>consolidate</code> in the <code>LShapedSolver</code> factory function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/consolidators/consolidation.jl#L185-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.NoConsolidation" href="#StochasticPrograms.LShaped.NoConsolidation"><code>StochasticPrograms.LShaped.NoConsolidation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoRegularization</code></pre><p>Empty functor object for running the L-shaped algorithm without consolidation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/consolidators/consolidation.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.RawConsolidationParameter" href="#StochasticPrograms.LShaped.RawConsolidationParameter"><code>StochasticPrograms.LShaped.RawConsolidationParameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RawConsolidationParameter</code></pre><p>An optimizer attribute used for raw parameters of the consolidator. Defers to <code>RawParameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/consolidators/consolidation.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StochasticPrograms.LShaped.at_tolerance-Tuple{}" href="#StochasticPrograms.LShaped.at_tolerance-Tuple{}"><code>StochasticPrograms.LShaped.at_tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">at_tolerance(τ = 0.4, miniter = 0)</code></pre><p>Rebuild master when at least nconsolidations*<code>miniter</code> iterations has passed and the ratio of number of cuts in the consolidated collection and the number of cuts in the master model has decreased below <code>τ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/3570e1a0f712645af87c9c93473cef35194860e3/src/solvers/structured/lshaped/consolidators/consolidation.jl#L170-L175">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../crash/">« Crash</a><a class="docs-footer-nextpage" href="../progressivehedging/">Progressive-hedging solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 22 December 2020 16:44">Tuesday 22 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
