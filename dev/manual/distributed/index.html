<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Distributed stochastic programs · StochasticPrograms.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StochasticPrograms.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickstart/">Quick start</a></li><li><a class="tocitem" href="../data/">Stochastic data</a></li><li><a class="tocitem" href="../model/">Stochastic models</a></li><li><a class="tocitem" href="../decisions/">Decision API</a></li><li class="is-active"><a class="tocitem" href>Distributed stochastic programs</a></li><li><a class="tocitem" href="../structuredsolvers/">Structured solvers</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/public/">Public interface</a></li><li><a class="tocitem" href="../../library/solverinterface/">Solver interface</a></li><li><a class="tocitem" href="../../library/crash/">Crash</a></li><li><a class="tocitem" href="../../library/lshaped/">L-shaped solvers</a></li><li><a class="tocitem" href="../../library/progressivehedging/">Progressive-hedging solvers</a></li><li><a class="tocitem" href="../../library/quasigradient/">Quasi-gradient solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Distributed stochastic programs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Distributed stochastic programs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/manual/distributed.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Distributed-stochastic-programs"><a class="docs-heading-anchor" href="#Distributed-stochastic-programs">Distributed stochastic programs</a><a id="Distributed-stochastic-programs-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-stochastic-programs" title="Permalink"></a></h1><p>Stochastic programs related to industrial applications are often associated with complex models and vast numbers of scenarios, often in the order of <code>1000-1000000</code>. Hence, the extensive form can have billions of variables and constraints, and often does not fit in memory on a single machine. This clarifies the need for solution approaches that work in parallel on distributed data when instantiating and optimizing large-scale stochastic programs.</p><p>If multiple Julia processes are available, locally or in a cluster, StochasticPrograms natively distributes any defined stochastic programs on the available processing nodes. Consider as before:</p><pre><code class="language-julia hljs">using Distributed

addprocs(3)

@everywhere using StochasticPrograms
@everywhere using Distributions

@sampler SimpleSampler = begin
    N::MvNormal

    SimpleSampler(μ, Σ) = new(MvNormal(μ, Σ))

    @sample Scenario begin
        x = rand(sampler.N)
        return Scenario(q₁ = x[1], q₂ = x[2], d₁ = x[3], d₂ = x[4])
    end
end

μ = [28, 32, 300, 300]
Σ = [2 0.5 0 0
     0.5 1 0 0
     0 0 50 20
     0 0 20 30]

sampler = SimpleSampler(μ, Σ)</code></pre><p><a href="../../library/public/#StochasticPrograms.@scenario"><code>@scenario</code></a> and <a href="../../library/public/#StochasticPrograms.@sampler"><code>@sampler</code></a> automatically ensures that the introduced scenario and sampler types are available on all processes. Define the stochastic model in the usual way:</p><pre><code class="language-julia hljs">@stochastic_model simple_model begin
    @stage 1 begin
        @decision(simple_model, x₁ &gt;= 40)
        @decision(simple_model, x₂ &gt;= 20)
        @objective(simple_model, Min, 100*x₁ + 150*x₂)
        @constraint(simple_model, x₁ + x₂ &lt;= 120)
    end
    @stage 2 begin
        @uncertain q₁ q₂ d₁ d₂ from SimpleScenario
        @recourse(simple_model, 0 &lt;= y₁ &lt;= d₁)
        @recourse(simple_model, 0 &lt;= y₂ &lt;= d₂)
        @objective(simple_model, Min, q₁*y₁ + q₂*y₂)
        @constraint(simple_model, 6*y₁ + 10*y₂ &lt;= 60*x₁)
        @constraint(simple_model, 8*y₁ + 5*y₂ &lt;= 80*x₂)
    end
end</code></pre><p>and instantiate a sampled model with 10 sceanarios:</p><pre><code class="language-julia hljs">sp = instantiate(simple_model, sampler, 10)</code></pre><p>the lightweight model recipes are passed to all worker nodes. The worker nodes then use the recipes and lightweight sampler object to instantiate second stage models in parallel. This is one of the intended outcomes of the design choices made in StochasticPrograms. The separation between data design and model design allows us to minimize data passing in a natural way.</p><p>Many operations in StochasticPrograms are embarassingly parallel which is exploited throughout when a stochastic program is distributed. Notably:</p><ul><li><a href="../../library/public/#StochasticPrograms.evaluate_decision-Tuple{StochasticModel{2, P} where P&lt;:Tuple{StageParameters, StageParameters}, AbstractVector{T} where T, AbstractSampler}"><code>evaluate_decision</code></a></li><li><a href="../../library/public/#StochasticPrograms.EVPI-Tuple{StochasticModel{2, P} where P&lt;:Tuple{StageParameters, StageParameters}, AbstractSampler}"><code>EVPI</code></a></li><li><a href="../../library/public/#StochasticPrograms.VSS-Tuple{StochasticModel{2, P} where P&lt;:Tuple{StageParameters, StageParameters}, AbstractSampler}"><code>VSS</code></a></li></ul><p>Perform many subproblem independent operations in parallel. The best performance is achieved if the optimization of the recourse problem is performed by an algorithm that can operate in parallel on the distributed stochastic programs. The solver suites provided by the <code>LShaped</code> and <code>ProgressiveHedging</code> modules are examples of this. For example, we can optimize the distributed version of the simple stochastic program with a parallelized L-shaped algorithm as follows:</p><pre><code class="language-julia hljs">using GLPK

sp = instantiate(simple_model, sampler, 10, optimizer = () -&gt; LShaped.Optimizer(GLPK.Optimizer))

optimize!(sp)</code></pre><pre><code class="language-julia hljs">Distributed L-Shaped Gap  Time: 0:00:03 (6 iterations)
  Objective:       -855.8333333333339
  Gap:             0.0
  Number of cuts:  7</code></pre><p>A quick note should also be made about the API calls that become less efficient in a distributed setting. This includes all calls that collect data that reside on remote processes. The functions in this category that involve the most data passing is <a href="../../library/public/#StochasticPrograms.scenarios-Union{Tuple{StochasticProgram{N, S, ST} where {S&lt;:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST&lt;:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S&lt;:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST&lt;:AbstractStochasticStructure{N}}, Integer}} where N"><code>scenarios</code></a>, which fetches all scenarios in the stochastic program, and <a href="../../library/public/#StochasticPrograms.subproblems-Union{Tuple{StochasticProgram{N, S, ST} where {S&lt;:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST&lt;:AbstractStochasticStructure{N}}}, Tuple{N}, Tuple{StochasticProgram{N, S, ST} where {S&lt;:Tuple{Vararg{StochasticPrograms.Stage, N}}, ST&lt;:AbstractStochasticStructure{N}}, Integer}} where N"><code>subproblems</code></a>, which fetches all second stage models in the stochastic program. If these collections are required frequently it is recommended to not distribute the stochastic program. This can be ensured by supplying <code>procs = [1]</code> to the constructor call. Individual queries <code>scenario(stochasticprogram, i)</code> and <code>subproblem(stochasticprogram, i)</code> are viable depending on the size of the scenarios/models. If a <code>MathProgBase</code> solver is supplied to a distributed stochastic program it will fetch all scenarios to the master node and attempt to build the extensive form. Long computation times are expected for large-scale models, assuming they fit in memory. If so, it is again recommended to avoid distributing the stochastic program through <code>procs = [1]</code>. The best approach is to use a structured solver that can operate on distributed stochastic programs, such as <code>LShaped</code> or <code>ProgressiveHedging</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../decisions/">« Decision API</a><a class="docs-footer-nextpage" href="../structuredsolvers/">Structured solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 4 September 2022 10:25">Sunday 4 September 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
