<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples ¬∑ StochasticPrograms.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">StochasticPrograms.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickstart/">Quick start</a></li><li><a class="tocitem" href="../data/">Stochastic data</a></li><li><a class="tocitem" href="../model/">Stochastic models</a></li><li><a class="tocitem" href="../decisions/">Decision API</a></li><li><a class="tocitem" href="../distributed/">Distributed stochastic programs</a></li><li><a class="tocitem" href="../structuredsolvers/">Structured solvers</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Farmer-problem"><span>Farmer problem</span></a></li><li><a class="tocitem" href="#Continuous-scenario-distribution"><span>Continuous scenario distribution</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/public/">Public interface</a></li><li><a class="tocitem" href="../../library/solverinterface/">Solver interface</a></li><li><a class="tocitem" href="../../library/crash/">Crash</a></li><li><a class="tocitem" href="../../library/lshaped/">L-shaped solvers</a></li><li><a class="tocitem" href="../../library/progressivehedging/">Progressive-hedging solvers</a></li><li><a class="tocitem" href="../../library/quasigradient/">Quasi-gradient solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/martinbiel/StochasticPrograms.jl/blob/master/docs/src/manual/examples.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><h2 id="Farmer-problem"><a class="docs-heading-anchor" href="#Farmer-problem">Farmer problem</a><a id="Farmer-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Farmer-problem" title="Permalink"></a></h2><p>The following defines the well-known &quot;Farmer problem&quot;, first outlined in <a href="https://link.springer.com/book/10.1007%2F978-1-4614-0237-4">Introduction to Stochastic Programming</a>, in StochasticPrograms. The problem revolves around a farmer who needs to decide how to partition his land to sow three different crops. The uncertainty comes from not knowing what the future yield of each crop will be. Recourse decisions involve purchasing/selling crops at the market.</p><pre><code class="language-julia hljs">using StochasticPrograms
using GLPK</code></pre><p>An example implementation of the farmer problem is given by:</p><pre><code class="language-julia hljs">Crops = [:wheat, :corn, :beets]
@stochastic_model farmer_model begin
    @stage 1 begin
        @parameters begin
            Crops = Crops
            Cost = Dict(:wheat=&gt;150, :corn=&gt;230, :beets=&gt;260)
            Budget = 500
        end
        @decision(farmer_model, x[c in Crops] &gt;= 0)
        @objective(farmer_model, Min, sum(Cost[c]*x[c] for c in Crops))
        @constraint(farmer_model, sum(x[c] for c in Crops) &lt;= Budget)
    end
    @stage 2 begin
        @parameters begin
            Crops = Crops
            Required = Dict(:wheat=&gt;200, :corn=&gt;240, :beets=&gt;0)
            PurchasePrice = Dict(:wheat=&gt;238, :corn=&gt;210)
            SellPrice = Dict(:wheat=&gt;170, :corn=&gt;150, :beets=&gt;36, :extra_beets=&gt;10)
        end
        @uncertain Œæ[c in Crops]
        @recourse(farmer_model, y[p in setdiff(Crops, [:beets])] &gt;= 0)
        @recourse(farmer_model, w[s in Crops ‚à™ [:extra_beets]] &gt;= 0)
        @objective(farmer_model, Min, sum(PurchasePrice[p] * y[p] for p in setdiff(Crops, [:beets]))
                   - sum(SellPrice[s] * w[s] for s in Crops ‚à™ [:extra_beets]))
        @constraint(farmer_model, minimum_requirement[p in setdiff(Crops, [:beets])],
            Œæ[p] * x[p] + y[p] - w[p] &gt;= Required[p])
        @constraint(farmer_model, minimum_requirement_beets,
            Œæ[:beets] * x[:beets] - w[:beets] - w[:extra_beets] &gt;= Required[:beets])
        @constraint(farmer_model, beets_quota, w[:beets] &lt;= 6000)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Two-Stage Stochastic Model

minimize f‚ÇÄ(x) + ùîº[f(x,Œæ)]
  x‚ààùí≥

where

f(x,Œæ) = min  f(y; x, Œæ)
              y ‚àà ùí¥ (x, Œæ)
</code></pre><p>The three yield scenarios can be defined through:</p><pre><code class="language-julia hljs">Œæ‚ÇÅ = @scenario Œæ[c in Crops] = [3.0, 3.6, 24.0] probability = 1/3
Œæ‚ÇÇ = @scenario Œæ[c in Crops] = [2.5, 3.0, 20.0] probability = 1/3
Œæ‚ÇÉ = @scenario Œæ[c in Crops] = [2.0, 2.4, 16.0] probability = 1/3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Scenario with probability 0.3333333333333333 and underlying data:

1-dimensional DenseAxisArray{Float64,1,...} with index sets:
    Dimension 1, [:wheat, :corn, :beets]
And data, a 3-element Vector{Float64}:
  2.0
  2.4
 16.0</code></pre><p>We can now instantiate the farmer problem using the defined stochastic farmer_model and the three yield scenarios:</p><pre><code class="language-julia hljs">farmer = instantiate(farmer_model, [Œæ‚ÇÅ,Œæ‚ÇÇ,Œæ‚ÇÉ], optimizer = GLPK.Optimizer)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Stochastic program with:
 * 3 decision variables
 * 6 recourse variables
 * 3 scenarios of type Scenario
Structure: Deterministic equivalent
Solver name: GLPK</code></pre><p>Printing:</p><pre><code class="language-julia hljs">print(farmer)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Deterministic equivalent problem
Min 150 x[wheat] + 230 x[corn] + 260 x[beets] + 79.33333333333333 y‚ÇÅ[wheat] + 70 y‚ÇÅ[corn] - 56.666666666666664 w‚ÇÅ[wheat] - 50 w‚ÇÅ[corn] - 12 w‚ÇÅ[beets] - 3.333333333333333 w‚ÇÅ[extra_beets] + 79.33333333333333 y‚ÇÇ[wheat] + 70 y‚ÇÇ[corn] - 56.666666666666664 w‚ÇÇ[wheat] - 50 w‚ÇÇ[corn] - 12 w‚ÇÇ[beets] - 3.333333333333333 w‚ÇÇ[extra_beets] + 79.33333333333333 y‚ÇÉ[wheat] + 70 y‚ÇÉ[corn] - 56.666666666666664 w‚ÇÉ[wheat] - 50 w‚ÇÉ[corn] - 12 w‚ÇÉ[beets] - 3.333333333333333 w‚ÇÉ[extra_beets]
Subject to
 x[wheat] ‚àà Decisions
 x[corn] ‚àà Decisions
 x[beets] ‚àà Decisions
 y‚ÇÅ[wheat] ‚àà RecourseDecisions
 y‚ÇÅ[corn] ‚àà RecourseDecisions
 w‚ÇÅ[wheat] ‚àà RecourseDecisions
 w‚ÇÅ[corn] ‚àà RecourseDecisions
 w‚ÇÅ[beets] ‚àà RecourseDecisions
 w‚ÇÅ[extra_beets] ‚àà RecourseDecisions
 y‚ÇÇ[wheat] ‚àà RecourseDecisions
 y‚ÇÇ[corn] ‚àà RecourseDecisions
 w‚ÇÇ[wheat] ‚àà RecourseDecisions
 w‚ÇÇ[corn] ‚àà RecourseDecisions
 w‚ÇÇ[beets] ‚àà RecourseDecisions
 w‚ÇÇ[extra_beets] ‚àà RecourseDecisions
 y‚ÇÉ[wheat] ‚àà RecourseDecisions
 y‚ÇÉ[corn] ‚àà RecourseDecisions
 w‚ÇÉ[wheat] ‚àà RecourseDecisions
 w‚ÇÉ[corn] ‚àà RecourseDecisions
 w‚ÇÉ[beets] ‚àà RecourseDecisions
 w‚ÇÉ[extra_beets] ‚àà RecourseDecisions
 x[wheat] ‚â• 0.0
 x[corn] ‚â• 0.0
 x[beets] ‚â• 0.0
 y‚ÇÅ[wheat] ‚â• 0.0
 y‚ÇÅ[corn] ‚â• 0.0
 w‚ÇÅ[wheat] ‚â• 0.0
 w‚ÇÅ[corn] ‚â• 0.0
 w‚ÇÅ[beets] ‚â• 0.0
 w‚ÇÅ[extra_beets] ‚â• 0.0
 y‚ÇÇ[wheat] ‚â• 0.0
 y‚ÇÇ[corn] ‚â• 0.0
 w‚ÇÇ[wheat] ‚â• 0.0
 w‚ÇÇ[corn] ‚â• 0.0
 w‚ÇÇ[beets] ‚â• 0.0
 w‚ÇÇ[extra_beets] ‚â• 0.0
 y‚ÇÉ[wheat] ‚â• 0.0
 y‚ÇÉ[corn] ‚â• 0.0
 w‚ÇÉ[wheat] ‚â• 0.0
 w‚ÇÉ[corn] ‚â• 0.0
 w‚ÇÉ[beets] ‚â• 0.0
 w‚ÇÉ[extra_beets] ‚â• 0.0
 x[wheat] + x[corn] + x[beets] ‚â§ 500.0
 beets_quota‚ÇÅ : w‚ÇÅ[beets] ‚â§ 6000.0
 beets_quota‚ÇÇ : w‚ÇÇ[beets] ‚â§ 6000.0
 beets_quota‚ÇÉ : w‚ÇÉ[beets] ‚â§ 6000.0
 minimum_requirement‚ÇÅ[wheat] : 3 x[wheat] + y‚ÇÅ[wheat] - w‚ÇÅ[wheat] ‚â• 200.0
 minimum_requirement‚ÇÅ[corn] : 3.6 x[corn] + y‚ÇÅ[corn] - w‚ÇÅ[corn] ‚â• 240.0
 minimum_requirement_beets‚ÇÅ : 24 x[beets] - w‚ÇÅ[beets] - w‚ÇÅ[extra_beets] ‚â• 0.0
 minimum_requirement‚ÇÇ[wheat] : 2.5 x[wheat] + y‚ÇÇ[wheat] - w‚ÇÇ[wheat] ‚â• 200.0
 minimum_requirement‚ÇÇ[corn] : 3 x[corn] + y‚ÇÇ[corn] - w‚ÇÇ[corn] ‚â• 240.0
 minimum_requirement_beets‚ÇÇ : 20 x[beets] - w‚ÇÇ[beets] - w‚ÇÇ[extra_beets] ‚â• 0.0
 minimum_requirement‚ÇÉ[wheat] : 2 x[wheat] + y‚ÇÉ[wheat] - w‚ÇÉ[wheat] ‚â• 200.0
 minimum_requirement‚ÇÉ[corn] : 2.4 x[corn] + y‚ÇÉ[corn] - w‚ÇÉ[corn] ‚â• 240.0
 minimum_requirement_beets‚ÇÉ : 16 x[beets] - w‚ÇÉ[beets] - w‚ÇÉ[extra_beets] ‚â• 0.0
Solver name: GLPK</code></pre><p>We can now optimize the farmer_model:</p><pre><code class="language-julia hljs">optimize!(farmer)
x = optimal_decision(farmer)
x = farmer[1,:x]
println(&quot;Wheat: $(value(x[:wheat]))&quot;)
println(&quot;Corn: $(value(x[:corn]))&quot;)
println(&quot;Beets: $(value(x[:beets]))&quot;)
println(&quot;Profit: $(objective_value(farmer))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Wheat: 170.00000000000006
Corn: 80.00000000000001
Beets: 250.0
Profit: -108390.00000000001</code></pre><p>We can also check results for a specific scenario:</p><pre><code class="language-julia hljs">y = farmer[2,:y]
w = farmer[2,:w]
println(&quot;Purchased wheat: $(value(y[:wheat], 1))&quot;)
println(&quot;Purchased corn: $(value(y[:corn], 1))&quot;)
println(&quot;Sold wheat: $(value(w[:wheat], 1))&quot;)
println(&quot;Sold corn: $(value(w[:corn], 1))&quot;)
println(&quot;Sold beets: $(value(w[:extra_beets], 1))&quot;)
println(&quot;Profit: $(objective_value(farmer, 1))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Purchased wheat: 0.0
Purchased corn: 0.0
Sold wheat: 310.00000000000017
Sold corn: 48.000000000000036
Sold beets: 0.0
Profit: -275900.00000000006</code></pre><p>Finally, we calculate the stochastic performance of the farmer_model:</p><pre><code class="language-julia hljs">println(&quot;EVPI: $(EVPI(farmer))&quot;)
println(&quot;VSS: $(VSS(farmer))&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EVPI: 7015.555555555533
VSS: 1150.0000000000146</code></pre><h2 id="Continuous-scenario-distribution"><a class="docs-heading-anchor" href="#Continuous-scenario-distribution">Continuous scenario distribution</a><a id="Continuous-scenario-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-scenario-distribution" title="Permalink"></a></h2><p>As an example, consider the following generalized stochastic program:</p><p class="math-container">\[\begin{aligned}
 \operatorname*{minimize}_{x \in \mathbb{R}} &amp; \quad \operatorname{\mathbb{E}}_{\omega} \left[(x - \xi(\omega))^2\right] \\
\end{aligned}\]</p><p>where <span>$\xi(\omega)$</span> is exponentially distributed. We will skip the mathematical details here and just take for granted that the optimizer to the above problem is the mean of the exponential distribution. We will try to approximately solve this problem using sample average approximation. First, lets try to introduce a custom discrete scenario type that farmer_models a stochastic variable with a continuous probability distribution. Consider the following implementation:</p><pre><code class="language-julia hljs">using StochasticPrograms
using Distributions

struct DistributionScenario{D &lt;: UnivariateDistribution} &lt;: AbstractScenario
    probability::Probability
    distribution::D
    Œæ::Float64

    function DistributionScenario(distribution::UnivariateDistribution, val::AbstractFloat)
        return new{typeof(distribution)}(Probability(pdf(distribution, val)), distribution, Float64(val))
    end
end

function StochasticPrograms.expected(scenarios::Vector{&lt;:DistributionScenario{D}}) where D &lt;: UnivariateDistribution
    isempty(scenarios) &amp;&amp; return DistributionScenario(D(), 0.0)
    distribution = scenarios[1].distribution
    return ExpectedScenario(DistributionScenario(distribution, mean(distribution)))
end</code></pre><p>The fallback <a href="../../library/public/#StochasticPrograms.probability-Tuple{AbstractScenario}"><code>probability</code></a> method is viable as long as the scenario type contains a <a href="../../library/public/#StochasticPrograms.Probability"><code>Probability</code></a> field named <code>probability</code>. The implementation of <a href="../../library/public/#StochasticPrograms.expected-Union{Tuple{Vector{S}}, Tuple{S}} where S&lt;:AbstractScenario"><code>expected</code></a> is somewhat unconventional as it returns the mean of the distribution regardless of how many scenarios are given.</p><p>We can implement a sampler that generates exponentially distributed scenarios as follows:</p><pre><code class="language-julia hljs">struct ExponentialSampler &lt;: AbstractSampler{DistributionScenario{Exponential{Float64}}}
    distribution::Exponential

    ExponentialSampler(Œ∏::AbstractFloat) = new(Exponential(Œ∏))
end

function (sampler::ExponentialSampler)()
    Œæ = rand(sampler.distribution)
    return DistributionScenario(sampler.distribution, Œæ)
end</code></pre><p>Now, lets attempt to define the generalized stochastic program using the available farmer_modeling tools:</p><pre><code class="language-julia hljs">using Ipopt

sm = @stochastic begin
    @stage 1 begin
        @decision(model, x)
    end
    @stage 2 begin
        @uncertain Œæ from DistributionScenario
        @objective(model, Min, (x - Œæ)^2)
    end
end</code></pre><pre><code class="language-julia hljs">Two-Stage Stochastic Model

minimize f‚ÇÄ(x) + ùîº[f(x,Œæ)]
  x‚ààùí≥

where

f(x,Œæ) = min  f(y; x, Œæ)
              y ‚àà ùí¥ (x, Œæ)</code></pre><p>The mean of the given exponential distribution is <span>$2.0$</span>, which is the optimal solution to the general problem. Now, lets create a finite sampled farmer_model of 1000 exponentially distributed numbers:</p><pre><code class="language-julia hljs">sampler = ExponentialSampler(2.) # Create a sampler

sp = instantiate(sm, sampler, 1000, optimizer = Ipopt.Optimizer) # Sample 1000 exponentially distributed scenarios and create a sampled farmer_model</code></pre><pre><code class="language-julia hljs">Stochastic program with:
 * 1 decision variable
 * 1 recourse variable
 * 1000 scenarios of type DistributionScenario
Solver is default solver</code></pre><p>By the law of large numbers, we approach the generalized formulation with increasing sample size. Solving yields:</p><pre><code class="language-julia hljs">optimize!(sp)

println(&quot;Optimal decision: $(optimal_decision(sp))&quot;)
println(&quot;Optimal value: $(objective_value(sp))&quot;)</code></pre><pre><code class="language-julia hljs">Optimal decision: [2.0397762891884894]
Optimal value: 4.00553678799426</code></pre><p>Now, due to the special implementation of the <a href="../../library/public/#StochasticPrograms.expected-Union{Tuple{Vector{S}}, Tuple{S}} where S&lt;:AbstractScenario"><code>expected</code></a> function, it actually holds that the expected value solution solves the generalized problem. Consider:</p><pre><code class="language-julia hljs">println(&quot;Expected value decision: $(expected_value_decision(sp)&quot;)
println(&quot;VSS: $(VSS(sp))&quot;)</code></pre><pre><code class="language-julia hljs">EVP decision: [2.0]
VSS: 0.00022773669794418083</code></pre><p>Accordingly, the VSS is small.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../structuredsolvers/">¬´ Structured solvers</a><a class="docs-footer-nextpage" href="../../library/public/">Public interface ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.16 on <span class="colophon-date" title="Tuesday 3 May 2022 12:27">Tuesday 3 May 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
